// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onos/rsm/rsm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_onos_2frsm_2frsm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_onos_2frsm_2frsm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_onos_2frsm_2frsm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_onos_2frsm_2frsm_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_onos_2frsm_2frsm_2eproto;
namespace onos {
namespace rsm {
class Ack;
struct AckDefaultTypeInternal;
extern AckDefaultTypeInternal _Ack_default_instance_;
class CreateSliceRequest;
struct CreateSliceRequestDefaultTypeInternal;
extern CreateSliceRequestDefaultTypeInternal _CreateSliceRequest_default_instance_;
class CreateSliceResponse;
struct CreateSliceResponseDefaultTypeInternal;
extern CreateSliceResponseDefaultTypeInternal _CreateSliceResponse_default_instance_;
class DeleteSliceRequest;
struct DeleteSliceRequestDefaultTypeInternal;
extern DeleteSliceRequestDefaultTypeInternal _DeleteSliceRequest_default_instance_;
class DeleteSliceResponse;
struct DeleteSliceResponseDefaultTypeInternal;
extern DeleteSliceResponseDefaultTypeInternal _DeleteSliceResponse_default_instance_;
class SetUeSliceAssociationRequest;
struct SetUeSliceAssociationRequestDefaultTypeInternal;
extern SetUeSliceAssociationRequestDefaultTypeInternal _SetUeSliceAssociationRequest_default_instance_;
class SetUeSliceAssociationResponse;
struct SetUeSliceAssociationResponseDefaultTypeInternal;
extern SetUeSliceAssociationResponseDefaultTypeInternal _SetUeSliceAssociationResponse_default_instance_;
class SliceAssocItem;
struct SliceAssocItemDefaultTypeInternal;
extern SliceAssocItemDefaultTypeInternal _SliceAssocItem_default_instance_;
class SliceItem;
struct SliceItemDefaultTypeInternal;
extern SliceItemDefaultTypeInternal _SliceItem_default_instance_;
class UeId;
struct UeIdDefaultTypeInternal;
extern UeIdDefaultTypeInternal _UeId_default_instance_;
class UpdateSliceRequest;
struct UpdateSliceRequestDefaultTypeInternal;
extern UpdateSliceRequestDefaultTypeInternal _UpdateSliceRequest_default_instance_;
class UpdateSliceResponse;
struct UpdateSliceResponseDefaultTypeInternal;
extern UpdateSliceResponseDefaultTypeInternal _UpdateSliceResponse_default_instance_;
}  // namespace rsm
}  // namespace onos
PROTOBUF_NAMESPACE_OPEN
template<> ::onos::rsm::Ack* Arena::CreateMaybeMessage<::onos::rsm::Ack>(Arena*);
template<> ::onos::rsm::CreateSliceRequest* Arena::CreateMaybeMessage<::onos::rsm::CreateSliceRequest>(Arena*);
template<> ::onos::rsm::CreateSliceResponse* Arena::CreateMaybeMessage<::onos::rsm::CreateSliceResponse>(Arena*);
template<> ::onos::rsm::DeleteSliceRequest* Arena::CreateMaybeMessage<::onos::rsm::DeleteSliceRequest>(Arena*);
template<> ::onos::rsm::DeleteSliceResponse* Arena::CreateMaybeMessage<::onos::rsm::DeleteSliceResponse>(Arena*);
template<> ::onos::rsm::SetUeSliceAssociationRequest* Arena::CreateMaybeMessage<::onos::rsm::SetUeSliceAssociationRequest>(Arena*);
template<> ::onos::rsm::SetUeSliceAssociationResponse* Arena::CreateMaybeMessage<::onos::rsm::SetUeSliceAssociationResponse>(Arena*);
template<> ::onos::rsm::SliceAssocItem* Arena::CreateMaybeMessage<::onos::rsm::SliceAssocItem>(Arena*);
template<> ::onos::rsm::SliceItem* Arena::CreateMaybeMessage<::onos::rsm::SliceItem>(Arena*);
template<> ::onos::rsm::UeId* Arena::CreateMaybeMessage<::onos::rsm::UeId>(Arena*);
template<> ::onos::rsm::UpdateSliceRequest* Arena::CreateMaybeMessage<::onos::rsm::UpdateSliceRequest>(Arena*);
template<> ::onos::rsm::UpdateSliceResponse* Arena::CreateMaybeMessage<::onos::rsm::UpdateSliceResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace onos {
namespace rsm {

enum SliceType : int {
  SLICE_TYPE_DL_SLICE = 0,
  SLICE_TYPE_UL_SLICE = 1,
  SliceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SliceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SliceType_IsValid(int value);
constexpr SliceType SliceType_MIN = SLICE_TYPE_DL_SLICE;
constexpr SliceType SliceType_MAX = SLICE_TYPE_UL_SLICE;
constexpr int SliceType_ARRAYSIZE = SliceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SliceType_descriptor();
template<typename T>
inline const std::string& SliceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SliceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SliceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SliceType_descriptor(), enum_t_value);
}
inline bool SliceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SliceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SliceType>(
    SliceType_descriptor(), name, value);
}
enum SchedulerType : int {
  SCHEDULER_TYPE_ROUND_ROBIN = 0,
  SCHEDULER_TYPE_PROPORTIONALLY_FAIR = 1,
  SCHEDULER_TYPE_QOS_BASED = 2,
  SchedulerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SchedulerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SchedulerType_IsValid(int value);
constexpr SchedulerType SchedulerType_MIN = SCHEDULER_TYPE_ROUND_ROBIN;
constexpr SchedulerType SchedulerType_MAX = SCHEDULER_TYPE_QOS_BASED;
constexpr int SchedulerType_ARRAYSIZE = SchedulerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SchedulerType_descriptor();
template<typename T>
inline const std::string& SchedulerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SchedulerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SchedulerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SchedulerType_descriptor(), enum_t_value);
}
inline bool SchedulerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SchedulerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SchedulerType>(
    SchedulerType_descriptor(), name, value);
}
enum UeIdType : int {
  UE_ID_TYPE_CU_UE_F1_AP_ID = 0,
  UE_ID_TYPE_DU_UE_F1_AP_ID = 1,
  UE_ID_TYPE_RAN_UE_NGAP_ID = 2,
  UE_ID_TYPE_AMF_UE_NGAP_ID = 3,
  UE_ID_TYPE_ENB_UE_S1_AP_ID = 4,
  UeIdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UeIdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UeIdType_IsValid(int value);
constexpr UeIdType UeIdType_MIN = UE_ID_TYPE_CU_UE_F1_AP_ID;
constexpr UeIdType UeIdType_MAX = UE_ID_TYPE_ENB_UE_S1_AP_ID;
constexpr int UeIdType_ARRAYSIZE = UeIdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UeIdType_descriptor();
template<typename T>
inline const std::string& UeIdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UeIdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UeIdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UeIdType_descriptor(), enum_t_value);
}
inline bool UeIdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UeIdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UeIdType>(
    UeIdType_descriptor(), name, value);
}
// ===================================================================

class SliceItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.SliceItem) */ {
 public:
  inline SliceItem() : SliceItem(nullptr) {}
  ~SliceItem() override;
  explicit constexpr SliceItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SliceItem(const SliceItem& from);
  SliceItem(SliceItem&& from) noexcept
    : SliceItem() {
    *this = ::std::move(from);
  }

  inline SliceItem& operator=(const SliceItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SliceItem& operator=(SliceItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SliceItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SliceItem* internal_default_instance() {
    return reinterpret_cast<const SliceItem*>(
               &_SliceItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SliceItem& a, SliceItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SliceItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SliceItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SliceItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SliceItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SliceItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SliceItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SliceItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.SliceItem";
  }
  protected:
  explicit SliceItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSliceIdsFieldNumber = 2,
    kE2NodeIdFieldNumber = 1,
  };
  // repeated string slice_ids = 2;
  int slice_ids_size() const;
  private:
  int _internal_slice_ids_size() const;
  public:
  void clear_slice_ids();
  const std::string& slice_ids(int index) const;
  std::string* mutable_slice_ids(int index);
  void set_slice_ids(int index, const std::string& value);
  void set_slice_ids(int index, std::string&& value);
  void set_slice_ids(int index, const char* value);
  void set_slice_ids(int index, const char* value, size_t size);
  std::string* add_slice_ids();
  void add_slice_ids(const std::string& value);
  void add_slice_ids(std::string&& value);
  void add_slice_ids(const char* value);
  void add_slice_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& slice_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_slice_ids();
  private:
  const std::string& _internal_slice_ids(int index) const;
  std::string* _internal_add_slice_ids();
  public:

  // string e2_node_id = 1;
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.SliceItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> slice_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class Ack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.Ack) */ {
 public:
  inline Ack() : Ack(nullptr) {}
  ~Ack() override;
  explicit constexpr Ack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ack(const Ack& from);
  Ack(Ack&& from) noexcept
    : Ack() {
    *this = ::std::move(from);
  }

  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ack& operator=(Ack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ack& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ack* internal_default_instance() {
    return reinterpret_cast<const Ack*>(
               &_Ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ack& a, Ack& b) {
    a.Swap(&b);
  }
  inline void Swap(Ack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ack& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.Ack";
  }
  protected:
  explicit Ack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCauseFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string cause = 2;
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.Ack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class CreateSliceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.CreateSliceRequest) */ {
 public:
  inline CreateSliceRequest() : CreateSliceRequest(nullptr) {}
  ~CreateSliceRequest() override;
  explicit constexpr CreateSliceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSliceRequest(const CreateSliceRequest& from);
  CreateSliceRequest(CreateSliceRequest&& from) noexcept
    : CreateSliceRequest() {
    *this = ::std::move(from);
  }

  inline CreateSliceRequest& operator=(const CreateSliceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSliceRequest& operator=(CreateSliceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSliceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSliceRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSliceRequest*>(
               &_CreateSliceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateSliceRequest& a, CreateSliceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSliceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSliceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSliceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSliceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSliceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSliceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSliceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.CreateSliceRequest";
  }
  protected:
  explicit CreateSliceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kE2NodeIdFieldNumber = 1,
    kSliceIdFieldNumber = 2,
    kWeightFieldNumber = 4,
    kSchedulerTypeFieldNumber = 3,
    kSliceTypeFieldNumber = 5,
  };
  // string e2_node_id = 1;
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // string slice_id = 2;
  void clear_slice_id();
  const std::string& slice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slice_id();
  PROTOBUF_NODISCARD std::string* release_slice_id();
  void set_allocated_slice_id(std::string* slice_id);
  private:
  const std::string& _internal_slice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slice_id(const std::string& value);
  std::string* _internal_mutable_slice_id();
  public:

  // string weight = 4;
  void clear_weight();
  const std::string& weight() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weight(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weight();
  PROTOBUF_NODISCARD std::string* release_weight();
  void set_allocated_weight(std::string* weight);
  private:
  const std::string& _internal_weight() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weight(const std::string& value);
  std::string* _internal_mutable_weight();
  public:

  // .onos.rsm.SchedulerType scheduler_type = 3;
  void clear_scheduler_type();
  ::onos::rsm::SchedulerType scheduler_type() const;
  void set_scheduler_type(::onos::rsm::SchedulerType value);
  private:
  ::onos::rsm::SchedulerType _internal_scheduler_type() const;
  void _internal_set_scheduler_type(::onos::rsm::SchedulerType value);
  public:

  // .onos.rsm.SliceType sliceType = 5;
  void clear_slicetype();
  ::onos::rsm::SliceType slicetype() const;
  void set_slicetype(::onos::rsm::SliceType value);
  private:
  ::onos::rsm::SliceType _internal_slicetype() const;
  void _internal_set_slicetype(::onos::rsm::SliceType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.CreateSliceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weight_;
  int scheduler_type_;
  int slicetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class CreateSliceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.CreateSliceResponse) */ {
 public:
  inline CreateSliceResponse() : CreateSliceResponse(nullptr) {}
  ~CreateSliceResponse() override;
  explicit constexpr CreateSliceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSliceResponse(const CreateSliceResponse& from);
  CreateSliceResponse(CreateSliceResponse&& from) noexcept
    : CreateSliceResponse() {
    *this = ::std::move(from);
  }

  inline CreateSliceResponse& operator=(const CreateSliceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSliceResponse& operator=(CreateSliceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSliceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSliceResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSliceResponse*>(
               &_CreateSliceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateSliceResponse& a, CreateSliceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSliceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSliceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSliceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSliceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSliceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSliceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSliceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.CreateSliceResponse";
  }
  protected:
  explicit CreateSliceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // .onos.rsm.Ack ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::onos::rsm::Ack& ack() const;
  PROTOBUF_NODISCARD ::onos::rsm::Ack* release_ack();
  ::onos::rsm::Ack* mutable_ack();
  void set_allocated_ack(::onos::rsm::Ack* ack);
  private:
  const ::onos::rsm::Ack& _internal_ack() const;
  ::onos::rsm::Ack* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::onos::rsm::Ack* ack);
  ::onos::rsm::Ack* unsafe_arena_release_ack();

  // @@protoc_insertion_point(class_scope:onos.rsm.CreateSliceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::rsm::Ack* ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class UpdateSliceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.UpdateSliceRequest) */ {
 public:
  inline UpdateSliceRequest() : UpdateSliceRequest(nullptr) {}
  ~UpdateSliceRequest() override;
  explicit constexpr UpdateSliceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSliceRequest(const UpdateSliceRequest& from);
  UpdateSliceRequest(UpdateSliceRequest&& from) noexcept
    : UpdateSliceRequest() {
    *this = ::std::move(from);
  }

  inline UpdateSliceRequest& operator=(const UpdateSliceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSliceRequest& operator=(UpdateSliceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSliceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSliceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSliceRequest*>(
               &_UpdateSliceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateSliceRequest& a, UpdateSliceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSliceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSliceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSliceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSliceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSliceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSliceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSliceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.UpdateSliceRequest";
  }
  protected:
  explicit UpdateSliceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kE2NodeIdFieldNumber = 1,
    kSliceIdFieldNumber = 2,
    kWeightFieldNumber = 4,
    kSchedulerTypeFieldNumber = 3,
    kSliceTypeFieldNumber = 5,
  };
  // string e2_node_id = 1;
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // string slice_id = 2;
  void clear_slice_id();
  const std::string& slice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slice_id();
  PROTOBUF_NODISCARD std::string* release_slice_id();
  void set_allocated_slice_id(std::string* slice_id);
  private:
  const std::string& _internal_slice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slice_id(const std::string& value);
  std::string* _internal_mutable_slice_id();
  public:

  // string weight = 4;
  void clear_weight();
  const std::string& weight() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weight(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weight();
  PROTOBUF_NODISCARD std::string* release_weight();
  void set_allocated_weight(std::string* weight);
  private:
  const std::string& _internal_weight() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weight(const std::string& value);
  std::string* _internal_mutable_weight();
  public:

  // .onos.rsm.SchedulerType scheduler_type = 3;
  void clear_scheduler_type();
  ::onos::rsm::SchedulerType scheduler_type() const;
  void set_scheduler_type(::onos::rsm::SchedulerType value);
  private:
  ::onos::rsm::SchedulerType _internal_scheduler_type() const;
  void _internal_set_scheduler_type(::onos::rsm::SchedulerType value);
  public:

  // .onos.rsm.SliceType sliceType = 5;
  void clear_slicetype();
  ::onos::rsm::SliceType slicetype() const;
  void set_slicetype(::onos::rsm::SliceType value);
  private:
  ::onos::rsm::SliceType _internal_slicetype() const;
  void _internal_set_slicetype(::onos::rsm::SliceType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.UpdateSliceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weight_;
  int scheduler_type_;
  int slicetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class UpdateSliceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.UpdateSliceResponse) */ {
 public:
  inline UpdateSliceResponse() : UpdateSliceResponse(nullptr) {}
  ~UpdateSliceResponse() override;
  explicit constexpr UpdateSliceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSliceResponse(const UpdateSliceResponse& from);
  UpdateSliceResponse(UpdateSliceResponse&& from) noexcept
    : UpdateSliceResponse() {
    *this = ::std::move(from);
  }

  inline UpdateSliceResponse& operator=(const UpdateSliceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSliceResponse& operator=(UpdateSliceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSliceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSliceResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateSliceResponse*>(
               &_UpdateSliceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateSliceResponse& a, UpdateSliceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSliceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSliceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSliceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSliceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSliceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSliceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSliceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.UpdateSliceResponse";
  }
  protected:
  explicit UpdateSliceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // .onos.rsm.Ack ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::onos::rsm::Ack& ack() const;
  PROTOBUF_NODISCARD ::onos::rsm::Ack* release_ack();
  ::onos::rsm::Ack* mutable_ack();
  void set_allocated_ack(::onos::rsm::Ack* ack);
  private:
  const ::onos::rsm::Ack& _internal_ack() const;
  ::onos::rsm::Ack* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::onos::rsm::Ack* ack);
  ::onos::rsm::Ack* unsafe_arena_release_ack();

  // @@protoc_insertion_point(class_scope:onos.rsm.UpdateSliceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::rsm::Ack* ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class DeleteSliceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.DeleteSliceRequest) */ {
 public:
  inline DeleteSliceRequest() : DeleteSliceRequest(nullptr) {}
  ~DeleteSliceRequest() override;
  explicit constexpr DeleteSliceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSliceRequest(const DeleteSliceRequest& from);
  DeleteSliceRequest(DeleteSliceRequest&& from) noexcept
    : DeleteSliceRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSliceRequest& operator=(const DeleteSliceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSliceRequest& operator=(DeleteSliceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSliceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSliceRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSliceRequest*>(
               &_DeleteSliceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteSliceRequest& a, DeleteSliceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSliceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSliceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSliceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSliceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSliceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteSliceRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSliceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.DeleteSliceRequest";
  }
  protected:
  explicit DeleteSliceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kE2NodeIdFieldNumber = 1,
    kSliceIdFieldNumber = 2,
    kSliceTypeFieldNumber = 3,
  };
  // string e2_node_id = 1;
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // string slice_id = 2;
  void clear_slice_id();
  const std::string& slice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slice_id();
  PROTOBUF_NODISCARD std::string* release_slice_id();
  void set_allocated_slice_id(std::string* slice_id);
  private:
  const std::string& _internal_slice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slice_id(const std::string& value);
  std::string* _internal_mutable_slice_id();
  public:

  // .onos.rsm.SliceType sliceType = 3;
  void clear_slicetype();
  ::onos::rsm::SliceType slicetype() const;
  void set_slicetype(::onos::rsm::SliceType value);
  private:
  ::onos::rsm::SliceType _internal_slicetype() const;
  void _internal_set_slicetype(::onos::rsm::SliceType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.DeleteSliceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slice_id_;
  int slicetype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class DeleteSliceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.DeleteSliceResponse) */ {
 public:
  inline DeleteSliceResponse() : DeleteSliceResponse(nullptr) {}
  ~DeleteSliceResponse() override;
  explicit constexpr DeleteSliceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSliceResponse(const DeleteSliceResponse& from);
  DeleteSliceResponse(DeleteSliceResponse&& from) noexcept
    : DeleteSliceResponse() {
    *this = ::std::move(from);
  }

  inline DeleteSliceResponse& operator=(const DeleteSliceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSliceResponse& operator=(DeleteSliceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSliceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSliceResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteSliceResponse*>(
               &_DeleteSliceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteSliceResponse& a, DeleteSliceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSliceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSliceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSliceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSliceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSliceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteSliceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSliceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.DeleteSliceResponse";
  }
  protected:
  explicit DeleteSliceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAckFieldNumber = 1,
  };
  // .onos.rsm.Ack ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::onos::rsm::Ack& ack() const;
  PROTOBUF_NODISCARD ::onos::rsm::Ack* release_ack();
  ::onos::rsm::Ack* mutable_ack();
  void set_allocated_ack(::onos::rsm::Ack* ack);
  private:
  const ::onos::rsm::Ack& _internal_ack() const;
  ::onos::rsm::Ack* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::onos::rsm::Ack* ack);
  ::onos::rsm::Ack* unsafe_arena_release_ack();

  // @@protoc_insertion_point(class_scope:onos.rsm.DeleteSliceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::rsm::Ack* ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class SliceAssocItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.SliceAssocItem) */ {
 public:
  inline SliceAssocItem() : SliceAssocItem(nullptr) {}
  ~SliceAssocItem() override;
  explicit constexpr SliceAssocItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SliceAssocItem(const SliceAssocItem& from);
  SliceAssocItem(SliceAssocItem&& from) noexcept
    : SliceAssocItem() {
    *this = ::std::move(from);
  }

  inline SliceAssocItem& operator=(const SliceAssocItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SliceAssocItem& operator=(SliceAssocItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SliceAssocItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SliceAssocItem* internal_default_instance() {
    return reinterpret_cast<const SliceAssocItem*>(
               &_SliceAssocItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SliceAssocItem& a, SliceAssocItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SliceAssocItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SliceAssocItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SliceAssocItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SliceAssocItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SliceAssocItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SliceAssocItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SliceAssocItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.SliceAssocItem";
  }
  protected:
  explicit SliceAssocItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeIdFieldNumber = 3,
    kUeSliceAssocIdFieldNumber = 1,
    kE2NodeIdFieldNumber = 2,
    kSliceIdFieldNumber = 4,
  };
  // repeated .onos.rsm.UeIdType ue_id = 3;
  int ue_id_size() const;
  private:
  int _internal_ue_id_size() const;
  public:
  void clear_ue_id();
  private:
  ::onos::rsm::UeIdType _internal_ue_id(int index) const;
  void _internal_add_ue_id(::onos::rsm::UeIdType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_ue_id();
  public:
  ::onos::rsm::UeIdType ue_id(int index) const;
  void set_ue_id(int index, ::onos::rsm::UeIdType value);
  void add_ue_id(::onos::rsm::UeIdType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ue_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_ue_id();

  // string ue_slice_assoc_id = 1;
  void clear_ue_slice_assoc_id();
  const std::string& ue_slice_assoc_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ue_slice_assoc_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ue_slice_assoc_id();
  PROTOBUF_NODISCARD std::string* release_ue_slice_assoc_id();
  void set_allocated_ue_slice_assoc_id(std::string* ue_slice_assoc_id);
  private:
  const std::string& _internal_ue_slice_assoc_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ue_slice_assoc_id(const std::string& value);
  std::string* _internal_mutable_ue_slice_assoc_id();
  public:

  // string e2_node_id = 2;
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // string slice_id = 4;
  void clear_slice_id();
  const std::string& slice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_slice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_slice_id();
  PROTOBUF_NODISCARD std::string* release_slice_id();
  void set_allocated_slice_id(std::string* slice_id);
  private:
  const std::string& _internal_slice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slice_id(const std::string& value);
  std::string* _internal_mutable_slice_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.SliceAssocItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> ue_id_;
  mutable std::atomic<int> _ue_id_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ue_slice_assoc_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr slice_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class UeId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.UeId) */ {
 public:
  inline UeId() : UeId(nullptr) {}
  ~UeId() override;
  explicit constexpr UeId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UeId(const UeId& from);
  UeId(UeId&& from) noexcept
    : UeId() {
    *this = ::std::move(from);
  }

  inline UeId& operator=(const UeId& from) {
    CopyFrom(from);
    return *this;
  }
  inline UeId& operator=(UeId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UeId& default_instance() {
    return *internal_default_instance();
  }
  static inline const UeId* internal_default_instance() {
    return reinterpret_cast<const UeId*>(
               &_UeId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UeId& a, UeId& b) {
    a.Swap(&b);
  }
  inline void Swap(UeId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UeId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UeId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UeId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UeId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UeId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UeId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.UeId";
  }
  protected:
  explicit UeId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string ue_id = 1;
  void clear_ue_id();
  const std::string& ue_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ue_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ue_id();
  PROTOBUF_NODISCARD std::string* release_ue_id();
  void set_allocated_ue_id(std::string* ue_id);
  private:
  const std::string& _internal_ue_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ue_id(const std::string& value);
  std::string* _internal_mutable_ue_id();
  public:

  // .onos.rsm.UeIdType type = 2;
  void clear_type();
  ::onos::rsm::UeIdType type() const;
  void set_type(::onos::rsm::UeIdType value);
  private:
  ::onos::rsm::UeIdType _internal_type() const;
  void _internal_set_type(::onos::rsm::UeIdType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.UeId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ue_id_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class SetUeSliceAssociationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.SetUeSliceAssociationRequest) */ {
 public:
  inline SetUeSliceAssociationRequest() : SetUeSliceAssociationRequest(nullptr) {}
  ~SetUeSliceAssociationRequest() override;
  explicit constexpr SetUeSliceAssociationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUeSliceAssociationRequest(const SetUeSliceAssociationRequest& from);
  SetUeSliceAssociationRequest(SetUeSliceAssociationRequest&& from) noexcept
    : SetUeSliceAssociationRequest() {
    *this = ::std::move(from);
  }

  inline SetUeSliceAssociationRequest& operator=(const SetUeSliceAssociationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUeSliceAssociationRequest& operator=(SetUeSliceAssociationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUeSliceAssociationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUeSliceAssociationRequest* internal_default_instance() {
    return reinterpret_cast<const SetUeSliceAssociationRequest*>(
               &_SetUeSliceAssociationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetUeSliceAssociationRequest& a, SetUeSliceAssociationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUeSliceAssociationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUeSliceAssociationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUeSliceAssociationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUeSliceAssociationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetUeSliceAssociationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetUeSliceAssociationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUeSliceAssociationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.SetUeSliceAssociationRequest";
  }
  protected:
  explicit SetUeSliceAssociationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUeIdFieldNumber = 2,
    kE2NodeIdFieldNumber = 1,
    kDlSliceIdFieldNumber = 3,
    kUlSliceIdFieldNumber = 4,
    kDrbIdFieldNumber = 5,
  };
  // repeated .onos.rsm.UeId ue_id = 2;
  int ue_id_size() const;
  private:
  int _internal_ue_id_size() const;
  public:
  void clear_ue_id();
  ::onos::rsm::UeId* mutable_ue_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::rsm::UeId >*
      mutable_ue_id();
  private:
  const ::onos::rsm::UeId& _internal_ue_id(int index) const;
  ::onos::rsm::UeId* _internal_add_ue_id();
  public:
  const ::onos::rsm::UeId& ue_id(int index) const;
  ::onos::rsm::UeId* add_ue_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::rsm::UeId >&
      ue_id() const;

  // string e2_node_id = 1;
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // string dl_slice_id = 3;
  void clear_dl_slice_id();
  const std::string& dl_slice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dl_slice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dl_slice_id();
  PROTOBUF_NODISCARD std::string* release_dl_slice_id();
  void set_allocated_dl_slice_id(std::string* dl_slice_id);
  private:
  const std::string& _internal_dl_slice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dl_slice_id(const std::string& value);
  std::string* _internal_mutable_dl_slice_id();
  public:

  // string ul_slice_id = 4;
  void clear_ul_slice_id();
  const std::string& ul_slice_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ul_slice_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ul_slice_id();
  PROTOBUF_NODISCARD std::string* release_ul_slice_id();
  void set_allocated_ul_slice_id(std::string* ul_slice_id);
  private:
  const std::string& _internal_ul_slice_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ul_slice_id(const std::string& value);
  std::string* _internal_mutable_ul_slice_id();
  public:

  // string drb_id = 5;
  void clear_drb_id();
  const std::string& drb_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_drb_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_drb_id();
  PROTOBUF_NODISCARD std::string* release_drb_id();
  void set_allocated_drb_id(std::string* drb_id);
  private:
  const std::string& _internal_drb_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_drb_id(const std::string& value);
  std::string* _internal_mutable_drb_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.rsm.SetUeSliceAssociationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::rsm::UeId > ue_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dl_slice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ul_slice_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr drb_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// -------------------------------------------------------------------

class SetUeSliceAssociationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.rsm.SetUeSliceAssociationResponse) */ {
 public:
  inline SetUeSliceAssociationResponse() : SetUeSliceAssociationResponse(nullptr) {}
  ~SetUeSliceAssociationResponse() override;
  explicit constexpr SetUeSliceAssociationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetUeSliceAssociationResponse(const SetUeSliceAssociationResponse& from);
  SetUeSliceAssociationResponse(SetUeSliceAssociationResponse&& from) noexcept
    : SetUeSliceAssociationResponse() {
    *this = ::std::move(from);
  }

  inline SetUeSliceAssociationResponse& operator=(const SetUeSliceAssociationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetUeSliceAssociationResponse& operator=(SetUeSliceAssociationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetUeSliceAssociationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetUeSliceAssociationResponse* internal_default_instance() {
    return reinterpret_cast<const SetUeSliceAssociationResponse*>(
               &_SetUeSliceAssociationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetUeSliceAssociationResponse& a, SetUeSliceAssociationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetUeSliceAssociationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetUeSliceAssociationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetUeSliceAssociationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetUeSliceAssociationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetUeSliceAssociationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetUeSliceAssociationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetUeSliceAssociationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.rsm.SetUeSliceAssociationResponse";
  }
  protected:
  explicit SetUeSliceAssociationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssignedUeSliceAssocIdFieldNumber = 2,
    kAckFieldNumber = 1,
  };
  // string assigned_ue_slice_assoc_id = 2;
  void clear_assigned_ue_slice_assoc_id();
  const std::string& assigned_ue_slice_assoc_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assigned_ue_slice_assoc_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assigned_ue_slice_assoc_id();
  PROTOBUF_NODISCARD std::string* release_assigned_ue_slice_assoc_id();
  void set_allocated_assigned_ue_slice_assoc_id(std::string* assigned_ue_slice_assoc_id);
  private:
  const std::string& _internal_assigned_ue_slice_assoc_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assigned_ue_slice_assoc_id(const std::string& value);
  std::string* _internal_mutable_assigned_ue_slice_assoc_id();
  public:

  // .onos.rsm.Ack ack = 1;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::onos::rsm::Ack& ack() const;
  PROTOBUF_NODISCARD ::onos::rsm::Ack* release_ack();
  ::onos::rsm::Ack* mutable_ack();
  void set_allocated_ack(::onos::rsm::Ack* ack);
  private:
  const ::onos::rsm::Ack& _internal_ack() const;
  ::onos::rsm::Ack* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::onos::rsm::Ack* ack);
  ::onos::rsm::Ack* unsafe_arena_release_ack();

  // @@protoc_insertion_point(class_scope:onos.rsm.SetUeSliceAssociationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assigned_ue_slice_assoc_id_;
  ::onos::rsm::Ack* ack_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2frsm_2frsm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SliceItem

// string e2_node_id = 1;
inline void SliceItem::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& SliceItem::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SliceItem.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceItem::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SliceItem.e2_node_id)
}
inline std::string* SliceItem::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SliceItem.e2_node_id)
  return _s;
}
inline const std::string& SliceItem::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void SliceItem::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SliceItem::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SliceItem::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SliceItem.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SliceItem::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SliceItem.e2_node_id)
}

// repeated string slice_ids = 2;
inline int SliceItem::_internal_slice_ids_size() const {
  return slice_ids_.size();
}
inline int SliceItem::slice_ids_size() const {
  return _internal_slice_ids_size();
}
inline void SliceItem::clear_slice_ids() {
  slice_ids_.Clear();
}
inline std::string* SliceItem::add_slice_ids() {
  std::string* _s = _internal_add_slice_ids();
  // @@protoc_insertion_point(field_add_mutable:onos.rsm.SliceItem.slice_ids)
  return _s;
}
inline const std::string& SliceItem::_internal_slice_ids(int index) const {
  return slice_ids_.Get(index);
}
inline const std::string& SliceItem::slice_ids(int index) const {
  // @@protoc_insertion_point(field_get:onos.rsm.SliceItem.slice_ids)
  return _internal_slice_ids(index);
}
inline std::string* SliceItem::mutable_slice_ids(int index) {
  // @@protoc_insertion_point(field_mutable:onos.rsm.SliceItem.slice_ids)
  return slice_ids_.Mutable(index);
}
inline void SliceItem::set_slice_ids(int index, const std::string& value) {
  slice_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.rsm.SliceItem.slice_ids)
}
inline void SliceItem::set_slice_ids(int index, std::string&& value) {
  slice_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.rsm.SliceItem.slice_ids)
}
inline void SliceItem::set_slice_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  slice_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.rsm.SliceItem.slice_ids)
}
inline void SliceItem::set_slice_ids(int index, const char* value, size_t size) {
  slice_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.rsm.SliceItem.slice_ids)
}
inline std::string* SliceItem::_internal_add_slice_ids() {
  return slice_ids_.Add();
}
inline void SliceItem::add_slice_ids(const std::string& value) {
  slice_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.rsm.SliceItem.slice_ids)
}
inline void SliceItem::add_slice_ids(std::string&& value) {
  slice_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.rsm.SliceItem.slice_ids)
}
inline void SliceItem::add_slice_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  slice_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.rsm.SliceItem.slice_ids)
}
inline void SliceItem::add_slice_ids(const char* value, size_t size) {
  slice_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.rsm.SliceItem.slice_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SliceItem::slice_ids() const {
  // @@protoc_insertion_point(field_list:onos.rsm.SliceItem.slice_ids)
  return slice_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SliceItem::mutable_slice_ids() {
  // @@protoc_insertion_point(field_mutable_list:onos.rsm.SliceItem.slice_ids)
  return &slice_ids_;
}

// -------------------------------------------------------------------

// Ack

// bool success = 1;
inline void Ack::clear_success() {
  success_ = false;
}
inline bool Ack::_internal_success() const {
  return success_;
}
inline bool Ack::success() const {
  // @@protoc_insertion_point(field_get:onos.rsm.Ack.success)
  return _internal_success();
}
inline void Ack::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void Ack::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:onos.rsm.Ack.success)
}

// string cause = 2;
inline void Ack::clear_cause() {
  cause_.ClearToEmpty();
}
inline const std::string& Ack::cause() const {
  // @@protoc_insertion_point(field_get:onos.rsm.Ack.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ack::set_cause(ArgT0&& arg0, ArgT... args) {
 
 cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.Ack.cause)
}
inline std::string* Ack::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:onos.rsm.Ack.cause)
  return _s;
}
inline const std::string& Ack::_internal_cause() const {
  return cause_.Get();
}
inline void Ack::_internal_set_cause(const std::string& value) {
  
  cause_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Ack::_internal_mutable_cause() {
  
  return cause_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Ack::release_cause() {
  // @@protoc_insertion_point(field_release:onos.rsm.Ack.cause)
  return cause_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Ack::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    
  } else {
    
  }
  cause_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cause,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cause_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cause_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.Ack.cause)
}

// -------------------------------------------------------------------

// CreateSliceRequest

// string e2_node_id = 1;
inline void CreateSliceRequest::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& CreateSliceRequest::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.CreateSliceRequest.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSliceRequest::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.CreateSliceRequest.e2_node_id)
}
inline std::string* CreateSliceRequest::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.CreateSliceRequest.e2_node_id)
  return _s;
}
inline const std::string& CreateSliceRequest::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void CreateSliceRequest::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSliceRequest::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSliceRequest::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.CreateSliceRequest.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSliceRequest::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.CreateSliceRequest.e2_node_id)
}

// string slice_id = 2;
inline void CreateSliceRequest::clear_slice_id() {
  slice_id_.ClearToEmpty();
}
inline const std::string& CreateSliceRequest::slice_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.CreateSliceRequest.slice_id)
  return _internal_slice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSliceRequest::set_slice_id(ArgT0&& arg0, ArgT... args) {
 
 slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.CreateSliceRequest.slice_id)
}
inline std::string* CreateSliceRequest::mutable_slice_id() {
  std::string* _s = _internal_mutable_slice_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.CreateSliceRequest.slice_id)
  return _s;
}
inline const std::string& CreateSliceRequest::_internal_slice_id() const {
  return slice_id_.Get();
}
inline void CreateSliceRequest::_internal_set_slice_id(const std::string& value) {
  
  slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSliceRequest::_internal_mutable_slice_id() {
  
  return slice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSliceRequest::release_slice_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.CreateSliceRequest.slice_id)
  return slice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSliceRequest::set_allocated_slice_id(std::string* slice_id) {
  if (slice_id != nullptr) {
    
  } else {
    
  }
  slice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slice_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slice_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    slice_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.CreateSliceRequest.slice_id)
}

// .onos.rsm.SchedulerType scheduler_type = 3;
inline void CreateSliceRequest::clear_scheduler_type() {
  scheduler_type_ = 0;
}
inline ::onos::rsm::SchedulerType CreateSliceRequest::_internal_scheduler_type() const {
  return static_cast< ::onos::rsm::SchedulerType >(scheduler_type_);
}
inline ::onos::rsm::SchedulerType CreateSliceRequest::scheduler_type() const {
  // @@protoc_insertion_point(field_get:onos.rsm.CreateSliceRequest.scheduler_type)
  return _internal_scheduler_type();
}
inline void CreateSliceRequest::_internal_set_scheduler_type(::onos::rsm::SchedulerType value) {
  
  scheduler_type_ = value;
}
inline void CreateSliceRequest::set_scheduler_type(::onos::rsm::SchedulerType value) {
  _internal_set_scheduler_type(value);
  // @@protoc_insertion_point(field_set:onos.rsm.CreateSliceRequest.scheduler_type)
}

// string weight = 4;
inline void CreateSliceRequest::clear_weight() {
  weight_.ClearToEmpty();
}
inline const std::string& CreateSliceRequest::weight() const {
  // @@protoc_insertion_point(field_get:onos.rsm.CreateSliceRequest.weight)
  return _internal_weight();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSliceRequest::set_weight(ArgT0&& arg0, ArgT... args) {
 
 weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.CreateSliceRequest.weight)
}
inline std::string* CreateSliceRequest::mutable_weight() {
  std::string* _s = _internal_mutable_weight();
  // @@protoc_insertion_point(field_mutable:onos.rsm.CreateSliceRequest.weight)
  return _s;
}
inline const std::string& CreateSliceRequest::_internal_weight() const {
  return weight_.Get();
}
inline void CreateSliceRequest::_internal_set_weight(const std::string& value) {
  
  weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSliceRequest::_internal_mutable_weight() {
  
  return weight_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSliceRequest::release_weight() {
  // @@protoc_insertion_point(field_release:onos.rsm.CreateSliceRequest.weight)
  return weight_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSliceRequest::set_allocated_weight(std::string* weight) {
  if (weight != nullptr) {
    
  } else {
    
  }
  weight_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), weight,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (weight_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    weight_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.CreateSliceRequest.weight)
}

// .onos.rsm.SliceType sliceType = 5;
inline void CreateSliceRequest::clear_slicetype() {
  slicetype_ = 0;
}
inline ::onos::rsm::SliceType CreateSliceRequest::_internal_slicetype() const {
  return static_cast< ::onos::rsm::SliceType >(slicetype_);
}
inline ::onos::rsm::SliceType CreateSliceRequest::slicetype() const {
  // @@protoc_insertion_point(field_get:onos.rsm.CreateSliceRequest.sliceType)
  return _internal_slicetype();
}
inline void CreateSliceRequest::_internal_set_slicetype(::onos::rsm::SliceType value) {
  
  slicetype_ = value;
}
inline void CreateSliceRequest::set_slicetype(::onos::rsm::SliceType value) {
  _internal_set_slicetype(value);
  // @@protoc_insertion_point(field_set:onos.rsm.CreateSliceRequest.sliceType)
}

// -------------------------------------------------------------------

// CreateSliceResponse

// .onos.rsm.Ack ack = 1;
inline bool CreateSliceResponse::_internal_has_ack() const {
  return this != internal_default_instance() && ack_ != nullptr;
}
inline bool CreateSliceResponse::has_ack() const {
  return _internal_has_ack();
}
inline void CreateSliceResponse::clear_ack() {
  if (GetArenaForAllocation() == nullptr && ack_ != nullptr) {
    delete ack_;
  }
  ack_ = nullptr;
}
inline const ::onos::rsm::Ack& CreateSliceResponse::_internal_ack() const {
  const ::onos::rsm::Ack* p = ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::rsm::Ack&>(
      ::onos::rsm::_Ack_default_instance_);
}
inline const ::onos::rsm::Ack& CreateSliceResponse::ack() const {
  // @@protoc_insertion_point(field_get:onos.rsm.CreateSliceResponse.ack)
  return _internal_ack();
}
inline void CreateSliceResponse::unsafe_arena_set_allocated_ack(
    ::onos::rsm::Ack* ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_);
  }
  ack_ = ack;
  if (ack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.rsm.CreateSliceResponse.ack)
}
inline ::onos::rsm::Ack* CreateSliceResponse::release_ack() {
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::rsm::Ack* CreateSliceResponse::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_release:onos.rsm.CreateSliceResponse.ack)
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
  return temp;
}
inline ::onos::rsm::Ack* CreateSliceResponse::_internal_mutable_ack() {
  
  if (ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::rsm::Ack>(GetArenaForAllocation());
    ack_ = p;
  }
  return ack_;
}
inline ::onos::rsm::Ack* CreateSliceResponse::mutable_ack() {
  ::onos::rsm::Ack* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:onos.rsm.CreateSliceResponse.ack)
  return _msg;
}
inline void CreateSliceResponse::set_allocated_ack(::onos::rsm::Ack* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ack_;
  }
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::rsm::Ack>::GetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    
  } else {
    
  }
  ack_ = ack;
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.CreateSliceResponse.ack)
}

// -------------------------------------------------------------------

// UpdateSliceRequest

// string e2_node_id = 1;
inline void UpdateSliceRequest::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& UpdateSliceRequest::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UpdateSliceRequest.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSliceRequest::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.UpdateSliceRequest.e2_node_id)
}
inline std::string* UpdateSliceRequest::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.UpdateSliceRequest.e2_node_id)
  return _s;
}
inline const std::string& UpdateSliceRequest::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void UpdateSliceRequest::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSliceRequest::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSliceRequest::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.UpdateSliceRequest.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSliceRequest::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.UpdateSliceRequest.e2_node_id)
}

// string slice_id = 2;
inline void UpdateSliceRequest::clear_slice_id() {
  slice_id_.ClearToEmpty();
}
inline const std::string& UpdateSliceRequest::slice_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UpdateSliceRequest.slice_id)
  return _internal_slice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSliceRequest::set_slice_id(ArgT0&& arg0, ArgT... args) {
 
 slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.UpdateSliceRequest.slice_id)
}
inline std::string* UpdateSliceRequest::mutable_slice_id() {
  std::string* _s = _internal_mutable_slice_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.UpdateSliceRequest.slice_id)
  return _s;
}
inline const std::string& UpdateSliceRequest::_internal_slice_id() const {
  return slice_id_.Get();
}
inline void UpdateSliceRequest::_internal_set_slice_id(const std::string& value) {
  
  slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSliceRequest::_internal_mutable_slice_id() {
  
  return slice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSliceRequest::release_slice_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.UpdateSliceRequest.slice_id)
  return slice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSliceRequest::set_allocated_slice_id(std::string* slice_id) {
  if (slice_id != nullptr) {
    
  } else {
    
  }
  slice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slice_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slice_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    slice_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.UpdateSliceRequest.slice_id)
}

// .onos.rsm.SchedulerType scheduler_type = 3;
inline void UpdateSliceRequest::clear_scheduler_type() {
  scheduler_type_ = 0;
}
inline ::onos::rsm::SchedulerType UpdateSliceRequest::_internal_scheduler_type() const {
  return static_cast< ::onos::rsm::SchedulerType >(scheduler_type_);
}
inline ::onos::rsm::SchedulerType UpdateSliceRequest::scheduler_type() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UpdateSliceRequest.scheduler_type)
  return _internal_scheduler_type();
}
inline void UpdateSliceRequest::_internal_set_scheduler_type(::onos::rsm::SchedulerType value) {
  
  scheduler_type_ = value;
}
inline void UpdateSliceRequest::set_scheduler_type(::onos::rsm::SchedulerType value) {
  _internal_set_scheduler_type(value);
  // @@protoc_insertion_point(field_set:onos.rsm.UpdateSliceRequest.scheduler_type)
}

// string weight = 4;
inline void UpdateSliceRequest::clear_weight() {
  weight_.ClearToEmpty();
}
inline const std::string& UpdateSliceRequest::weight() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UpdateSliceRequest.weight)
  return _internal_weight();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateSliceRequest::set_weight(ArgT0&& arg0, ArgT... args) {
 
 weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.UpdateSliceRequest.weight)
}
inline std::string* UpdateSliceRequest::mutable_weight() {
  std::string* _s = _internal_mutable_weight();
  // @@protoc_insertion_point(field_mutable:onos.rsm.UpdateSliceRequest.weight)
  return _s;
}
inline const std::string& UpdateSliceRequest::_internal_weight() const {
  return weight_.Get();
}
inline void UpdateSliceRequest::_internal_set_weight(const std::string& value) {
  
  weight_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateSliceRequest::_internal_mutable_weight() {
  
  return weight_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateSliceRequest::release_weight() {
  // @@protoc_insertion_point(field_release:onos.rsm.UpdateSliceRequest.weight)
  return weight_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateSliceRequest::set_allocated_weight(std::string* weight) {
  if (weight != nullptr) {
    
  } else {
    
  }
  weight_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), weight,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (weight_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    weight_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.UpdateSliceRequest.weight)
}

// .onos.rsm.SliceType sliceType = 5;
inline void UpdateSliceRequest::clear_slicetype() {
  slicetype_ = 0;
}
inline ::onos::rsm::SliceType UpdateSliceRequest::_internal_slicetype() const {
  return static_cast< ::onos::rsm::SliceType >(slicetype_);
}
inline ::onos::rsm::SliceType UpdateSliceRequest::slicetype() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UpdateSliceRequest.sliceType)
  return _internal_slicetype();
}
inline void UpdateSliceRequest::_internal_set_slicetype(::onos::rsm::SliceType value) {
  
  slicetype_ = value;
}
inline void UpdateSliceRequest::set_slicetype(::onos::rsm::SliceType value) {
  _internal_set_slicetype(value);
  // @@protoc_insertion_point(field_set:onos.rsm.UpdateSliceRequest.sliceType)
}

// -------------------------------------------------------------------

// UpdateSliceResponse

// .onos.rsm.Ack ack = 1;
inline bool UpdateSliceResponse::_internal_has_ack() const {
  return this != internal_default_instance() && ack_ != nullptr;
}
inline bool UpdateSliceResponse::has_ack() const {
  return _internal_has_ack();
}
inline void UpdateSliceResponse::clear_ack() {
  if (GetArenaForAllocation() == nullptr && ack_ != nullptr) {
    delete ack_;
  }
  ack_ = nullptr;
}
inline const ::onos::rsm::Ack& UpdateSliceResponse::_internal_ack() const {
  const ::onos::rsm::Ack* p = ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::rsm::Ack&>(
      ::onos::rsm::_Ack_default_instance_);
}
inline const ::onos::rsm::Ack& UpdateSliceResponse::ack() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UpdateSliceResponse.ack)
  return _internal_ack();
}
inline void UpdateSliceResponse::unsafe_arena_set_allocated_ack(
    ::onos::rsm::Ack* ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_);
  }
  ack_ = ack;
  if (ack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.rsm.UpdateSliceResponse.ack)
}
inline ::onos::rsm::Ack* UpdateSliceResponse::release_ack() {
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::rsm::Ack* UpdateSliceResponse::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_release:onos.rsm.UpdateSliceResponse.ack)
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
  return temp;
}
inline ::onos::rsm::Ack* UpdateSliceResponse::_internal_mutable_ack() {
  
  if (ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::rsm::Ack>(GetArenaForAllocation());
    ack_ = p;
  }
  return ack_;
}
inline ::onos::rsm::Ack* UpdateSliceResponse::mutable_ack() {
  ::onos::rsm::Ack* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:onos.rsm.UpdateSliceResponse.ack)
  return _msg;
}
inline void UpdateSliceResponse::set_allocated_ack(::onos::rsm::Ack* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ack_;
  }
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::rsm::Ack>::GetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    
  } else {
    
  }
  ack_ = ack;
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.UpdateSliceResponse.ack)
}

// -------------------------------------------------------------------

// DeleteSliceRequest

// string e2_node_id = 1;
inline void DeleteSliceRequest::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& DeleteSliceRequest::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.DeleteSliceRequest.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSliceRequest::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.DeleteSliceRequest.e2_node_id)
}
inline std::string* DeleteSliceRequest::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.DeleteSliceRequest.e2_node_id)
  return _s;
}
inline const std::string& DeleteSliceRequest::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void DeleteSliceRequest::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteSliceRequest::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteSliceRequest::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.DeleteSliceRequest.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteSliceRequest::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.DeleteSliceRequest.e2_node_id)
}

// string slice_id = 2;
inline void DeleteSliceRequest::clear_slice_id() {
  slice_id_.ClearToEmpty();
}
inline const std::string& DeleteSliceRequest::slice_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.DeleteSliceRequest.slice_id)
  return _internal_slice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSliceRequest::set_slice_id(ArgT0&& arg0, ArgT... args) {
 
 slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.DeleteSliceRequest.slice_id)
}
inline std::string* DeleteSliceRequest::mutable_slice_id() {
  std::string* _s = _internal_mutable_slice_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.DeleteSliceRequest.slice_id)
  return _s;
}
inline const std::string& DeleteSliceRequest::_internal_slice_id() const {
  return slice_id_.Get();
}
inline void DeleteSliceRequest::_internal_set_slice_id(const std::string& value) {
  
  slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteSliceRequest::_internal_mutable_slice_id() {
  
  return slice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteSliceRequest::release_slice_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.DeleteSliceRequest.slice_id)
  return slice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteSliceRequest::set_allocated_slice_id(std::string* slice_id) {
  if (slice_id != nullptr) {
    
  } else {
    
  }
  slice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slice_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slice_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    slice_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.DeleteSliceRequest.slice_id)
}

// .onos.rsm.SliceType sliceType = 3;
inline void DeleteSliceRequest::clear_slicetype() {
  slicetype_ = 0;
}
inline ::onos::rsm::SliceType DeleteSliceRequest::_internal_slicetype() const {
  return static_cast< ::onos::rsm::SliceType >(slicetype_);
}
inline ::onos::rsm::SliceType DeleteSliceRequest::slicetype() const {
  // @@protoc_insertion_point(field_get:onos.rsm.DeleteSliceRequest.sliceType)
  return _internal_slicetype();
}
inline void DeleteSliceRequest::_internal_set_slicetype(::onos::rsm::SliceType value) {
  
  slicetype_ = value;
}
inline void DeleteSliceRequest::set_slicetype(::onos::rsm::SliceType value) {
  _internal_set_slicetype(value);
  // @@protoc_insertion_point(field_set:onos.rsm.DeleteSliceRequest.sliceType)
}

// -------------------------------------------------------------------

// DeleteSliceResponse

// .onos.rsm.Ack ack = 1;
inline bool DeleteSliceResponse::_internal_has_ack() const {
  return this != internal_default_instance() && ack_ != nullptr;
}
inline bool DeleteSliceResponse::has_ack() const {
  return _internal_has_ack();
}
inline void DeleteSliceResponse::clear_ack() {
  if (GetArenaForAllocation() == nullptr && ack_ != nullptr) {
    delete ack_;
  }
  ack_ = nullptr;
}
inline const ::onos::rsm::Ack& DeleteSliceResponse::_internal_ack() const {
  const ::onos::rsm::Ack* p = ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::rsm::Ack&>(
      ::onos::rsm::_Ack_default_instance_);
}
inline const ::onos::rsm::Ack& DeleteSliceResponse::ack() const {
  // @@protoc_insertion_point(field_get:onos.rsm.DeleteSliceResponse.ack)
  return _internal_ack();
}
inline void DeleteSliceResponse::unsafe_arena_set_allocated_ack(
    ::onos::rsm::Ack* ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_);
  }
  ack_ = ack;
  if (ack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.rsm.DeleteSliceResponse.ack)
}
inline ::onos::rsm::Ack* DeleteSliceResponse::release_ack() {
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::rsm::Ack* DeleteSliceResponse::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_release:onos.rsm.DeleteSliceResponse.ack)
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
  return temp;
}
inline ::onos::rsm::Ack* DeleteSliceResponse::_internal_mutable_ack() {
  
  if (ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::rsm::Ack>(GetArenaForAllocation());
    ack_ = p;
  }
  return ack_;
}
inline ::onos::rsm::Ack* DeleteSliceResponse::mutable_ack() {
  ::onos::rsm::Ack* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:onos.rsm.DeleteSliceResponse.ack)
  return _msg;
}
inline void DeleteSliceResponse::set_allocated_ack(::onos::rsm::Ack* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ack_;
  }
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::rsm::Ack>::GetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    
  } else {
    
  }
  ack_ = ack;
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.DeleteSliceResponse.ack)
}

// -------------------------------------------------------------------

// SliceAssocItem

// string ue_slice_assoc_id = 1;
inline void SliceAssocItem::clear_ue_slice_assoc_id() {
  ue_slice_assoc_id_.ClearToEmpty();
}
inline const std::string& SliceAssocItem::ue_slice_assoc_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SliceAssocItem.ue_slice_assoc_id)
  return _internal_ue_slice_assoc_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceAssocItem::set_ue_slice_assoc_id(ArgT0&& arg0, ArgT... args) {
 
 ue_slice_assoc_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SliceAssocItem.ue_slice_assoc_id)
}
inline std::string* SliceAssocItem::mutable_ue_slice_assoc_id() {
  std::string* _s = _internal_mutable_ue_slice_assoc_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SliceAssocItem.ue_slice_assoc_id)
  return _s;
}
inline const std::string& SliceAssocItem::_internal_ue_slice_assoc_id() const {
  return ue_slice_assoc_id_.Get();
}
inline void SliceAssocItem::_internal_set_ue_slice_assoc_id(const std::string& value) {
  
  ue_slice_assoc_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SliceAssocItem::_internal_mutable_ue_slice_assoc_id() {
  
  return ue_slice_assoc_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SliceAssocItem::release_ue_slice_assoc_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SliceAssocItem.ue_slice_assoc_id)
  return ue_slice_assoc_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SliceAssocItem::set_allocated_ue_slice_assoc_id(std::string* ue_slice_assoc_id) {
  if (ue_slice_assoc_id != nullptr) {
    
  } else {
    
  }
  ue_slice_assoc_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ue_slice_assoc_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ue_slice_assoc_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ue_slice_assoc_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SliceAssocItem.ue_slice_assoc_id)
}

// string e2_node_id = 2;
inline void SliceAssocItem::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& SliceAssocItem::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SliceAssocItem.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceAssocItem::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SliceAssocItem.e2_node_id)
}
inline std::string* SliceAssocItem::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SliceAssocItem.e2_node_id)
  return _s;
}
inline const std::string& SliceAssocItem::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void SliceAssocItem::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SliceAssocItem::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SliceAssocItem::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SliceAssocItem.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SliceAssocItem::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SliceAssocItem.e2_node_id)
}

// repeated .onos.rsm.UeIdType ue_id = 3;
inline int SliceAssocItem::_internal_ue_id_size() const {
  return ue_id_.size();
}
inline int SliceAssocItem::ue_id_size() const {
  return _internal_ue_id_size();
}
inline void SliceAssocItem::clear_ue_id() {
  ue_id_.Clear();
}
inline ::onos::rsm::UeIdType SliceAssocItem::_internal_ue_id(int index) const {
  return static_cast< ::onos::rsm::UeIdType >(ue_id_.Get(index));
}
inline ::onos::rsm::UeIdType SliceAssocItem::ue_id(int index) const {
  // @@protoc_insertion_point(field_get:onos.rsm.SliceAssocItem.ue_id)
  return _internal_ue_id(index);
}
inline void SliceAssocItem::set_ue_id(int index, ::onos::rsm::UeIdType value) {
  ue_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:onos.rsm.SliceAssocItem.ue_id)
}
inline void SliceAssocItem::_internal_add_ue_id(::onos::rsm::UeIdType value) {
  ue_id_.Add(value);
}
inline void SliceAssocItem::add_ue_id(::onos::rsm::UeIdType value) {
  _internal_add_ue_id(value);
  // @@protoc_insertion_point(field_add:onos.rsm.SliceAssocItem.ue_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SliceAssocItem::ue_id() const {
  // @@protoc_insertion_point(field_list:onos.rsm.SliceAssocItem.ue_id)
  return ue_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SliceAssocItem::_internal_mutable_ue_id() {
  return &ue_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SliceAssocItem::mutable_ue_id() {
  // @@protoc_insertion_point(field_mutable_list:onos.rsm.SliceAssocItem.ue_id)
  return _internal_mutable_ue_id();
}

// string slice_id = 4;
inline void SliceAssocItem::clear_slice_id() {
  slice_id_.ClearToEmpty();
}
inline const std::string& SliceAssocItem::slice_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SliceAssocItem.slice_id)
  return _internal_slice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SliceAssocItem::set_slice_id(ArgT0&& arg0, ArgT... args) {
 
 slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SliceAssocItem.slice_id)
}
inline std::string* SliceAssocItem::mutable_slice_id() {
  std::string* _s = _internal_mutable_slice_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SliceAssocItem.slice_id)
  return _s;
}
inline const std::string& SliceAssocItem::_internal_slice_id() const {
  return slice_id_.Get();
}
inline void SliceAssocItem::_internal_set_slice_id(const std::string& value) {
  
  slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SliceAssocItem::_internal_mutable_slice_id() {
  
  return slice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SliceAssocItem::release_slice_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SliceAssocItem.slice_id)
  return slice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SliceAssocItem::set_allocated_slice_id(std::string* slice_id) {
  if (slice_id != nullptr) {
    
  } else {
    
  }
  slice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), slice_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (slice_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    slice_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SliceAssocItem.slice_id)
}

// -------------------------------------------------------------------

// UeId

// string ue_id = 1;
inline void UeId::clear_ue_id() {
  ue_id_.ClearToEmpty();
}
inline const std::string& UeId::ue_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UeId.ue_id)
  return _internal_ue_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UeId::set_ue_id(ArgT0&& arg0, ArgT... args) {
 
 ue_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.UeId.ue_id)
}
inline std::string* UeId::mutable_ue_id() {
  std::string* _s = _internal_mutable_ue_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.UeId.ue_id)
  return _s;
}
inline const std::string& UeId::_internal_ue_id() const {
  return ue_id_.Get();
}
inline void UeId::_internal_set_ue_id(const std::string& value) {
  
  ue_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UeId::_internal_mutable_ue_id() {
  
  return ue_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UeId::release_ue_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.UeId.ue_id)
  return ue_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UeId::set_allocated_ue_id(std::string* ue_id) {
  if (ue_id != nullptr) {
    
  } else {
    
  }
  ue_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ue_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ue_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ue_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.UeId.ue_id)
}

// .onos.rsm.UeIdType type = 2;
inline void UeId::clear_type() {
  type_ = 0;
}
inline ::onos::rsm::UeIdType UeId::_internal_type() const {
  return static_cast< ::onos::rsm::UeIdType >(type_);
}
inline ::onos::rsm::UeIdType UeId::type() const {
  // @@protoc_insertion_point(field_get:onos.rsm.UeId.type)
  return _internal_type();
}
inline void UeId::_internal_set_type(::onos::rsm::UeIdType value) {
  
  type_ = value;
}
inline void UeId::set_type(::onos::rsm::UeIdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.rsm.UeId.type)
}

// -------------------------------------------------------------------

// SetUeSliceAssociationRequest

// string e2_node_id = 1;
inline void SetUeSliceAssociationRequest::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& SetUeSliceAssociationRequest::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationRequest.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUeSliceAssociationRequest::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SetUeSliceAssociationRequest.e2_node_id)
}
inline std::string* SetUeSliceAssociationRequest::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationRequest.e2_node_id)
  return _s;
}
inline const std::string& SetUeSliceAssociationRequest::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void SetUeSliceAssociationRequest::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SetUeSliceAssociationRequest.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetUeSliceAssociationRequest::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SetUeSliceAssociationRequest.e2_node_id)
}

// repeated .onos.rsm.UeId ue_id = 2;
inline int SetUeSliceAssociationRequest::_internal_ue_id_size() const {
  return ue_id_.size();
}
inline int SetUeSliceAssociationRequest::ue_id_size() const {
  return _internal_ue_id_size();
}
inline void SetUeSliceAssociationRequest::clear_ue_id() {
  ue_id_.Clear();
}
inline ::onos::rsm::UeId* SetUeSliceAssociationRequest::mutable_ue_id(int index) {
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationRequest.ue_id)
  return ue_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::rsm::UeId >*
SetUeSliceAssociationRequest::mutable_ue_id() {
  // @@protoc_insertion_point(field_mutable_list:onos.rsm.SetUeSliceAssociationRequest.ue_id)
  return &ue_id_;
}
inline const ::onos::rsm::UeId& SetUeSliceAssociationRequest::_internal_ue_id(int index) const {
  return ue_id_.Get(index);
}
inline const ::onos::rsm::UeId& SetUeSliceAssociationRequest::ue_id(int index) const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationRequest.ue_id)
  return _internal_ue_id(index);
}
inline ::onos::rsm::UeId* SetUeSliceAssociationRequest::_internal_add_ue_id() {
  return ue_id_.Add();
}
inline ::onos::rsm::UeId* SetUeSliceAssociationRequest::add_ue_id() {
  ::onos::rsm::UeId* _add = _internal_add_ue_id();
  // @@protoc_insertion_point(field_add:onos.rsm.SetUeSliceAssociationRequest.ue_id)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::rsm::UeId >&
SetUeSliceAssociationRequest::ue_id() const {
  // @@protoc_insertion_point(field_list:onos.rsm.SetUeSliceAssociationRequest.ue_id)
  return ue_id_;
}

// string dl_slice_id = 3;
inline void SetUeSliceAssociationRequest::clear_dl_slice_id() {
  dl_slice_id_.ClearToEmpty();
}
inline const std::string& SetUeSliceAssociationRequest::dl_slice_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationRequest.dl_slice_id)
  return _internal_dl_slice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUeSliceAssociationRequest::set_dl_slice_id(ArgT0&& arg0, ArgT... args) {
 
 dl_slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SetUeSliceAssociationRequest.dl_slice_id)
}
inline std::string* SetUeSliceAssociationRequest::mutable_dl_slice_id() {
  std::string* _s = _internal_mutable_dl_slice_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationRequest.dl_slice_id)
  return _s;
}
inline const std::string& SetUeSliceAssociationRequest::_internal_dl_slice_id() const {
  return dl_slice_id_.Get();
}
inline void SetUeSliceAssociationRequest::_internal_set_dl_slice_id(const std::string& value) {
  
  dl_slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::_internal_mutable_dl_slice_id() {
  
  return dl_slice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::release_dl_slice_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SetUeSliceAssociationRequest.dl_slice_id)
  return dl_slice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetUeSliceAssociationRequest::set_allocated_dl_slice_id(std::string* dl_slice_id) {
  if (dl_slice_id != nullptr) {
    
  } else {
    
  }
  dl_slice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dl_slice_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dl_slice_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dl_slice_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SetUeSliceAssociationRequest.dl_slice_id)
}

// string ul_slice_id = 4;
inline void SetUeSliceAssociationRequest::clear_ul_slice_id() {
  ul_slice_id_.ClearToEmpty();
}
inline const std::string& SetUeSliceAssociationRequest::ul_slice_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationRequest.ul_slice_id)
  return _internal_ul_slice_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUeSliceAssociationRequest::set_ul_slice_id(ArgT0&& arg0, ArgT... args) {
 
 ul_slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SetUeSliceAssociationRequest.ul_slice_id)
}
inline std::string* SetUeSliceAssociationRequest::mutable_ul_slice_id() {
  std::string* _s = _internal_mutable_ul_slice_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationRequest.ul_slice_id)
  return _s;
}
inline const std::string& SetUeSliceAssociationRequest::_internal_ul_slice_id() const {
  return ul_slice_id_.Get();
}
inline void SetUeSliceAssociationRequest::_internal_set_ul_slice_id(const std::string& value) {
  
  ul_slice_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::_internal_mutable_ul_slice_id() {
  
  return ul_slice_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::release_ul_slice_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SetUeSliceAssociationRequest.ul_slice_id)
  return ul_slice_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetUeSliceAssociationRequest::set_allocated_ul_slice_id(std::string* ul_slice_id) {
  if (ul_slice_id != nullptr) {
    
  } else {
    
  }
  ul_slice_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ul_slice_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ul_slice_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ul_slice_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SetUeSliceAssociationRequest.ul_slice_id)
}

// string drb_id = 5;
inline void SetUeSliceAssociationRequest::clear_drb_id() {
  drb_id_.ClearToEmpty();
}
inline const std::string& SetUeSliceAssociationRequest::drb_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationRequest.drb_id)
  return _internal_drb_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUeSliceAssociationRequest::set_drb_id(ArgT0&& arg0, ArgT... args) {
 
 drb_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SetUeSliceAssociationRequest.drb_id)
}
inline std::string* SetUeSliceAssociationRequest::mutable_drb_id() {
  std::string* _s = _internal_mutable_drb_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationRequest.drb_id)
  return _s;
}
inline const std::string& SetUeSliceAssociationRequest::_internal_drb_id() const {
  return drb_id_.Get();
}
inline void SetUeSliceAssociationRequest::_internal_set_drb_id(const std::string& value) {
  
  drb_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::_internal_mutable_drb_id() {
  
  return drb_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationRequest::release_drb_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SetUeSliceAssociationRequest.drb_id)
  return drb_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetUeSliceAssociationRequest::set_allocated_drb_id(std::string* drb_id) {
  if (drb_id != nullptr) {
    
  } else {
    
  }
  drb_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), drb_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (drb_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    drb_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SetUeSliceAssociationRequest.drb_id)
}

// -------------------------------------------------------------------

// SetUeSliceAssociationResponse

// .onos.rsm.Ack ack = 1;
inline bool SetUeSliceAssociationResponse::_internal_has_ack() const {
  return this != internal_default_instance() && ack_ != nullptr;
}
inline bool SetUeSliceAssociationResponse::has_ack() const {
  return _internal_has_ack();
}
inline void SetUeSliceAssociationResponse::clear_ack() {
  if (GetArenaForAllocation() == nullptr && ack_ != nullptr) {
    delete ack_;
  }
  ack_ = nullptr;
}
inline const ::onos::rsm::Ack& SetUeSliceAssociationResponse::_internal_ack() const {
  const ::onos::rsm::Ack* p = ack_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::rsm::Ack&>(
      ::onos::rsm::_Ack_default_instance_);
}
inline const ::onos::rsm::Ack& SetUeSliceAssociationResponse::ack() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationResponse.ack)
  return _internal_ack();
}
inline void SetUeSliceAssociationResponse::unsafe_arena_set_allocated_ack(
    ::onos::rsm::Ack* ack) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ack_);
  }
  ack_ = ack;
  if (ack) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.rsm.SetUeSliceAssociationResponse.ack)
}
inline ::onos::rsm::Ack* SetUeSliceAssociationResponse::release_ack() {
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::rsm::Ack* SetUeSliceAssociationResponse::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_release:onos.rsm.SetUeSliceAssociationResponse.ack)
  
  ::onos::rsm::Ack* temp = ack_;
  ack_ = nullptr;
  return temp;
}
inline ::onos::rsm::Ack* SetUeSliceAssociationResponse::_internal_mutable_ack() {
  
  if (ack_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::rsm::Ack>(GetArenaForAllocation());
    ack_ = p;
  }
  return ack_;
}
inline ::onos::rsm::Ack* SetUeSliceAssociationResponse::mutable_ack() {
  ::onos::rsm::Ack* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationResponse.ack)
  return _msg;
}
inline void SetUeSliceAssociationResponse::set_allocated_ack(::onos::rsm::Ack* ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ack_;
  }
  if (ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::rsm::Ack>::GetOwningArena(ack);
    if (message_arena != submessage_arena) {
      ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ack, submessage_arena);
    }
    
  } else {
    
  }
  ack_ = ack;
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SetUeSliceAssociationResponse.ack)
}

// string assigned_ue_slice_assoc_id = 2;
inline void SetUeSliceAssociationResponse::clear_assigned_ue_slice_assoc_id() {
  assigned_ue_slice_assoc_id_.ClearToEmpty();
}
inline const std::string& SetUeSliceAssociationResponse::assigned_ue_slice_assoc_id() const {
  // @@protoc_insertion_point(field_get:onos.rsm.SetUeSliceAssociationResponse.assigned_ue_slice_assoc_id)
  return _internal_assigned_ue_slice_assoc_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetUeSliceAssociationResponse::set_assigned_ue_slice_assoc_id(ArgT0&& arg0, ArgT... args) {
 
 assigned_ue_slice_assoc_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.rsm.SetUeSliceAssociationResponse.assigned_ue_slice_assoc_id)
}
inline std::string* SetUeSliceAssociationResponse::mutable_assigned_ue_slice_assoc_id() {
  std::string* _s = _internal_mutable_assigned_ue_slice_assoc_id();
  // @@protoc_insertion_point(field_mutable:onos.rsm.SetUeSliceAssociationResponse.assigned_ue_slice_assoc_id)
  return _s;
}
inline const std::string& SetUeSliceAssociationResponse::_internal_assigned_ue_slice_assoc_id() const {
  return assigned_ue_slice_assoc_id_.Get();
}
inline void SetUeSliceAssociationResponse::_internal_set_assigned_ue_slice_assoc_id(const std::string& value) {
  
  assigned_ue_slice_assoc_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationResponse::_internal_mutable_assigned_ue_slice_assoc_id() {
  
  return assigned_ue_slice_assoc_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetUeSliceAssociationResponse::release_assigned_ue_slice_assoc_id() {
  // @@protoc_insertion_point(field_release:onos.rsm.SetUeSliceAssociationResponse.assigned_ue_slice_assoc_id)
  return assigned_ue_slice_assoc_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetUeSliceAssociationResponse::set_allocated_assigned_ue_slice_assoc_id(std::string* assigned_ue_slice_assoc_id) {
  if (assigned_ue_slice_assoc_id != nullptr) {
    
  } else {
    
  }
  assigned_ue_slice_assoc_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assigned_ue_slice_assoc_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assigned_ue_slice_assoc_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assigned_ue_slice_assoc_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.rsm.SetUeSliceAssociationResponse.assigned_ue_slice_assoc_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rsm
}  // namespace onos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::onos::rsm::SliceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::rsm::SliceType>() {
  return ::onos::rsm::SliceType_descriptor();
}
template <> struct is_proto_enum< ::onos::rsm::SchedulerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::rsm::SchedulerType>() {
  return ::onos::rsm::SchedulerType_descriptor();
}
template <> struct is_proto_enum< ::onos::rsm::UeIdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::rsm::UeIdType>() {
  return ::onos::rsm::UeIdType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onos_2frsm_2frsm_2eproto
