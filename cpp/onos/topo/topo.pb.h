// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onos/topo/topo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_onos_2ftopo_2ftopo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_onos_2ftopo_2ftopo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_onos_2ftopo_2ftopo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_onos_2ftopo_2ftopo_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_onos_2ftopo_2ftopo_2eproto;
namespace onos {
namespace topo {
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class CreateResponse;
struct CreateResponseDefaultTypeInternal;
extern CreateResponseDefaultTypeInternal _CreateResponse_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class DeleteResponse;
struct DeleteResponseDefaultTypeInternal;
extern DeleteResponseDefaultTypeInternal _DeleteResponse_default_instance_;
class Entity;
struct EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class EqualFilter;
struct EqualFilterDefaultTypeInternal;
extern EqualFilterDefaultTypeInternal _EqualFilter_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Filter;
struct FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class Filters;
struct FiltersDefaultTypeInternal;
extern FiltersDefaultTypeInternal _Filters_default_instance_;
class GetRequest;
struct GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
struct GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class InFilter;
struct InFilterDefaultTypeInternal;
extern InFilterDefaultTypeInternal _InFilter_default_instance_;
class Kind;
struct KindDefaultTypeInternal;
extern KindDefaultTypeInternal _Kind_default_instance_;
class ListRequest;
struct ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class ListResponse;
struct ListResponseDefaultTypeInternal;
extern ListResponseDefaultTypeInternal _ListResponse_default_instance_;
class NotFilter;
struct NotFilterDefaultTypeInternal;
extern NotFilterDefaultTypeInternal _NotFilter_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Object_AspectsEntry_DoNotUse;
struct Object_AspectsEntry_DoNotUseDefaultTypeInternal;
extern Object_AspectsEntry_DoNotUseDefaultTypeInternal _Object_AspectsEntry_DoNotUse_default_instance_;
class Object_LabelsEntry_DoNotUse;
struct Object_LabelsEntry_DoNotUseDefaultTypeInternal;
extern Object_LabelsEntry_DoNotUseDefaultTypeInternal _Object_LabelsEntry_DoNotUse_default_instance_;
class Relation;
struct RelationDefaultTypeInternal;
extern RelationDefaultTypeInternal _Relation_default_instance_;
class RelationFilter;
struct RelationFilterDefaultTypeInternal;
extern RelationFilterDefaultTypeInternal _RelationFilter_default_instance_;
class UpdateRequest;
struct UpdateRequestDefaultTypeInternal;
extern UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
class UpdateResponse;
struct UpdateResponseDefaultTypeInternal;
extern UpdateResponseDefaultTypeInternal _UpdateResponse_default_instance_;
class WatchRequest;
struct WatchRequestDefaultTypeInternal;
extern WatchRequestDefaultTypeInternal _WatchRequest_default_instance_;
class WatchResponse;
struct WatchResponseDefaultTypeInternal;
extern WatchResponseDefaultTypeInternal _WatchResponse_default_instance_;
}  // namespace topo
}  // namespace onos
PROTOBUF_NAMESPACE_OPEN
template<> ::onos::topo::CreateRequest* Arena::CreateMaybeMessage<::onos::topo::CreateRequest>(Arena*);
template<> ::onos::topo::CreateResponse* Arena::CreateMaybeMessage<::onos::topo::CreateResponse>(Arena*);
template<> ::onos::topo::DeleteRequest* Arena::CreateMaybeMessage<::onos::topo::DeleteRequest>(Arena*);
template<> ::onos::topo::DeleteResponse* Arena::CreateMaybeMessage<::onos::topo::DeleteResponse>(Arena*);
template<> ::onos::topo::Entity* Arena::CreateMaybeMessage<::onos::topo::Entity>(Arena*);
template<> ::onos::topo::EqualFilter* Arena::CreateMaybeMessage<::onos::topo::EqualFilter>(Arena*);
template<> ::onos::topo::Event* Arena::CreateMaybeMessage<::onos::topo::Event>(Arena*);
template<> ::onos::topo::Filter* Arena::CreateMaybeMessage<::onos::topo::Filter>(Arena*);
template<> ::onos::topo::Filters* Arena::CreateMaybeMessage<::onos::topo::Filters>(Arena*);
template<> ::onos::topo::GetRequest* Arena::CreateMaybeMessage<::onos::topo::GetRequest>(Arena*);
template<> ::onos::topo::GetResponse* Arena::CreateMaybeMessage<::onos::topo::GetResponse>(Arena*);
template<> ::onos::topo::InFilter* Arena::CreateMaybeMessage<::onos::topo::InFilter>(Arena*);
template<> ::onos::topo::Kind* Arena::CreateMaybeMessage<::onos::topo::Kind>(Arena*);
template<> ::onos::topo::ListRequest* Arena::CreateMaybeMessage<::onos::topo::ListRequest>(Arena*);
template<> ::onos::topo::ListResponse* Arena::CreateMaybeMessage<::onos::topo::ListResponse>(Arena*);
template<> ::onos::topo::NotFilter* Arena::CreateMaybeMessage<::onos::topo::NotFilter>(Arena*);
template<> ::onos::topo::Object* Arena::CreateMaybeMessage<::onos::topo::Object>(Arena*);
template<> ::onos::topo::Object_AspectsEntry_DoNotUse* Arena::CreateMaybeMessage<::onos::topo::Object_AspectsEntry_DoNotUse>(Arena*);
template<> ::onos::topo::Object_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::onos::topo::Object_LabelsEntry_DoNotUse>(Arena*);
template<> ::onos::topo::Relation* Arena::CreateMaybeMessage<::onos::topo::Relation>(Arena*);
template<> ::onos::topo::RelationFilter* Arena::CreateMaybeMessage<::onos::topo::RelationFilter>(Arena*);
template<> ::onos::topo::UpdateRequest* Arena::CreateMaybeMessage<::onos::topo::UpdateRequest>(Arena*);
template<> ::onos::topo::UpdateResponse* Arena::CreateMaybeMessage<::onos::topo::UpdateResponse>(Arena*);
template<> ::onos::topo::WatchRequest* Arena::CreateMaybeMessage<::onos::topo::WatchRequest>(Arena*);
template<> ::onos::topo::WatchResponse* Arena::CreateMaybeMessage<::onos::topo::WatchResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace onos {
namespace topo {

enum Object_Type : int {
  Object_Type_UNSPECIFIED = 0,
  Object_Type_ENTITY = 1,
  Object_Type_RELATION = 2,
  Object_Type_KIND = 3,
  Object_Type_Object_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Object_Type_Object_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Object_Type_IsValid(int value);
constexpr Object_Type Object_Type_Type_MIN = Object_Type_UNSPECIFIED;
constexpr Object_Type Object_Type_Type_MAX = Object_Type_KIND;
constexpr int Object_Type_Type_ARRAYSIZE = Object_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Object_Type_descriptor();
template<typename T>
inline const std::string& Object_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Object_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Object_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Object_Type_descriptor(), enum_t_value);
}
inline bool Object_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Object_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Object_Type>(
    Object_Type_descriptor(), name, value);
}
enum EventType : int {
  NONE = 0,
  ADDED = 1,
  UPDATED = 2,
  REMOVED = 3,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = NONE;
constexpr EventType EventType_MAX = REMOVED;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor();
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventType_descriptor(), enum_t_value);
}
inline bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
enum RelationFilterScope : int {
  TARGETS_ONLY = 0,
  ALL = 1,
  SOURCE_AND_TARGETS = 2,
  RELATIONS_ONLY = 3,
  RELATIONS_AND_TARGETS = 4,
  RelationFilterScope_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RelationFilterScope_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RelationFilterScope_IsValid(int value);
constexpr RelationFilterScope RelationFilterScope_MIN = TARGETS_ONLY;
constexpr RelationFilterScope RelationFilterScope_MAX = RELATIONS_AND_TARGETS;
constexpr int RelationFilterScope_ARRAYSIZE = RelationFilterScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RelationFilterScope_descriptor();
template<typename T>
inline const std::string& RelationFilterScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RelationFilterScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RelationFilterScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RelationFilterScope_descriptor(), enum_t_value);
}
inline bool RelationFilterScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RelationFilterScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RelationFilterScope>(
    RelationFilterScope_descriptor(), name, value);
}
enum SortOrder : int {
  UNORDERED = 0,
  ASCENDING = 1,
  DESCENDING = 2,
  SortOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SortOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SortOrder_IsValid(int value);
constexpr SortOrder SortOrder_MIN = UNORDERED;
constexpr SortOrder SortOrder_MAX = DESCENDING;
constexpr int SortOrder_ARRAYSIZE = SortOrder_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortOrder_descriptor();
template<typename T>
inline const std::string& SortOrder_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SortOrder>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SortOrder_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SortOrder_descriptor(), enum_t_value);
}
inline bool SortOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortOrder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SortOrder>(
    SortOrder_descriptor(), name, value);
}
// ===================================================================

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .onos.topo.Object object = 2 [(.gogoproto.nullable) = false];
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::onos::topo::Object& object() const;
  PROTOBUF_NODISCARD ::onos::topo::Object* release_object();
  ::onos::topo::Object* mutable_object();
  void set_allocated_object(::onos::topo::Object* object);
  private:
  const ::onos::topo::Object& _internal_object() const;
  ::onos::topo::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::onos::topo::Object* object);
  ::onos::topo::Object* unsafe_arena_release_object();

  // .onos.topo.EventType type = 1;
  void clear_type();
  ::onos::topo::EventType type() const;
  void set_type(::onos::topo::EventType value);
  private:
  ::onos::topo::EventType _internal_type() const;
  void _internal_set_type(::onos::topo::EventType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Object* object_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit constexpr CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .onos.topo.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::onos::topo::Object& object() const;
  PROTOBUF_NODISCARD ::onos::topo::Object* release_object();
  ::onos::topo::Object* mutable_object();
  void set_allocated_object(::onos::topo::Object* object);
  private:
  const ::onos::topo::Object& _internal_object() const;
  ::onos::topo::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::onos::topo::Object* object);
  ::onos::topo::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:onos.topo.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class CreateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.CreateResponse) */ {
 public:
  inline CreateResponse() : CreateResponse(nullptr) {}
  ~CreateResponse() override;
  explicit constexpr CreateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateResponse(const CreateResponse& from);
  CreateResponse(CreateResponse&& from) noexcept
    : CreateResponse() {
    *this = ::std::move(from);
  }

  inline CreateResponse& operator=(const CreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateResponse& operator=(CreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateResponse* internal_default_instance() {
    return reinterpret_cast<const CreateResponse*>(
               &_CreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateResponse& a, CreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.CreateResponse";
  }
  protected:
  explicit CreateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .onos.topo.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::onos::topo::Object& object() const;
  PROTOBUF_NODISCARD ::onos::topo::Object* release_object();
  ::onos::topo::Object* mutable_object();
  void set_allocated_object(::onos::topo::Object* object);
  private:
  const ::onos::topo::Object& _internal_object() const;
  ::onos::topo::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::onos::topo::Object* object);
  ::onos::topo::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:onos.topo.CreateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class GetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.GetRequest) */ {
 public:
  inline GetRequest() : GetRequest(nullptr) {}
  ~GetRequest() override;
  explicit constexpr GetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.GetRequest";
  }
  protected:
  explicit GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.GetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class GetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.GetResponse) */ {
 public:
  inline GetResponse() : GetResponse(nullptr) {}
  ~GetResponse() override;
  explicit constexpr GetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.GetResponse";
  }
  protected:
  explicit GetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .onos.topo.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::onos::topo::Object& object() const;
  PROTOBUF_NODISCARD ::onos::topo::Object* release_object();
  ::onos::topo::Object* mutable_object();
  void set_allocated_object(::onos::topo::Object* object);
  private:
  const ::onos::topo::Object& _internal_object() const;
  ::onos::topo::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::onos::topo::Object* object);
  ::onos::topo::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:onos.topo.GetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class UpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.UpdateRequest) */ {
 public:
  inline UpdateRequest() : UpdateRequest(nullptr) {}
  ~UpdateRequest() override;
  explicit constexpr UpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRequest(const UpdateRequest& from);
  UpdateRequest(UpdateRequest&& from) noexcept
    : UpdateRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRequest& operator=(UpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRequest*>(
               &_UpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateRequest& a, UpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.UpdateRequest";
  }
  protected:
  explicit UpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .onos.topo.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::onos::topo::Object& object() const;
  PROTOBUF_NODISCARD ::onos::topo::Object* release_object();
  ::onos::topo::Object* mutable_object();
  void set_allocated_object(::onos::topo::Object* object);
  private:
  const ::onos::topo::Object& _internal_object() const;
  ::onos::topo::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::onos::topo::Object* object);
  ::onos::topo::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:onos.topo.UpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class UpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.UpdateResponse) */ {
 public:
  inline UpdateResponse() : UpdateResponse(nullptr) {}
  ~UpdateResponse() override;
  explicit constexpr UpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateResponse(const UpdateResponse& from);
  UpdateResponse(UpdateResponse&& from) noexcept
    : UpdateResponse() {
    *this = ::std::move(from);
  }

  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateResponse& operator=(UpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateResponse*>(
               &_UpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateResponse& a, UpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.UpdateResponse";
  }
  protected:
  explicit UpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
  };
  // .onos.topo.Object object = 1;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::onos::topo::Object& object() const;
  PROTOBUF_NODISCARD ::onos::topo::Object* release_object();
  ::onos::topo::Object* mutable_object();
  void set_allocated_object(::onos::topo::Object* object);
  private:
  const ::onos::topo::Object& _internal_object() const;
  ::onos::topo::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::onos::topo::Object* object);
  ::onos::topo::Object* unsafe_arena_release_object();

  // @@protoc_insertion_point(class_scope:onos.topo.UpdateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Object* object_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit constexpr DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRevisionFieldNumber = 2,
  };
  // string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 revision = 2 [(.gogoproto.casttype) = "Revision"];
  void clear_revision();
  uint64_t revision() const;
  void set_revision(uint64_t value);
  private:
  uint64_t _internal_revision() const;
  void _internal_set_revision(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  uint64_t revision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class DeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:onos.topo.DeleteResponse) */ {
 public:
  inline DeleteResponse() : DeleteResponse(nullptr) {}
  explicit constexpr DeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteResponse(const DeleteResponse& from);
  DeleteResponse(DeleteResponse&& from) noexcept
    : DeleteResponse() {
    *this = ::std::move(from);
  }

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteResponse& operator=(DeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteResponse*>(
               &_DeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteResponse& a, DeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.DeleteResponse";
  }
  protected:
  explicit DeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:onos.topo.DeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class Filter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Filter) */ {
 public:
  inline Filter() : Filter(nullptr) {}
  ~Filter() override;
  explicit constexpr Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filter& default_instance() {
    return *internal_default_instance();
  }
  enum FilterCase {
    kEqual = 1,
    kNot = 2,
    kIn = 3,
    FILTER_NOT_SET = 0,
  };

  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Filter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Filter";
  }
  protected:
  explicit Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 4,
    kEqualFieldNumber = 1,
    kNotFieldNumber = 2,
    kInFieldNumber = 3,
  };
  // string key = 4;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .onos.topo.EqualFilter equal = 1;
  bool has_equal() const;
  private:
  bool _internal_has_equal() const;
  public:
  void clear_equal();
  const ::onos::topo::EqualFilter& equal() const;
  PROTOBUF_NODISCARD ::onos::topo::EqualFilter* release_equal();
  ::onos::topo::EqualFilter* mutable_equal();
  void set_allocated_equal(::onos::topo::EqualFilter* equal);
  private:
  const ::onos::topo::EqualFilter& _internal_equal() const;
  ::onos::topo::EqualFilter* _internal_mutable_equal();
  public:
  void unsafe_arena_set_allocated_equal(
      ::onos::topo::EqualFilter* equal);
  ::onos::topo::EqualFilter* unsafe_arena_release_equal();

  // .onos.topo.NotFilter not = 2;
  bool has_not_() const;
  private:
  bool _internal_has_not_() const;
  public:
  void clear_not_();
  const ::onos::topo::NotFilter& not_() const;
  PROTOBUF_NODISCARD ::onos::topo::NotFilter* release_not_();
  ::onos::topo::NotFilter* mutable_not_();
  void set_allocated_not_(::onos::topo::NotFilter* not_);
  private:
  const ::onos::topo::NotFilter& _internal_not_() const;
  ::onos::topo::NotFilter* _internal_mutable_not_();
  public:
  void unsafe_arena_set_allocated_not_(
      ::onos::topo::NotFilter* not_);
  ::onos::topo::NotFilter* unsafe_arena_release_not_();

  // .onos.topo.InFilter in = 3;
  bool has_in() const;
  private:
  bool _internal_has_in() const;
  public:
  void clear_in();
  const ::onos::topo::InFilter& in() const;
  PROTOBUF_NODISCARD ::onos::topo::InFilter* release_in();
  ::onos::topo::InFilter* mutable_in();
  void set_allocated_in(::onos::topo::InFilter* in);
  private:
  const ::onos::topo::InFilter& _internal_in() const;
  ::onos::topo::InFilter* _internal_mutable_in();
  public:
  void unsafe_arena_set_allocated_in(
      ::onos::topo::InFilter* in);
  ::onos::topo::InFilter* unsafe_arena_release_in();

  void clear_filter();
  FilterCase filter_case() const;
  // @@protoc_insertion_point(class_scope:onos.topo.Filter)
 private:
  class _Internal;
  void set_has_equal();
  void set_has_not_();
  void set_has_in();

  inline bool has_filter() const;
  inline void clear_has_filter();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  union FilterUnion {
    constexpr FilterUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::onos::topo::EqualFilter* equal_;
    ::onos::topo::NotFilter* not__;
    ::onos::topo::InFilter* in_;
  } filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class EqualFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.EqualFilter) */ {
 public:
  inline EqualFilter() : EqualFilter(nullptr) {}
  ~EqualFilter() override;
  explicit constexpr EqualFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EqualFilter(const EqualFilter& from);
  EqualFilter(EqualFilter&& from) noexcept
    : EqualFilter() {
    *this = ::std::move(from);
  }

  inline EqualFilter& operator=(const EqualFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline EqualFilter& operator=(EqualFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EqualFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const EqualFilter* internal_default_instance() {
    return reinterpret_cast<const EqualFilter*>(
               &_EqualFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EqualFilter& a, EqualFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(EqualFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EqualFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EqualFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EqualFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EqualFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EqualFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EqualFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.EqualFilter";
  }
  protected:
  explicit EqualFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.EqualFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class InFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.InFilter) */ {
 public:
  inline InFilter() : InFilter(nullptr) {}
  ~InFilter() override;
  explicit constexpr InFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InFilter(const InFilter& from);
  InFilter(InFilter&& from) noexcept
    : InFilter() {
    *this = ::std::move(from);
  }

  inline InFilter& operator=(const InFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InFilter& operator=(InFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const InFilter* internal_default_instance() {
    return reinterpret_cast<const InFilter*>(
               &_InFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InFilter& a, InFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(InFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.InFilter";
  }
  protected:
  explicit InFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.InFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class NotFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.NotFilter) */ {
 public:
  inline NotFilter() : NotFilter(nullptr) {}
  ~NotFilter() override;
  explicit constexpr NotFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotFilter(const NotFilter& from);
  NotFilter(NotFilter&& from) noexcept
    : NotFilter() {
    *this = ::std::move(from);
  }

  inline NotFilter& operator=(const NotFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotFilter& operator=(NotFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotFilter* internal_default_instance() {
    return reinterpret_cast<const NotFilter*>(
               &_NotFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NotFilter& a, NotFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(NotFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.NotFilter";
  }
  protected:
  explicit NotFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInnerFieldNumber = 1,
  };
  // .onos.topo.Filter inner = 1;
  bool has_inner() const;
  private:
  bool _internal_has_inner() const;
  public:
  void clear_inner();
  const ::onos::topo::Filter& inner() const;
  PROTOBUF_NODISCARD ::onos::topo::Filter* release_inner();
  ::onos::topo::Filter* mutable_inner();
  void set_allocated_inner(::onos::topo::Filter* inner);
  private:
  const ::onos::topo::Filter& _internal_inner() const;
  ::onos::topo::Filter* _internal_mutable_inner();
  public:
  void unsafe_arena_set_allocated_inner(
      ::onos::topo::Filter* inner);
  ::onos::topo::Filter* unsafe_arena_release_inner();

  // @@protoc_insertion_point(class_scope:onos.topo.NotFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Filter* inner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class RelationFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.RelationFilter) */ {
 public:
  inline RelationFilter() : RelationFilter(nullptr) {}
  ~RelationFilter() override;
  explicit constexpr RelationFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelationFilter(const RelationFilter& from);
  RelationFilter(RelationFilter&& from) noexcept
    : RelationFilter() {
    *this = ::std::move(from);
  }

  inline RelationFilter& operator=(const RelationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelationFilter& operator=(RelationFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelationFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelationFilter* internal_default_instance() {
    return reinterpret_cast<const RelationFilter*>(
               &_RelationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RelationFilter& a, RelationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RelationFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelationFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelationFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelationFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RelationFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelationFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.RelationFilter";
  }
  protected:
  explicit RelationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcIdFieldNumber = 1,
    kRelationKindFieldNumber = 2,
    kTargetKindFieldNumber = 3,
    kTargetIdFieldNumber = 5,
    kScopeFieldNumber = 4,
  };
  // string src_id = 1;
  void clear_src_id();
  const std::string& src_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_id();
  PROTOBUF_NODISCARD std::string* release_src_id();
  void set_allocated_src_id(std::string* src_id);
  private:
  const std::string& _internal_src_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_id(const std::string& value);
  std::string* _internal_mutable_src_id();
  public:

  // string relation_kind = 2;
  void clear_relation_kind();
  const std::string& relation_kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relation_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relation_kind();
  PROTOBUF_NODISCARD std::string* release_relation_kind();
  void set_allocated_relation_kind(std::string* relation_kind);
  private:
  const std::string& _internal_relation_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relation_kind(const std::string& value);
  std::string* _internal_mutable_relation_kind();
  public:

  // string target_kind = 3;
  void clear_target_kind();
  const std::string& target_kind() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_kind(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_kind();
  PROTOBUF_NODISCARD std::string* release_target_kind();
  void set_allocated_target_kind(std::string* target_kind);
  private:
  const std::string& _internal_target_kind() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_kind(const std::string& value);
  std::string* _internal_mutable_target_kind();
  public:

  // string target_id = 5;
  void clear_target_id();
  const std::string& target_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* target_id);
  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(const std::string& value);
  std::string* _internal_mutable_target_id();
  public:

  // .onos.topo.RelationFilterScope scope = 4;
  void clear_scope();
  ::onos::topo::RelationFilterScope scope() const;
  void set_scope(::onos::topo::RelationFilterScope value);
  private:
  ::onos::topo::RelationFilterScope _internal_scope() const;
  void _internal_set_scope(::onos::topo::RelationFilterScope value);
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.RelationFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relation_kind_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_kind_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_id_;
  int scope_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class Filters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Filters) */ {
 public:
  inline Filters() : Filters(nullptr) {}
  ~Filters() override;
  explicit constexpr Filters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Filters(const Filters& from);
  Filters(Filters&& from) noexcept
    : Filters() {
    *this = ::std::move(from);
  }

  inline Filters& operator=(const Filters& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filters& operator=(Filters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Filters& default_instance() {
    return *internal_default_instance();
  }
  static inline const Filters* internal_default_instance() {
    return reinterpret_cast<const Filters*>(
               &_Filters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Filters& a, Filters& b) {
    a.Swap(&b);
  }
  inline void Swap(Filters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Filters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Filters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Filters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Filters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Filters& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Filters";
  }
  protected:
  explicit Filters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFiltersFieldNumber = 2,
    kObjectTypesFieldNumber = 4,
    kWithAspectsFieldNumber = 6,
    kKindFilterFieldNumber = 1,
    kRelationFilterFieldNumber = 3,
  };
  // repeated .onos.topo.Filter label_filters = 2;
  int label_filters_size() const;
  private:
  int _internal_label_filters_size() const;
  public:
  void clear_label_filters();
  ::onos::topo::Filter* mutable_label_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Filter >*
      mutable_label_filters();
  private:
  const ::onos::topo::Filter& _internal_label_filters(int index) const;
  ::onos::topo::Filter* _internal_add_label_filters();
  public:
  const ::onos::topo::Filter& label_filters(int index) const;
  ::onos::topo::Filter* add_label_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Filter >&
      label_filters() const;

  // repeated .onos.topo.Object.Type object_types = 4;
  int object_types_size() const;
  private:
  int _internal_object_types_size() const;
  public:
  void clear_object_types();
  private:
  ::onos::topo::Object_Type _internal_object_types(int index) const;
  void _internal_add_object_types(::onos::topo::Object_Type value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_object_types();
  public:
  ::onos::topo::Object_Type object_types(int index) const;
  void set_object_types(int index, ::onos::topo::Object_Type value);
  void add_object_types(::onos::topo::Object_Type value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& object_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_object_types();

  // repeated string with_aspects = 6;
  int with_aspects_size() const;
  private:
  int _internal_with_aspects_size() const;
  public:
  void clear_with_aspects();
  const std::string& with_aspects(int index) const;
  std::string* mutable_with_aspects(int index);
  void set_with_aspects(int index, const std::string& value);
  void set_with_aspects(int index, std::string&& value);
  void set_with_aspects(int index, const char* value);
  void set_with_aspects(int index, const char* value, size_t size);
  std::string* add_with_aspects();
  void add_with_aspects(const std::string& value);
  void add_with_aspects(std::string&& value);
  void add_with_aspects(const char* value);
  void add_with_aspects(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& with_aspects() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_with_aspects();
  private:
  const std::string& _internal_with_aspects(int index) const;
  std::string* _internal_add_with_aspects();
  public:

  // .onos.topo.Filter kind_filter = 1;
  bool has_kind_filter() const;
  private:
  bool _internal_has_kind_filter() const;
  public:
  void clear_kind_filter();
  const ::onos::topo::Filter& kind_filter() const;
  PROTOBUF_NODISCARD ::onos::topo::Filter* release_kind_filter();
  ::onos::topo::Filter* mutable_kind_filter();
  void set_allocated_kind_filter(::onos::topo::Filter* kind_filter);
  private:
  const ::onos::topo::Filter& _internal_kind_filter() const;
  ::onos::topo::Filter* _internal_mutable_kind_filter();
  public:
  void unsafe_arena_set_allocated_kind_filter(
      ::onos::topo::Filter* kind_filter);
  ::onos::topo::Filter* unsafe_arena_release_kind_filter();

  // .onos.topo.RelationFilter relation_filter = 3;
  bool has_relation_filter() const;
  private:
  bool _internal_has_relation_filter() const;
  public:
  void clear_relation_filter();
  const ::onos::topo::RelationFilter& relation_filter() const;
  PROTOBUF_NODISCARD ::onos::topo::RelationFilter* release_relation_filter();
  ::onos::topo::RelationFilter* mutable_relation_filter();
  void set_allocated_relation_filter(::onos::topo::RelationFilter* relation_filter);
  private:
  const ::onos::topo::RelationFilter& _internal_relation_filter() const;
  ::onos::topo::RelationFilter* _internal_mutable_relation_filter();
  public:
  void unsafe_arena_set_allocated_relation_filter(
      ::onos::topo::RelationFilter* relation_filter);
  ::onos::topo::RelationFilter* unsafe_arena_release_relation_filter();

  // @@protoc_insertion_point(class_scope:onos.topo.Filters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Filter > label_filters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> object_types_;
  mutable std::atomic<int> _object_types_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> with_aspects_;
  ::onos::topo::Filter* kind_filter_;
  ::onos::topo::RelationFilter* relation_filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class ListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {}
  ~ListRequest() override;
  explicit constexpr ListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRequest(const ListRequest& from);
  ListRequest(ListRequest&& from) noexcept
    : ListRequest() {
    *this = ::std::move(from);
  }

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
               &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ListRequest& a, ListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.ListRequest";
  }
  protected:
  explicit ListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
    kSortOrderFieldNumber = 2,
  };
  // .onos.topo.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::onos::topo::Filters& filters() const;
  PROTOBUF_NODISCARD ::onos::topo::Filters* release_filters();
  ::onos::topo::Filters* mutable_filters();
  void set_allocated_filters(::onos::topo::Filters* filters);
  private:
  const ::onos::topo::Filters& _internal_filters() const;
  ::onos::topo::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::onos::topo::Filters* filters);
  ::onos::topo::Filters* unsafe_arena_release_filters();

  // .onos.topo.SortOrder sort_order = 2;
  void clear_sort_order();
  ::onos::topo::SortOrder sort_order() const;
  void set_sort_order(::onos::topo::SortOrder value);
  private:
  ::onos::topo::SortOrder _internal_sort_order() const;
  void _internal_set_sort_order(::onos::topo::SortOrder value);
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.ListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Filters* filters_;
  int sort_order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class ListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.ListResponse) */ {
 public:
  inline ListResponse() : ListResponse(nullptr) {}
  ~ListResponse() override;
  explicit constexpr ListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResponse(const ListResponse& from);
  ListResponse(ListResponse&& from) noexcept
    : ListResponse() {
    *this = ::std::move(from);
  }

  inline ListResponse& operator=(const ListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResponse& operator=(ListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResponse* internal_default_instance() {
    return reinterpret_cast<const ListResponse*>(
               &_ListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ListResponse& a, ListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.ListResponse";
  }
  protected:
  explicit ListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .onos.topo.Object objects = 1 [(.gogoproto.nullable) = false];
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::onos::topo::Object* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Object >*
      mutable_objects();
  private:
  const ::onos::topo::Object& _internal_objects(int index) const;
  ::onos::topo::Object* _internal_add_objects();
  public:
  const ::onos::topo::Object& objects(int index) const;
  ::onos::topo::Object* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Object >&
      objects() const;

  // @@protoc_insertion_point(class_scope:onos.topo.ListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Object > objects_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class WatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.WatchRequest) */ {
 public:
  inline WatchRequest() : WatchRequest(nullptr) {}
  ~WatchRequest() override;
  explicit constexpr WatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchRequest(const WatchRequest& from);
  WatchRequest(WatchRequest&& from) noexcept
    : WatchRequest() {
    *this = ::std::move(from);
  }

  inline WatchRequest& operator=(const WatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchRequest& operator=(WatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchRequest* internal_default_instance() {
    return reinterpret_cast<const WatchRequest*>(
               &_WatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WatchRequest& a, WatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.WatchRequest";
  }
  protected:
  explicit WatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
    kNoreplayFieldNumber = 2,
  };
  // .onos.topo.Filters filters = 1;
  bool has_filters() const;
  private:
  bool _internal_has_filters() const;
  public:
  void clear_filters();
  const ::onos::topo::Filters& filters() const;
  PROTOBUF_NODISCARD ::onos::topo::Filters* release_filters();
  ::onos::topo::Filters* mutable_filters();
  void set_allocated_filters(::onos::topo::Filters* filters);
  private:
  const ::onos::topo::Filters& _internal_filters() const;
  ::onos::topo::Filters* _internal_mutable_filters();
  public:
  void unsafe_arena_set_allocated_filters(
      ::onos::topo::Filters* filters);
  ::onos::topo::Filters* unsafe_arena_release_filters();

  // bool noreplay = 2;
  void clear_noreplay();
  bool noreplay() const;
  void set_noreplay(bool value);
  private:
  bool _internal_noreplay() const;
  void _internal_set_noreplay(bool value);
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.WatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Filters* filters_;
  bool noreplay_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class WatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.WatchResponse) */ {
 public:
  inline WatchResponse() : WatchResponse(nullptr) {}
  ~WatchResponse() override;
  explicit constexpr WatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchResponse(const WatchResponse& from);
  WatchResponse(WatchResponse&& from) noexcept
    : WatchResponse() {
    *this = ::std::move(from);
  }

  inline WatchResponse& operator=(const WatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchResponse& operator=(WatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchResponse* internal_default_instance() {
    return reinterpret_cast<const WatchResponse*>(
               &_WatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WatchResponse& a, WatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.WatchResponse";
  }
  protected:
  explicit WatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // .onos.topo.Event event = 1 [(.gogoproto.nullable) = false];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::onos::topo::Event& event() const;
  PROTOBUF_NODISCARD ::onos::topo::Event* release_event();
  ::onos::topo::Event* mutable_event();
  void set_allocated_event(::onos::topo::Event* event);
  private:
  const ::onos::topo::Event& _internal_event() const;
  ::onos::topo::Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::onos::topo::Event* event);
  ::onos::topo::Event* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:onos.topo.WatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::topo::Event* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class Object_AspectsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Object_AspectsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Object_AspectsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::Any,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Object_AspectsEntry_DoNotUse();
  explicit constexpr Object_AspectsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Object_AspectsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Object_AspectsEntry_DoNotUse& other);
  static const Object_AspectsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Object_AspectsEntry_DoNotUse*>(&_Object_AspectsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "onos.topo.Object.AspectsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Object_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Object_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Object_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Object_LabelsEntry_DoNotUse();
  explicit constexpr Object_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Object_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Object_LabelsEntry_DoNotUse& other);
  static const Object_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Object_LabelsEntry_DoNotUse*>(&_Object_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "onos.topo.Object.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "onos.topo.Object.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  explicit constexpr Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  enum ObjCase {
    kEntity = 4,
    kRelation = 5,
    kKind = 6,
    OBJ_NOT_SET = 0,
  };

  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Object& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Object_Type Type;
  static constexpr Type UNSPECIFIED =
    Object_Type_UNSPECIFIED;
  static constexpr Type ENTITY =
    Object_Type_ENTITY;
  static constexpr Type RELATION =
    Object_Type_RELATION;
  static constexpr Type KIND =
    Object_Type_KIND;
  static inline bool Type_IsValid(int value) {
    return Object_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Object_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Object_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Object_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Object_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Object_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Object_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAspectsFieldNumber = 7,
    kLabelsFieldNumber = 8,
    kIdFieldNumber = 1,
    kUuidFieldNumber = 9,
    kRevisionFieldNumber = 2,
    kTypeFieldNumber = 3,
    kEntityFieldNumber = 4,
    kRelationFieldNumber = 5,
    kKindFieldNumber = 6,
  };
  // map<string, .google.protobuf.Any> aspects = 7;
  int aspects_size() const;
  private:
  int _internal_aspects_size() const;
  public:
  void clear_aspects();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      _internal_aspects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      _internal_mutable_aspects();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
      aspects() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_aspects();

  // map<string, string> labels = 8;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string uuid = 9 [(.gogoproto.customname) = "UUID", (.gogoproto.casttype) = "UUID"];
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // uint64 revision = 2 [(.gogoproto.casttype) = "Revision"];
  void clear_revision();
  uint64_t revision() const;
  void set_revision(uint64_t value);
  private:
  uint64_t _internal_revision() const;
  void _internal_set_revision(uint64_t value);
  public:

  // .onos.topo.Object.Type type = 3;
  void clear_type();
  ::onos::topo::Object_Type type() const;
  void set_type(::onos::topo::Object_Type value);
  private:
  ::onos::topo::Object_Type _internal_type() const;
  void _internal_set_type(::onos::topo::Object_Type value);
  public:

  // .onos.topo.Entity entity = 4;
  bool has_entity() const;
  private:
  bool _internal_has_entity() const;
  public:
  void clear_entity();
  const ::onos::topo::Entity& entity() const;
  PROTOBUF_NODISCARD ::onos::topo::Entity* release_entity();
  ::onos::topo::Entity* mutable_entity();
  void set_allocated_entity(::onos::topo::Entity* entity);
  private:
  const ::onos::topo::Entity& _internal_entity() const;
  ::onos::topo::Entity* _internal_mutable_entity();
  public:
  void unsafe_arena_set_allocated_entity(
      ::onos::topo::Entity* entity);
  ::onos::topo::Entity* unsafe_arena_release_entity();

  // .onos.topo.Relation relation = 5;
  bool has_relation() const;
  private:
  bool _internal_has_relation() const;
  public:
  void clear_relation();
  const ::onos::topo::Relation& relation() const;
  PROTOBUF_NODISCARD ::onos::topo::Relation* release_relation();
  ::onos::topo::Relation* mutable_relation();
  void set_allocated_relation(::onos::topo::Relation* relation);
  private:
  const ::onos::topo::Relation& _internal_relation() const;
  ::onos::topo::Relation* _internal_mutable_relation();
  public:
  void unsafe_arena_set_allocated_relation(
      ::onos::topo::Relation* relation);
  ::onos::topo::Relation* unsafe_arena_release_relation();

  // .onos.topo.Kind kind = 6;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const ::onos::topo::Kind& kind() const;
  PROTOBUF_NODISCARD ::onos::topo::Kind* release_kind();
  ::onos::topo::Kind* mutable_kind();
  void set_allocated_kind(::onos::topo::Kind* kind);
  private:
  const ::onos::topo::Kind& _internal_kind() const;
  ::onos::topo::Kind* _internal_mutable_kind();
  public:
  void unsafe_arena_set_allocated_kind(
      ::onos::topo::Kind* kind);
  ::onos::topo::Kind* unsafe_arena_release_kind();

  void clear_obj();
  ObjCase obj_case() const;
  // @@protoc_insertion_point(class_scope:onos.topo.Object)
 private:
  class _Internal;
  void set_has_entity();
  void set_has_relation();
  void set_has_kind();

  inline bool has_obj() const;
  inline void clear_has_obj();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Object_AspectsEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::Any,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> aspects_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Object_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  uint64_t revision_;
  int type_;
  union ObjUnion {
    constexpr ObjUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::onos::topo::Entity* entity_;
    ::onos::topo::Relation* relation_;
    ::onos::topo::Kind* kind_;
  } obj_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class Entity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Entity) */ {
 public:
  inline Entity() : Entity(nullptr) {}
  ~Entity() override;
  explicit constexpr Entity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Entity(const Entity& from);
  Entity(Entity&& from) noexcept
    : Entity() {
    *this = ::std::move(from);
  }

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity& operator=(Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
               &_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Entity& a, Entity& b) {
    a.Swap(&b);
  }
  inline void Swap(Entity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Entity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Entity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Entity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Entity";
  }
  protected:
  explicit Entity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcRelationIdsFieldNumber = 2,
    kTgtRelationIdsFieldNumber = 3,
    kKindIdFieldNumber = 1,
  };
  // repeated string src_relation_ids = 2 [(.gogoproto.customname) = "SrcRelationIDs", (.gogoproto.casttype) = "ID"];
  int src_relation_ids_size() const;
  private:
  int _internal_src_relation_ids_size() const;
  public:
  void clear_src_relation_ids();
  const std::string& src_relation_ids(int index) const;
  std::string* mutable_src_relation_ids(int index);
  void set_src_relation_ids(int index, const std::string& value);
  void set_src_relation_ids(int index, std::string&& value);
  void set_src_relation_ids(int index, const char* value);
  void set_src_relation_ids(int index, const char* value, size_t size);
  std::string* add_src_relation_ids();
  void add_src_relation_ids(const std::string& value);
  void add_src_relation_ids(std::string&& value);
  void add_src_relation_ids(const char* value);
  void add_src_relation_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& src_relation_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_src_relation_ids();
  private:
  const std::string& _internal_src_relation_ids(int index) const;
  std::string* _internal_add_src_relation_ids();
  public:

  // repeated string tgt_relation_ids = 3 [(.gogoproto.customname) = "TgtRelationIDs", (.gogoproto.casttype) = "ID"];
  int tgt_relation_ids_size() const;
  private:
  int _internal_tgt_relation_ids_size() const;
  public:
  void clear_tgt_relation_ids();
  const std::string& tgt_relation_ids(int index) const;
  std::string* mutable_tgt_relation_ids(int index);
  void set_tgt_relation_ids(int index, const std::string& value);
  void set_tgt_relation_ids(int index, std::string&& value);
  void set_tgt_relation_ids(int index, const char* value);
  void set_tgt_relation_ids(int index, const char* value, size_t size);
  std::string* add_tgt_relation_ids();
  void add_tgt_relation_ids(const std::string& value);
  void add_tgt_relation_ids(std::string&& value);
  void add_tgt_relation_ids(const char* value);
  void add_tgt_relation_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tgt_relation_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tgt_relation_ids();
  private:
  const std::string& _internal_tgt_relation_ids(int index) const;
  std::string* _internal_add_tgt_relation_ids();
  public:

  // string kind_id = 1 [(.gogoproto.customname) = "KindID", (.gogoproto.casttype) = "ID"];
  void clear_kind_id();
  const std::string& kind_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind_id();
  PROTOBUF_NODISCARD std::string* release_kind_id();
  void set_allocated_kind_id(std::string* kind_id);
  private:
  const std::string& _internal_kind_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind_id(const std::string& value);
  std::string* _internal_mutable_kind_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.Entity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> src_relation_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tgt_relation_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class Relation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Relation) */ {
 public:
  inline Relation() : Relation(nullptr) {}
  ~Relation() override;
  explicit constexpr Relation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Relation(const Relation& from);
  Relation(Relation&& from) noexcept
    : Relation() {
    *this = ::std::move(from);
  }

  inline Relation& operator=(const Relation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Relation& operator=(Relation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Relation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Relation* internal_default_instance() {
    return reinterpret_cast<const Relation*>(
               &_Relation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Relation& a, Relation& b) {
    a.Swap(&b);
  }
  inline void Swap(Relation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Relation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Relation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Relation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Relation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Relation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Relation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Relation";
  }
  protected:
  explicit Relation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKindIdFieldNumber = 1,
    kSrcEntityIdFieldNumber = 2,
    kTgtEntityIdFieldNumber = 3,
  };
  // string kind_id = 1 [(.gogoproto.customname) = "KindID", (.gogoproto.casttype) = "ID"];
  void clear_kind_id();
  const std::string& kind_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kind_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kind_id();
  PROTOBUF_NODISCARD std::string* release_kind_id();
  void set_allocated_kind_id(std::string* kind_id);
  private:
  const std::string& _internal_kind_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kind_id(const std::string& value);
  std::string* _internal_mutable_kind_id();
  public:

  // string src_entity_id = 2 [(.gogoproto.customname) = "SrcEntityID", (.gogoproto.casttype) = "ID"];
  void clear_src_entity_id();
  const std::string& src_entity_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_entity_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_entity_id();
  PROTOBUF_NODISCARD std::string* release_src_entity_id();
  void set_allocated_src_entity_id(std::string* src_entity_id);
  private:
  const std::string& _internal_src_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_entity_id(const std::string& value);
  std::string* _internal_mutable_src_entity_id();
  public:

  // string tgt_entity_id = 3 [(.gogoproto.customname) = "TgtEntityID", (.gogoproto.casttype) = "ID"];
  void clear_tgt_entity_id();
  const std::string& tgt_entity_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tgt_entity_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tgt_entity_id();
  PROTOBUF_NODISCARD std::string* release_tgt_entity_id();
  void set_allocated_tgt_entity_id(std::string* tgt_entity_id);
  private:
  const std::string& _internal_tgt_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tgt_entity_id(const std::string& value);
  std::string* _internal_mutable_tgt_entity_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.Relation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_entity_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tgt_entity_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// -------------------------------------------------------------------

class Kind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.topo.Kind) */ {
 public:
  inline Kind() : Kind(nullptr) {}
  ~Kind() override;
  explicit constexpr Kind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Kind(const Kind& from);
  Kind(Kind&& from) noexcept
    : Kind() {
    *this = ::std::move(from);
  }

  inline Kind& operator=(const Kind& from) {
    CopyFrom(from);
    return *this;
  }
  inline Kind& operator=(Kind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Kind& default_instance() {
    return *internal_default_instance();
  }
  static inline const Kind* internal_default_instance() {
    return reinterpret_cast<const Kind*>(
               &_Kind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Kind& a, Kind& b) {
    a.Swap(&b);
  }
  inline void Swap(Kind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Kind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Kind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Kind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Kind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Kind& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Kind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.topo.Kind";
  }
  protected:
  explicit Kind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:onos.topo.Kind)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2ftopo_2ftopo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Event

// .onos.topo.EventType type = 1;
inline void Event::clear_type() {
  type_ = 0;
}
inline ::onos::topo::EventType Event::_internal_type() const {
  return static_cast< ::onos::topo::EventType >(type_);
}
inline ::onos::topo::EventType Event::type() const {
  // @@protoc_insertion_point(field_get:onos.topo.Event.type)
  return _internal_type();
}
inline void Event::_internal_set_type(::onos::topo::EventType value) {
  
  type_ = value;
}
inline void Event::set_type(::onos::topo::EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.topo.Event.type)
}

// .onos.topo.Object object = 2 [(.gogoproto.nullable) = false];
inline bool Event::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool Event::has_object() const {
  return _internal_has_object();
}
inline void Event::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::onos::topo::Object& Event::_internal_object() const {
  const ::onos::topo::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Object&>(
      ::onos::topo::_Object_default_instance_);
}
inline const ::onos::topo::Object& Event::object() const {
  // @@protoc_insertion_point(field_get:onos.topo.Event.object)
  return _internal_object();
}
inline void Event::unsafe_arena_set_allocated_object(
    ::onos::topo::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Event.object)
}
inline ::onos::topo::Object* Event::release_object() {
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Object* Event::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:onos.topo.Event.object)
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::onos::topo::Object* Event::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::onos::topo::Object* Event::mutable_object() {
  ::onos::topo::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:onos.topo.Event.object)
  return _msg;
}
inline void Event::set_allocated_object(::onos::topo::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Event.object)
}

// -------------------------------------------------------------------

// CreateRequest

// .onos.topo.Object object = 1;
inline bool CreateRequest::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool CreateRequest::has_object() const {
  return _internal_has_object();
}
inline void CreateRequest::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::onos::topo::Object& CreateRequest::_internal_object() const {
  const ::onos::topo::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Object&>(
      ::onos::topo::_Object_default_instance_);
}
inline const ::onos::topo::Object& CreateRequest::object() const {
  // @@protoc_insertion_point(field_get:onos.topo.CreateRequest.object)
  return _internal_object();
}
inline void CreateRequest::unsafe_arena_set_allocated_object(
    ::onos::topo::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.CreateRequest.object)
}
inline ::onos::topo::Object* CreateRequest::release_object() {
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Object* CreateRequest::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:onos.topo.CreateRequest.object)
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::onos::topo::Object* CreateRequest::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::onos::topo::Object* CreateRequest::mutable_object() {
  ::onos::topo::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:onos.topo.CreateRequest.object)
  return _msg;
}
inline void CreateRequest::set_allocated_object(::onos::topo::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.CreateRequest.object)
}

// -------------------------------------------------------------------

// CreateResponse

// .onos.topo.Object object = 1;
inline bool CreateResponse::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool CreateResponse::has_object() const {
  return _internal_has_object();
}
inline void CreateResponse::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::onos::topo::Object& CreateResponse::_internal_object() const {
  const ::onos::topo::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Object&>(
      ::onos::topo::_Object_default_instance_);
}
inline const ::onos::topo::Object& CreateResponse::object() const {
  // @@protoc_insertion_point(field_get:onos.topo.CreateResponse.object)
  return _internal_object();
}
inline void CreateResponse::unsafe_arena_set_allocated_object(
    ::onos::topo::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.CreateResponse.object)
}
inline ::onos::topo::Object* CreateResponse::release_object() {
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Object* CreateResponse::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:onos.topo.CreateResponse.object)
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::onos::topo::Object* CreateResponse::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::onos::topo::Object* CreateResponse::mutable_object() {
  ::onos::topo::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:onos.topo.CreateResponse.object)
  return _msg;
}
inline void CreateResponse::set_allocated_object(::onos::topo::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.CreateResponse.object)
}

// -------------------------------------------------------------------

// GetRequest

// string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ID"];
inline void GetRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetRequest::id() const {
  // @@protoc_insertion_point(field_get:onos.topo.GetRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.GetRequest.id)
}
inline std::string* GetRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.GetRequest.id)
  return _s;
}
inline const std::string& GetRequest::_internal_id() const {
  return id_.Get();
}
inline void GetRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRequest::release_id() {
  // @@protoc_insertion_point(field_release:onos.topo.GetRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.GetRequest.id)
}

// -------------------------------------------------------------------

// GetResponse

// .onos.topo.Object object = 1;
inline bool GetResponse::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool GetResponse::has_object() const {
  return _internal_has_object();
}
inline void GetResponse::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::onos::topo::Object& GetResponse::_internal_object() const {
  const ::onos::topo::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Object&>(
      ::onos::topo::_Object_default_instance_);
}
inline const ::onos::topo::Object& GetResponse::object() const {
  // @@protoc_insertion_point(field_get:onos.topo.GetResponse.object)
  return _internal_object();
}
inline void GetResponse::unsafe_arena_set_allocated_object(
    ::onos::topo::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.GetResponse.object)
}
inline ::onos::topo::Object* GetResponse::release_object() {
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Object* GetResponse::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:onos.topo.GetResponse.object)
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::onos::topo::Object* GetResponse::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::onos::topo::Object* GetResponse::mutable_object() {
  ::onos::topo::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:onos.topo.GetResponse.object)
  return _msg;
}
inline void GetResponse::set_allocated_object(::onos::topo::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.GetResponse.object)
}

// -------------------------------------------------------------------

// UpdateRequest

// .onos.topo.Object object = 1;
inline bool UpdateRequest::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool UpdateRequest::has_object() const {
  return _internal_has_object();
}
inline void UpdateRequest::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::onos::topo::Object& UpdateRequest::_internal_object() const {
  const ::onos::topo::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Object&>(
      ::onos::topo::_Object_default_instance_);
}
inline const ::onos::topo::Object& UpdateRequest::object() const {
  // @@protoc_insertion_point(field_get:onos.topo.UpdateRequest.object)
  return _internal_object();
}
inline void UpdateRequest::unsafe_arena_set_allocated_object(
    ::onos::topo::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.UpdateRequest.object)
}
inline ::onos::topo::Object* UpdateRequest::release_object() {
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Object* UpdateRequest::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:onos.topo.UpdateRequest.object)
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::onos::topo::Object* UpdateRequest::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::onos::topo::Object* UpdateRequest::mutable_object() {
  ::onos::topo::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:onos.topo.UpdateRequest.object)
  return _msg;
}
inline void UpdateRequest::set_allocated_object(::onos::topo::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.UpdateRequest.object)
}

// -------------------------------------------------------------------

// UpdateResponse

// .onos.topo.Object object = 1;
inline bool UpdateResponse::_internal_has_object() const {
  return this != internal_default_instance() && object_ != nullptr;
}
inline bool UpdateResponse::has_object() const {
  return _internal_has_object();
}
inline void UpdateResponse::clear_object() {
  if (GetArenaForAllocation() == nullptr && object_ != nullptr) {
    delete object_;
  }
  object_ = nullptr;
}
inline const ::onos::topo::Object& UpdateResponse::_internal_object() const {
  const ::onos::topo::Object* p = object_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Object&>(
      ::onos::topo::_Object_default_instance_);
}
inline const ::onos::topo::Object& UpdateResponse::object() const {
  // @@protoc_insertion_point(field_get:onos.topo.UpdateResponse.object)
  return _internal_object();
}
inline void UpdateResponse::unsafe_arena_set_allocated_object(
    ::onos::topo::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_);
  }
  object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.UpdateResponse.object)
}
inline ::onos::topo::Object* UpdateResponse::release_object() {
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Object* UpdateResponse::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:onos.topo.UpdateResponse.object)
  
  ::onos::topo::Object* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::onos::topo::Object* UpdateResponse::_internal_mutable_object() {
  
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Object>(GetArenaForAllocation());
    object_ = p;
  }
  return object_;
}
inline ::onos::topo::Object* UpdateResponse::mutable_object() {
  ::onos::topo::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:onos.topo.UpdateResponse.object)
  return _msg;
}
inline void UpdateResponse::set_allocated_object(::onos::topo::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Object>::GetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.UpdateResponse.object)
}

// -------------------------------------------------------------------

// DeleteRequest

// string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ID"];
inline void DeleteRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteRequest::id() const {
  // @@protoc_insertion_point(field_get:onos.topo.DeleteRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.DeleteRequest.id)
}
inline std::string* DeleteRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.DeleteRequest.id)
  return _s;
}
inline const std::string& DeleteRequest::_internal_id() const {
  return id_.Get();
}
inline void DeleteRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_id() {
  // @@protoc_insertion_point(field_release:onos.topo.DeleteRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.DeleteRequest.id)
}

// uint64 revision = 2 [(.gogoproto.casttype) = "Revision"];
inline void DeleteRequest::clear_revision() {
  revision_ = uint64_t{0u};
}
inline uint64_t DeleteRequest::_internal_revision() const {
  return revision_;
}
inline uint64_t DeleteRequest::revision() const {
  // @@protoc_insertion_point(field_get:onos.topo.DeleteRequest.revision)
  return _internal_revision();
}
inline void DeleteRequest::_internal_set_revision(uint64_t value) {
  
  revision_ = value;
}
inline void DeleteRequest::set_revision(uint64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:onos.topo.DeleteRequest.revision)
}

// -------------------------------------------------------------------

// DeleteResponse

// -------------------------------------------------------------------

// Filter

// .onos.topo.EqualFilter equal = 1;
inline bool Filter::_internal_has_equal() const {
  return filter_case() == kEqual;
}
inline bool Filter::has_equal() const {
  return _internal_has_equal();
}
inline void Filter::set_has_equal() {
  _oneof_case_[0] = kEqual;
}
inline void Filter::clear_equal() {
  if (_internal_has_equal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.equal_;
    }
    clear_has_filter();
  }
}
inline ::onos::topo::EqualFilter* Filter::release_equal() {
  // @@protoc_insertion_point(field_release:onos.topo.Filter.equal)
  if (_internal_has_equal()) {
    clear_has_filter();
      ::onos::topo::EqualFilter* temp = filter_.equal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.equal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::topo::EqualFilter& Filter::_internal_equal() const {
  return _internal_has_equal()
      ? *filter_.equal_
      : reinterpret_cast< ::onos::topo::EqualFilter&>(::onos::topo::_EqualFilter_default_instance_);
}
inline const ::onos::topo::EqualFilter& Filter::equal() const {
  // @@protoc_insertion_point(field_get:onos.topo.Filter.equal)
  return _internal_equal();
}
inline ::onos::topo::EqualFilter* Filter::unsafe_arena_release_equal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.topo.Filter.equal)
  if (_internal_has_equal()) {
    clear_has_filter();
    ::onos::topo::EqualFilter* temp = filter_.equal_;
    filter_.equal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filter::unsafe_arena_set_allocated_equal(::onos::topo::EqualFilter* equal) {
  clear_filter();
  if (equal) {
    set_has_equal();
    filter_.equal_ = equal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Filter.equal)
}
inline ::onos::topo::EqualFilter* Filter::_internal_mutable_equal() {
  if (!_internal_has_equal()) {
    clear_filter();
    set_has_equal();
    filter_.equal_ = CreateMaybeMessage< ::onos::topo::EqualFilter >(GetArenaForAllocation());
  }
  return filter_.equal_;
}
inline ::onos::topo::EqualFilter* Filter::mutable_equal() {
  ::onos::topo::EqualFilter* _msg = _internal_mutable_equal();
  // @@protoc_insertion_point(field_mutable:onos.topo.Filter.equal)
  return _msg;
}

// .onos.topo.NotFilter not = 2;
inline bool Filter::_internal_has_not_() const {
  return filter_case() == kNot;
}
inline bool Filter::has_not_() const {
  return _internal_has_not_();
}
inline void Filter::set_has_not_() {
  _oneof_case_[0] = kNot;
}
inline void Filter::clear_not_() {
  if (_internal_has_not_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.not__;
    }
    clear_has_filter();
  }
}
inline ::onos::topo::NotFilter* Filter::release_not_() {
  // @@protoc_insertion_point(field_release:onos.topo.Filter.not)
  if (_internal_has_not_()) {
    clear_has_filter();
      ::onos::topo::NotFilter* temp = filter_.not__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::topo::NotFilter& Filter::_internal_not_() const {
  return _internal_has_not_()
      ? *filter_.not__
      : reinterpret_cast< ::onos::topo::NotFilter&>(::onos::topo::_NotFilter_default_instance_);
}
inline const ::onos::topo::NotFilter& Filter::not_() const {
  // @@protoc_insertion_point(field_get:onos.topo.Filter.not)
  return _internal_not_();
}
inline ::onos::topo::NotFilter* Filter::unsafe_arena_release_not_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.topo.Filter.not)
  if (_internal_has_not_()) {
    clear_has_filter();
    ::onos::topo::NotFilter* temp = filter_.not__;
    filter_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filter::unsafe_arena_set_allocated_not_(::onos::topo::NotFilter* not_) {
  clear_filter();
  if (not_) {
    set_has_not_();
    filter_.not__ = not_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Filter.not)
}
inline ::onos::topo::NotFilter* Filter::_internal_mutable_not_() {
  if (!_internal_has_not_()) {
    clear_filter();
    set_has_not_();
    filter_.not__ = CreateMaybeMessage< ::onos::topo::NotFilter >(GetArenaForAllocation());
  }
  return filter_.not__;
}
inline ::onos::topo::NotFilter* Filter::mutable_not_() {
  ::onos::topo::NotFilter* _msg = _internal_mutable_not_();
  // @@protoc_insertion_point(field_mutable:onos.topo.Filter.not)
  return _msg;
}

// .onos.topo.InFilter in = 3;
inline bool Filter::_internal_has_in() const {
  return filter_case() == kIn;
}
inline bool Filter::has_in() const {
  return _internal_has_in();
}
inline void Filter::set_has_in() {
  _oneof_case_[0] = kIn;
}
inline void Filter::clear_in() {
  if (_internal_has_in()) {
    if (GetArenaForAllocation() == nullptr) {
      delete filter_.in_;
    }
    clear_has_filter();
  }
}
inline ::onos::topo::InFilter* Filter::release_in() {
  // @@protoc_insertion_point(field_release:onos.topo.Filter.in)
  if (_internal_has_in()) {
    clear_has_filter();
      ::onos::topo::InFilter* temp = filter_.in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    filter_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::topo::InFilter& Filter::_internal_in() const {
  return _internal_has_in()
      ? *filter_.in_
      : reinterpret_cast< ::onos::topo::InFilter&>(::onos::topo::_InFilter_default_instance_);
}
inline const ::onos::topo::InFilter& Filter::in() const {
  // @@protoc_insertion_point(field_get:onos.topo.Filter.in)
  return _internal_in();
}
inline ::onos::topo::InFilter* Filter::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.topo.Filter.in)
  if (_internal_has_in()) {
    clear_has_filter();
    ::onos::topo::InFilter* temp = filter_.in_;
    filter_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Filter::unsafe_arena_set_allocated_in(::onos::topo::InFilter* in) {
  clear_filter();
  if (in) {
    set_has_in();
    filter_.in_ = in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Filter.in)
}
inline ::onos::topo::InFilter* Filter::_internal_mutable_in() {
  if (!_internal_has_in()) {
    clear_filter();
    set_has_in();
    filter_.in_ = CreateMaybeMessage< ::onos::topo::InFilter >(GetArenaForAllocation());
  }
  return filter_.in_;
}
inline ::onos::topo::InFilter* Filter::mutable_in() {
  ::onos::topo::InFilter* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:onos.topo.Filter.in)
  return _msg;
}

// string key = 4;
inline void Filter::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& Filter::key() const {
  // @@protoc_insertion_point(field_get:onos.topo.Filter.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Filter::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Filter.key)
}
inline std::string* Filter::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:onos.topo.Filter.key)
  return _s;
}
inline const std::string& Filter::_internal_key() const {
  return key_.Get();
}
inline void Filter::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Filter::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Filter::release_key() {
  // @@protoc_insertion_point(field_release:onos.topo.Filter.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Filter::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Filter.key)
}

inline bool Filter::has_filter() const {
  return filter_case() != FILTER_NOT_SET;
}
inline void Filter::clear_has_filter() {
  _oneof_case_[0] = FILTER_NOT_SET;
}
inline Filter::FilterCase Filter::filter_case() const {
  return Filter::FilterCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EqualFilter

// string value = 1;
inline void EqualFilter::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& EqualFilter::value() const {
  // @@protoc_insertion_point(field_get:onos.topo.EqualFilter.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EqualFilter::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.EqualFilter.value)
}
inline std::string* EqualFilter::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:onos.topo.EqualFilter.value)
  return _s;
}
inline const std::string& EqualFilter::_internal_value() const {
  return value_.Get();
}
inline void EqualFilter::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EqualFilter::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EqualFilter::release_value() {
  // @@protoc_insertion_point(field_release:onos.topo.EqualFilter.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EqualFilter::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.EqualFilter.value)
}

// -------------------------------------------------------------------

// InFilter

// repeated string values = 1;
inline int InFilter::_internal_values_size() const {
  return values_.size();
}
inline int InFilter::values_size() const {
  return _internal_values_size();
}
inline void InFilter::clear_values() {
  values_.Clear();
}
inline std::string* InFilter::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:onos.topo.InFilter.values)
  return _s;
}
inline const std::string& InFilter::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& InFilter::values(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.InFilter.values)
  return _internal_values(index);
}
inline std::string* InFilter::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:onos.topo.InFilter.values)
  return values_.Mutable(index);
}
inline void InFilter::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.topo.InFilter.values)
}
inline void InFilter::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.topo.InFilter.values)
}
inline void InFilter::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.topo.InFilter.values)
}
inline void InFilter::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.topo.InFilter.values)
}
inline std::string* InFilter::_internal_add_values() {
  return values_.Add();
}
inline void InFilter::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.topo.InFilter.values)
}
inline void InFilter::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.topo.InFilter.values)
}
inline void InFilter::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.topo.InFilter.values)
}
inline void InFilter::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.topo.InFilter.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InFilter::values() const {
  // @@protoc_insertion_point(field_list:onos.topo.InFilter.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InFilter::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.InFilter.values)
  return &values_;
}

// -------------------------------------------------------------------

// NotFilter

// .onos.topo.Filter inner = 1;
inline bool NotFilter::_internal_has_inner() const {
  return this != internal_default_instance() && inner_ != nullptr;
}
inline bool NotFilter::has_inner() const {
  return _internal_has_inner();
}
inline void NotFilter::clear_inner() {
  if (GetArenaForAllocation() == nullptr && inner_ != nullptr) {
    delete inner_;
  }
  inner_ = nullptr;
}
inline const ::onos::topo::Filter& NotFilter::_internal_inner() const {
  const ::onos::topo::Filter* p = inner_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Filter&>(
      ::onos::topo::_Filter_default_instance_);
}
inline const ::onos::topo::Filter& NotFilter::inner() const {
  // @@protoc_insertion_point(field_get:onos.topo.NotFilter.inner)
  return _internal_inner();
}
inline void NotFilter::unsafe_arena_set_allocated_inner(
    ::onos::topo::Filter* inner) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inner_);
  }
  inner_ = inner;
  if (inner) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.NotFilter.inner)
}
inline ::onos::topo::Filter* NotFilter::release_inner() {
  
  ::onos::topo::Filter* temp = inner_;
  inner_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Filter* NotFilter::unsafe_arena_release_inner() {
  // @@protoc_insertion_point(field_release:onos.topo.NotFilter.inner)
  
  ::onos::topo::Filter* temp = inner_;
  inner_ = nullptr;
  return temp;
}
inline ::onos::topo::Filter* NotFilter::_internal_mutable_inner() {
  
  if (inner_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Filter>(GetArenaForAllocation());
    inner_ = p;
  }
  return inner_;
}
inline ::onos::topo::Filter* NotFilter::mutable_inner() {
  ::onos::topo::Filter* _msg = _internal_mutable_inner();
  // @@protoc_insertion_point(field_mutable:onos.topo.NotFilter.inner)
  return _msg;
}
inline void NotFilter::set_allocated_inner(::onos::topo::Filter* inner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inner_;
  }
  if (inner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Filter>::GetOwningArena(inner);
    if (message_arena != submessage_arena) {
      inner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inner, submessage_arena);
    }
    
  } else {
    
  }
  inner_ = inner;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.NotFilter.inner)
}

// -------------------------------------------------------------------

// RelationFilter

// string src_id = 1;
inline void RelationFilter::clear_src_id() {
  src_id_.ClearToEmpty();
}
inline const std::string& RelationFilter::src_id() const {
  // @@protoc_insertion_point(field_get:onos.topo.RelationFilter.src_id)
  return _internal_src_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationFilter::set_src_id(ArgT0&& arg0, ArgT... args) {
 
 src_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.RelationFilter.src_id)
}
inline std::string* RelationFilter::mutable_src_id() {
  std::string* _s = _internal_mutable_src_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.RelationFilter.src_id)
  return _s;
}
inline const std::string& RelationFilter::_internal_src_id() const {
  return src_id_.Get();
}
inline void RelationFilter::_internal_set_src_id(const std::string& value) {
  
  src_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RelationFilter::_internal_mutable_src_id() {
  
  return src_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RelationFilter::release_src_id() {
  // @@protoc_insertion_point(field_release:onos.topo.RelationFilter.src_id)
  return src_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RelationFilter::set_allocated_src_id(std::string* src_id) {
  if (src_id != nullptr) {
    
  } else {
    
  }
  src_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (src_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    src_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.RelationFilter.src_id)
}

// string relation_kind = 2;
inline void RelationFilter::clear_relation_kind() {
  relation_kind_.ClearToEmpty();
}
inline const std::string& RelationFilter::relation_kind() const {
  // @@protoc_insertion_point(field_get:onos.topo.RelationFilter.relation_kind)
  return _internal_relation_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationFilter::set_relation_kind(ArgT0&& arg0, ArgT... args) {
 
 relation_kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.RelationFilter.relation_kind)
}
inline std::string* RelationFilter::mutable_relation_kind() {
  std::string* _s = _internal_mutable_relation_kind();
  // @@protoc_insertion_point(field_mutable:onos.topo.RelationFilter.relation_kind)
  return _s;
}
inline const std::string& RelationFilter::_internal_relation_kind() const {
  return relation_kind_.Get();
}
inline void RelationFilter::_internal_set_relation_kind(const std::string& value) {
  
  relation_kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RelationFilter::_internal_mutable_relation_kind() {
  
  return relation_kind_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RelationFilter::release_relation_kind() {
  // @@protoc_insertion_point(field_release:onos.topo.RelationFilter.relation_kind)
  return relation_kind_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RelationFilter::set_allocated_relation_kind(std::string* relation_kind) {
  if (relation_kind != nullptr) {
    
  } else {
    
  }
  relation_kind_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), relation_kind,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (relation_kind_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    relation_kind_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.RelationFilter.relation_kind)
}

// string target_kind = 3;
inline void RelationFilter::clear_target_kind() {
  target_kind_.ClearToEmpty();
}
inline const std::string& RelationFilter::target_kind() const {
  // @@protoc_insertion_point(field_get:onos.topo.RelationFilter.target_kind)
  return _internal_target_kind();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationFilter::set_target_kind(ArgT0&& arg0, ArgT... args) {
 
 target_kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.RelationFilter.target_kind)
}
inline std::string* RelationFilter::mutable_target_kind() {
  std::string* _s = _internal_mutable_target_kind();
  // @@protoc_insertion_point(field_mutable:onos.topo.RelationFilter.target_kind)
  return _s;
}
inline const std::string& RelationFilter::_internal_target_kind() const {
  return target_kind_.Get();
}
inline void RelationFilter::_internal_set_target_kind(const std::string& value) {
  
  target_kind_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RelationFilter::_internal_mutable_target_kind() {
  
  return target_kind_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RelationFilter::release_target_kind() {
  // @@protoc_insertion_point(field_release:onos.topo.RelationFilter.target_kind)
  return target_kind_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RelationFilter::set_allocated_target_kind(std::string* target_kind) {
  if (target_kind != nullptr) {
    
  } else {
    
  }
  target_kind_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_kind,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (target_kind_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    target_kind_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.RelationFilter.target_kind)
}

// .onos.topo.RelationFilterScope scope = 4;
inline void RelationFilter::clear_scope() {
  scope_ = 0;
}
inline ::onos::topo::RelationFilterScope RelationFilter::_internal_scope() const {
  return static_cast< ::onos::topo::RelationFilterScope >(scope_);
}
inline ::onos::topo::RelationFilterScope RelationFilter::scope() const {
  // @@protoc_insertion_point(field_get:onos.topo.RelationFilter.scope)
  return _internal_scope();
}
inline void RelationFilter::_internal_set_scope(::onos::topo::RelationFilterScope value) {
  
  scope_ = value;
}
inline void RelationFilter::set_scope(::onos::topo::RelationFilterScope value) {
  _internal_set_scope(value);
  // @@protoc_insertion_point(field_set:onos.topo.RelationFilter.scope)
}

// string target_id = 5;
inline void RelationFilter::clear_target_id() {
  target_id_.ClearToEmpty();
}
inline const std::string& RelationFilter::target_id() const {
  // @@protoc_insertion_point(field_get:onos.topo.RelationFilter.target_id)
  return _internal_target_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelationFilter::set_target_id(ArgT0&& arg0, ArgT... args) {
 
 target_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.RelationFilter.target_id)
}
inline std::string* RelationFilter::mutable_target_id() {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.RelationFilter.target_id)
  return _s;
}
inline const std::string& RelationFilter::_internal_target_id() const {
  return target_id_.Get();
}
inline void RelationFilter::_internal_set_target_id(const std::string& value) {
  
  target_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RelationFilter::_internal_mutable_target_id() {
  
  return target_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RelationFilter::release_target_id() {
  // @@protoc_insertion_point(field_release:onos.topo.RelationFilter.target_id)
  return target_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RelationFilter::set_allocated_target_id(std::string* target_id) {
  if (target_id != nullptr) {
    
  } else {
    
  }
  target_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (target_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    target_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.RelationFilter.target_id)
}

// -------------------------------------------------------------------

// Filters

// .onos.topo.Filter kind_filter = 1;
inline bool Filters::_internal_has_kind_filter() const {
  return this != internal_default_instance() && kind_filter_ != nullptr;
}
inline bool Filters::has_kind_filter() const {
  return _internal_has_kind_filter();
}
inline void Filters::clear_kind_filter() {
  if (GetArenaForAllocation() == nullptr && kind_filter_ != nullptr) {
    delete kind_filter_;
  }
  kind_filter_ = nullptr;
}
inline const ::onos::topo::Filter& Filters::_internal_kind_filter() const {
  const ::onos::topo::Filter* p = kind_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Filter&>(
      ::onos::topo::_Filter_default_instance_);
}
inline const ::onos::topo::Filter& Filters::kind_filter() const {
  // @@protoc_insertion_point(field_get:onos.topo.Filters.kind_filter)
  return _internal_kind_filter();
}
inline void Filters::unsafe_arena_set_allocated_kind_filter(
    ::onos::topo::Filter* kind_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kind_filter_);
  }
  kind_filter_ = kind_filter;
  if (kind_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Filters.kind_filter)
}
inline ::onos::topo::Filter* Filters::release_kind_filter() {
  
  ::onos::topo::Filter* temp = kind_filter_;
  kind_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Filter* Filters::unsafe_arena_release_kind_filter() {
  // @@protoc_insertion_point(field_release:onos.topo.Filters.kind_filter)
  
  ::onos::topo::Filter* temp = kind_filter_;
  kind_filter_ = nullptr;
  return temp;
}
inline ::onos::topo::Filter* Filters::_internal_mutable_kind_filter() {
  
  if (kind_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Filter>(GetArenaForAllocation());
    kind_filter_ = p;
  }
  return kind_filter_;
}
inline ::onos::topo::Filter* Filters::mutable_kind_filter() {
  ::onos::topo::Filter* _msg = _internal_mutable_kind_filter();
  // @@protoc_insertion_point(field_mutable:onos.topo.Filters.kind_filter)
  return _msg;
}
inline void Filters::set_allocated_kind_filter(::onos::topo::Filter* kind_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kind_filter_;
  }
  if (kind_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Filter>::GetOwningArena(kind_filter);
    if (message_arena != submessage_arena) {
      kind_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kind_filter, submessage_arena);
    }
    
  } else {
    
  }
  kind_filter_ = kind_filter;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Filters.kind_filter)
}

// repeated .onos.topo.Filter label_filters = 2;
inline int Filters::_internal_label_filters_size() const {
  return label_filters_.size();
}
inline int Filters::label_filters_size() const {
  return _internal_label_filters_size();
}
inline void Filters::clear_label_filters() {
  label_filters_.Clear();
}
inline ::onos::topo::Filter* Filters::mutable_label_filters(int index) {
  // @@protoc_insertion_point(field_mutable:onos.topo.Filters.label_filters)
  return label_filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Filter >*
Filters::mutable_label_filters() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.Filters.label_filters)
  return &label_filters_;
}
inline const ::onos::topo::Filter& Filters::_internal_label_filters(int index) const {
  return label_filters_.Get(index);
}
inline const ::onos::topo::Filter& Filters::label_filters(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.Filters.label_filters)
  return _internal_label_filters(index);
}
inline ::onos::topo::Filter* Filters::_internal_add_label_filters() {
  return label_filters_.Add();
}
inline ::onos::topo::Filter* Filters::add_label_filters() {
  ::onos::topo::Filter* _add = _internal_add_label_filters();
  // @@protoc_insertion_point(field_add:onos.topo.Filters.label_filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Filter >&
Filters::label_filters() const {
  // @@protoc_insertion_point(field_list:onos.topo.Filters.label_filters)
  return label_filters_;
}

// .onos.topo.RelationFilter relation_filter = 3;
inline bool Filters::_internal_has_relation_filter() const {
  return this != internal_default_instance() && relation_filter_ != nullptr;
}
inline bool Filters::has_relation_filter() const {
  return _internal_has_relation_filter();
}
inline void Filters::clear_relation_filter() {
  if (GetArenaForAllocation() == nullptr && relation_filter_ != nullptr) {
    delete relation_filter_;
  }
  relation_filter_ = nullptr;
}
inline const ::onos::topo::RelationFilter& Filters::_internal_relation_filter() const {
  const ::onos::topo::RelationFilter* p = relation_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::RelationFilter&>(
      ::onos::topo::_RelationFilter_default_instance_);
}
inline const ::onos::topo::RelationFilter& Filters::relation_filter() const {
  // @@protoc_insertion_point(field_get:onos.topo.Filters.relation_filter)
  return _internal_relation_filter();
}
inline void Filters::unsafe_arena_set_allocated_relation_filter(
    ::onos::topo::RelationFilter* relation_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(relation_filter_);
  }
  relation_filter_ = relation_filter;
  if (relation_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Filters.relation_filter)
}
inline ::onos::topo::RelationFilter* Filters::release_relation_filter() {
  
  ::onos::topo::RelationFilter* temp = relation_filter_;
  relation_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::RelationFilter* Filters::unsafe_arena_release_relation_filter() {
  // @@protoc_insertion_point(field_release:onos.topo.Filters.relation_filter)
  
  ::onos::topo::RelationFilter* temp = relation_filter_;
  relation_filter_ = nullptr;
  return temp;
}
inline ::onos::topo::RelationFilter* Filters::_internal_mutable_relation_filter() {
  
  if (relation_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::RelationFilter>(GetArenaForAllocation());
    relation_filter_ = p;
  }
  return relation_filter_;
}
inline ::onos::topo::RelationFilter* Filters::mutable_relation_filter() {
  ::onos::topo::RelationFilter* _msg = _internal_mutable_relation_filter();
  // @@protoc_insertion_point(field_mutable:onos.topo.Filters.relation_filter)
  return _msg;
}
inline void Filters::set_allocated_relation_filter(::onos::topo::RelationFilter* relation_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete relation_filter_;
  }
  if (relation_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::RelationFilter>::GetOwningArena(relation_filter);
    if (message_arena != submessage_arena) {
      relation_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, relation_filter, submessage_arena);
    }
    
  } else {
    
  }
  relation_filter_ = relation_filter;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Filters.relation_filter)
}

// repeated .onos.topo.Object.Type object_types = 4;
inline int Filters::_internal_object_types_size() const {
  return object_types_.size();
}
inline int Filters::object_types_size() const {
  return _internal_object_types_size();
}
inline void Filters::clear_object_types() {
  object_types_.Clear();
}
inline ::onos::topo::Object_Type Filters::_internal_object_types(int index) const {
  return static_cast< ::onos::topo::Object_Type >(object_types_.Get(index));
}
inline ::onos::topo::Object_Type Filters::object_types(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.Filters.object_types)
  return _internal_object_types(index);
}
inline void Filters::set_object_types(int index, ::onos::topo::Object_Type value) {
  object_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:onos.topo.Filters.object_types)
}
inline void Filters::_internal_add_object_types(::onos::topo::Object_Type value) {
  object_types_.Add(value);
}
inline void Filters::add_object_types(::onos::topo::Object_Type value) {
  _internal_add_object_types(value);
  // @@protoc_insertion_point(field_add:onos.topo.Filters.object_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Filters::object_types() const {
  // @@protoc_insertion_point(field_list:onos.topo.Filters.object_types)
  return object_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Filters::_internal_mutable_object_types() {
  return &object_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Filters::mutable_object_types() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.Filters.object_types)
  return _internal_mutable_object_types();
}

// repeated string with_aspects = 6;
inline int Filters::_internal_with_aspects_size() const {
  return with_aspects_.size();
}
inline int Filters::with_aspects_size() const {
  return _internal_with_aspects_size();
}
inline void Filters::clear_with_aspects() {
  with_aspects_.Clear();
}
inline std::string* Filters::add_with_aspects() {
  std::string* _s = _internal_add_with_aspects();
  // @@protoc_insertion_point(field_add_mutable:onos.topo.Filters.with_aspects)
  return _s;
}
inline const std::string& Filters::_internal_with_aspects(int index) const {
  return with_aspects_.Get(index);
}
inline const std::string& Filters::with_aspects(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.Filters.with_aspects)
  return _internal_with_aspects(index);
}
inline std::string* Filters::mutable_with_aspects(int index) {
  // @@protoc_insertion_point(field_mutable:onos.topo.Filters.with_aspects)
  return with_aspects_.Mutable(index);
}
inline void Filters::set_with_aspects(int index, const std::string& value) {
  with_aspects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.topo.Filters.with_aspects)
}
inline void Filters::set_with_aspects(int index, std::string&& value) {
  with_aspects_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.topo.Filters.with_aspects)
}
inline void Filters::set_with_aspects(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  with_aspects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.topo.Filters.with_aspects)
}
inline void Filters::set_with_aspects(int index, const char* value, size_t size) {
  with_aspects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.topo.Filters.with_aspects)
}
inline std::string* Filters::_internal_add_with_aspects() {
  return with_aspects_.Add();
}
inline void Filters::add_with_aspects(const std::string& value) {
  with_aspects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.topo.Filters.with_aspects)
}
inline void Filters::add_with_aspects(std::string&& value) {
  with_aspects_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.topo.Filters.with_aspects)
}
inline void Filters::add_with_aspects(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  with_aspects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.topo.Filters.with_aspects)
}
inline void Filters::add_with_aspects(const char* value, size_t size) {
  with_aspects_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.topo.Filters.with_aspects)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Filters::with_aspects() const {
  // @@protoc_insertion_point(field_list:onos.topo.Filters.with_aspects)
  return with_aspects_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Filters::mutable_with_aspects() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.Filters.with_aspects)
  return &with_aspects_;
}

// -------------------------------------------------------------------

// ListRequest

// .onos.topo.Filters filters = 1;
inline bool ListRequest::_internal_has_filters() const {
  return this != internal_default_instance() && filters_ != nullptr;
}
inline bool ListRequest::has_filters() const {
  return _internal_has_filters();
}
inline void ListRequest::clear_filters() {
  if (GetArenaForAllocation() == nullptr && filters_ != nullptr) {
    delete filters_;
  }
  filters_ = nullptr;
}
inline const ::onos::topo::Filters& ListRequest::_internal_filters() const {
  const ::onos::topo::Filters* p = filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Filters&>(
      ::onos::topo::_Filters_default_instance_);
}
inline const ::onos::topo::Filters& ListRequest::filters() const {
  // @@protoc_insertion_point(field_get:onos.topo.ListRequest.filters)
  return _internal_filters();
}
inline void ListRequest::unsafe_arena_set_allocated_filters(
    ::onos::topo::Filters* filters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filters_);
  }
  filters_ = filters;
  if (filters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.ListRequest.filters)
}
inline ::onos::topo::Filters* ListRequest::release_filters() {
  
  ::onos::topo::Filters* temp = filters_;
  filters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Filters* ListRequest::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:onos.topo.ListRequest.filters)
  
  ::onos::topo::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::onos::topo::Filters* ListRequest::_internal_mutable_filters() {
  
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Filters>(GetArenaForAllocation());
    filters_ = p;
  }
  return filters_;
}
inline ::onos::topo::Filters* ListRequest::mutable_filters() {
  ::onos::topo::Filters* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:onos.topo.ListRequest.filters)
  return _msg;
}
inline void ListRequest::set_allocated_filters(::onos::topo::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Filters>::GetOwningArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    
  } else {
    
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.ListRequest.filters)
}

// .onos.topo.SortOrder sort_order = 2;
inline void ListRequest::clear_sort_order() {
  sort_order_ = 0;
}
inline ::onos::topo::SortOrder ListRequest::_internal_sort_order() const {
  return static_cast< ::onos::topo::SortOrder >(sort_order_);
}
inline ::onos::topo::SortOrder ListRequest::sort_order() const {
  // @@protoc_insertion_point(field_get:onos.topo.ListRequest.sort_order)
  return _internal_sort_order();
}
inline void ListRequest::_internal_set_sort_order(::onos::topo::SortOrder value) {
  
  sort_order_ = value;
}
inline void ListRequest::set_sort_order(::onos::topo::SortOrder value) {
  _internal_set_sort_order(value);
  // @@protoc_insertion_point(field_set:onos.topo.ListRequest.sort_order)
}

// -------------------------------------------------------------------

// ListResponse

// repeated .onos.topo.Object objects = 1 [(.gogoproto.nullable) = false];
inline int ListResponse::_internal_objects_size() const {
  return objects_.size();
}
inline int ListResponse::objects_size() const {
  return _internal_objects_size();
}
inline void ListResponse::clear_objects() {
  objects_.Clear();
}
inline ::onos::topo::Object* ListResponse::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:onos.topo.ListResponse.objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Object >*
ListResponse::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.ListResponse.objects)
  return &objects_;
}
inline const ::onos::topo::Object& ListResponse::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::onos::topo::Object& ListResponse::objects(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.ListResponse.objects)
  return _internal_objects(index);
}
inline ::onos::topo::Object* ListResponse::_internal_add_objects() {
  return objects_.Add();
}
inline ::onos::topo::Object* ListResponse::add_objects() {
  ::onos::topo::Object* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:onos.topo.ListResponse.objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::topo::Object >&
ListResponse::objects() const {
  // @@protoc_insertion_point(field_list:onos.topo.ListResponse.objects)
  return objects_;
}

// -------------------------------------------------------------------

// WatchRequest

// .onos.topo.Filters filters = 1;
inline bool WatchRequest::_internal_has_filters() const {
  return this != internal_default_instance() && filters_ != nullptr;
}
inline bool WatchRequest::has_filters() const {
  return _internal_has_filters();
}
inline void WatchRequest::clear_filters() {
  if (GetArenaForAllocation() == nullptr && filters_ != nullptr) {
    delete filters_;
  }
  filters_ = nullptr;
}
inline const ::onos::topo::Filters& WatchRequest::_internal_filters() const {
  const ::onos::topo::Filters* p = filters_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Filters&>(
      ::onos::topo::_Filters_default_instance_);
}
inline const ::onos::topo::Filters& WatchRequest::filters() const {
  // @@protoc_insertion_point(field_get:onos.topo.WatchRequest.filters)
  return _internal_filters();
}
inline void WatchRequest::unsafe_arena_set_allocated_filters(
    ::onos::topo::Filters* filters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filters_);
  }
  filters_ = filters;
  if (filters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.WatchRequest.filters)
}
inline ::onos::topo::Filters* WatchRequest::release_filters() {
  
  ::onos::topo::Filters* temp = filters_;
  filters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Filters* WatchRequest::unsafe_arena_release_filters() {
  // @@protoc_insertion_point(field_release:onos.topo.WatchRequest.filters)
  
  ::onos::topo::Filters* temp = filters_;
  filters_ = nullptr;
  return temp;
}
inline ::onos::topo::Filters* WatchRequest::_internal_mutable_filters() {
  
  if (filters_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Filters>(GetArenaForAllocation());
    filters_ = p;
  }
  return filters_;
}
inline ::onos::topo::Filters* WatchRequest::mutable_filters() {
  ::onos::topo::Filters* _msg = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:onos.topo.WatchRequest.filters)
  return _msg;
}
inline void WatchRequest::set_allocated_filters(::onos::topo::Filters* filters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filters_;
  }
  if (filters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Filters>::GetOwningArena(filters);
    if (message_arena != submessage_arena) {
      filters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filters, submessage_arena);
    }
    
  } else {
    
  }
  filters_ = filters;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.WatchRequest.filters)
}

// bool noreplay = 2;
inline void WatchRequest::clear_noreplay() {
  noreplay_ = false;
}
inline bool WatchRequest::_internal_noreplay() const {
  return noreplay_;
}
inline bool WatchRequest::noreplay() const {
  // @@protoc_insertion_point(field_get:onos.topo.WatchRequest.noreplay)
  return _internal_noreplay();
}
inline void WatchRequest::_internal_set_noreplay(bool value) {
  
  noreplay_ = value;
}
inline void WatchRequest::set_noreplay(bool value) {
  _internal_set_noreplay(value);
  // @@protoc_insertion_point(field_set:onos.topo.WatchRequest.noreplay)
}

// -------------------------------------------------------------------

// WatchResponse

// .onos.topo.Event event = 1 [(.gogoproto.nullable) = false];
inline bool WatchResponse::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool WatchResponse::has_event() const {
  return _internal_has_event();
}
inline void WatchResponse::clear_event() {
  if (GetArenaForAllocation() == nullptr && event_ != nullptr) {
    delete event_;
  }
  event_ = nullptr;
}
inline const ::onos::topo::Event& WatchResponse::_internal_event() const {
  const ::onos::topo::Event* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::topo::Event&>(
      ::onos::topo::_Event_default_instance_);
}
inline const ::onos::topo::Event& WatchResponse::event() const {
  // @@protoc_insertion_point(field_get:onos.topo.WatchResponse.event)
  return _internal_event();
}
inline void WatchResponse::unsafe_arena_set_allocated_event(
    ::onos::topo::Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.WatchResponse.event)
}
inline ::onos::topo::Event* WatchResponse::release_event() {
  
  ::onos::topo::Event* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::topo::Event* WatchResponse::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:onos.topo.WatchResponse.event)
  
  ::onos::topo::Event* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::onos::topo::Event* WatchResponse::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::topo::Event>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::onos::topo::Event* WatchResponse::mutable_event() {
  ::onos::topo::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:onos.topo.WatchResponse.event)
  return _msg;
}
inline void WatchResponse::set_allocated_event(::onos::topo::Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::topo::Event>::GetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:onos.topo.WatchResponse.event)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Object

// string uuid = 9 [(.gogoproto.customname) = "UUID", (.gogoproto.casttype) = "UUID"];
inline void Object::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& Object::uuid() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Object.uuid)
}
inline std::string* Object::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:onos.topo.Object.uuid)
  return _s;
}
inline const std::string& Object::_internal_uuid() const {
  return uuid_.Get();
}
inline void Object::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Object::release_uuid() {
  // @@protoc_insertion_point(field_release:onos.topo.Object.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Object::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uuid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Object.uuid)
}

// string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ID"];
inline void Object::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Object::id() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Object::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Object.id)
}
inline std::string* Object::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.Object.id)
  return _s;
}
inline const std::string& Object::_internal_id() const {
  return id_.Get();
}
inline void Object::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Object::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Object::release_id() {
  // @@protoc_insertion_point(field_release:onos.topo.Object.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Object::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Object.id)
}

// uint64 revision = 2 [(.gogoproto.casttype) = "Revision"];
inline void Object::clear_revision() {
  revision_ = uint64_t{0u};
}
inline uint64_t Object::_internal_revision() const {
  return revision_;
}
inline uint64_t Object::revision() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.revision)
  return _internal_revision();
}
inline void Object::_internal_set_revision(uint64_t value) {
  
  revision_ = value;
}
inline void Object::set_revision(uint64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:onos.topo.Object.revision)
}

// .onos.topo.Object.Type type = 3;
inline void Object::clear_type() {
  type_ = 0;
}
inline ::onos::topo::Object_Type Object::_internal_type() const {
  return static_cast< ::onos::topo::Object_Type >(type_);
}
inline ::onos::topo::Object_Type Object::type() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.type)
  return _internal_type();
}
inline void Object::_internal_set_type(::onos::topo::Object_Type value) {
  
  type_ = value;
}
inline void Object::set_type(::onos::topo::Object_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.topo.Object.type)
}

// .onos.topo.Entity entity = 4;
inline bool Object::_internal_has_entity() const {
  return obj_case() == kEntity;
}
inline bool Object::has_entity() const {
  return _internal_has_entity();
}
inline void Object::set_has_entity() {
  _oneof_case_[0] = kEntity;
}
inline void Object::clear_entity() {
  if (_internal_has_entity()) {
    if (GetArenaForAllocation() == nullptr) {
      delete obj_.entity_;
    }
    clear_has_obj();
  }
}
inline ::onos::topo::Entity* Object::release_entity() {
  // @@protoc_insertion_point(field_release:onos.topo.Object.entity)
  if (_internal_has_entity()) {
    clear_has_obj();
      ::onos::topo::Entity* temp = obj_.entity_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obj_.entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::topo::Entity& Object::_internal_entity() const {
  return _internal_has_entity()
      ? *obj_.entity_
      : reinterpret_cast< ::onos::topo::Entity&>(::onos::topo::_Entity_default_instance_);
}
inline const ::onos::topo::Entity& Object::entity() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.entity)
  return _internal_entity();
}
inline ::onos::topo::Entity* Object::unsafe_arena_release_entity() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.topo.Object.entity)
  if (_internal_has_entity()) {
    clear_has_obj();
    ::onos::topo::Entity* temp = obj_.entity_;
    obj_.entity_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_entity(::onos::topo::Entity* entity) {
  clear_obj();
  if (entity) {
    set_has_entity();
    obj_.entity_ = entity;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Object.entity)
}
inline ::onos::topo::Entity* Object::_internal_mutable_entity() {
  if (!_internal_has_entity()) {
    clear_obj();
    set_has_entity();
    obj_.entity_ = CreateMaybeMessage< ::onos::topo::Entity >(GetArenaForAllocation());
  }
  return obj_.entity_;
}
inline ::onos::topo::Entity* Object::mutable_entity() {
  ::onos::topo::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:onos.topo.Object.entity)
  return _msg;
}

// .onos.topo.Relation relation = 5;
inline bool Object::_internal_has_relation() const {
  return obj_case() == kRelation;
}
inline bool Object::has_relation() const {
  return _internal_has_relation();
}
inline void Object::set_has_relation() {
  _oneof_case_[0] = kRelation;
}
inline void Object::clear_relation() {
  if (_internal_has_relation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete obj_.relation_;
    }
    clear_has_obj();
  }
}
inline ::onos::topo::Relation* Object::release_relation() {
  // @@protoc_insertion_point(field_release:onos.topo.Object.relation)
  if (_internal_has_relation()) {
    clear_has_obj();
      ::onos::topo::Relation* temp = obj_.relation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obj_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::topo::Relation& Object::_internal_relation() const {
  return _internal_has_relation()
      ? *obj_.relation_
      : reinterpret_cast< ::onos::topo::Relation&>(::onos::topo::_Relation_default_instance_);
}
inline const ::onos::topo::Relation& Object::relation() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.relation)
  return _internal_relation();
}
inline ::onos::topo::Relation* Object::unsafe_arena_release_relation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.topo.Object.relation)
  if (_internal_has_relation()) {
    clear_has_obj();
    ::onos::topo::Relation* temp = obj_.relation_;
    obj_.relation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_relation(::onos::topo::Relation* relation) {
  clear_obj();
  if (relation) {
    set_has_relation();
    obj_.relation_ = relation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Object.relation)
}
inline ::onos::topo::Relation* Object::_internal_mutable_relation() {
  if (!_internal_has_relation()) {
    clear_obj();
    set_has_relation();
    obj_.relation_ = CreateMaybeMessage< ::onos::topo::Relation >(GetArenaForAllocation());
  }
  return obj_.relation_;
}
inline ::onos::topo::Relation* Object::mutable_relation() {
  ::onos::topo::Relation* _msg = _internal_mutable_relation();
  // @@protoc_insertion_point(field_mutable:onos.topo.Object.relation)
  return _msg;
}

// .onos.topo.Kind kind = 6;
inline bool Object::_internal_has_kind() const {
  return obj_case() == kKind;
}
inline bool Object::has_kind() const {
  return _internal_has_kind();
}
inline void Object::set_has_kind() {
  _oneof_case_[0] = kKind;
}
inline void Object::clear_kind() {
  if (_internal_has_kind()) {
    if (GetArenaForAllocation() == nullptr) {
      delete obj_.kind_;
    }
    clear_has_obj();
  }
}
inline ::onos::topo::Kind* Object::release_kind() {
  // @@protoc_insertion_point(field_release:onos.topo.Object.kind)
  if (_internal_has_kind()) {
    clear_has_obj();
      ::onos::topo::Kind* temp = obj_.kind_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obj_.kind_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::topo::Kind& Object::_internal_kind() const {
  return _internal_has_kind()
      ? *obj_.kind_
      : reinterpret_cast< ::onos::topo::Kind&>(::onos::topo::_Kind_default_instance_);
}
inline const ::onos::topo::Kind& Object::kind() const {
  // @@protoc_insertion_point(field_get:onos.topo.Object.kind)
  return _internal_kind();
}
inline ::onos::topo::Kind* Object::unsafe_arena_release_kind() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.topo.Object.kind)
  if (_internal_has_kind()) {
    clear_has_obj();
    ::onos::topo::Kind* temp = obj_.kind_;
    obj_.kind_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Object::unsafe_arena_set_allocated_kind(::onos::topo::Kind* kind) {
  clear_obj();
  if (kind) {
    set_has_kind();
    obj_.kind_ = kind;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.topo.Object.kind)
}
inline ::onos::topo::Kind* Object::_internal_mutable_kind() {
  if (!_internal_has_kind()) {
    clear_obj();
    set_has_kind();
    obj_.kind_ = CreateMaybeMessage< ::onos::topo::Kind >(GetArenaForAllocation());
  }
  return obj_.kind_;
}
inline ::onos::topo::Kind* Object::mutable_kind() {
  ::onos::topo::Kind* _msg = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:onos.topo.Object.kind)
  return _msg;
}

// map<string, .google.protobuf.Any> aspects = 7;
inline int Object::_internal_aspects_size() const {
  return aspects_.size();
}
inline int Object::aspects_size() const {
  return _internal_aspects_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Object::_internal_aspects() const {
  return aspects_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >&
Object::aspects() const {
  // @@protoc_insertion_point(field_map:onos.topo.Object.aspects)
  return _internal_aspects();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Object::_internal_mutable_aspects() {
  return aspects_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::Any >*
Object::mutable_aspects() {
  // @@protoc_insertion_point(field_mutable_map:onos.topo.Object.aspects)
  return _internal_mutable_aspects();
}

// map<string, string> labels = 8;
inline int Object::_internal_labels_size() const {
  return labels_.size();
}
inline int Object::labels_size() const {
  return _internal_labels_size();
}
inline void Object::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Object::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Object::labels() const {
  // @@protoc_insertion_point(field_map:onos.topo.Object.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Object::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Object::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:onos.topo.Object.labels)
  return _internal_mutable_labels();
}

inline bool Object::has_obj() const {
  return obj_case() != OBJ_NOT_SET;
}
inline void Object::clear_has_obj() {
  _oneof_case_[0] = OBJ_NOT_SET;
}
inline Object::ObjCase Object::obj_case() const {
  return Object::ObjCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Entity

// string kind_id = 1 [(.gogoproto.customname) = "KindID", (.gogoproto.casttype) = "ID"];
inline void Entity::clear_kind_id() {
  kind_id_.ClearToEmpty();
}
inline const std::string& Entity::kind_id() const {
  // @@protoc_insertion_point(field_get:onos.topo.Entity.kind_id)
  return _internal_kind_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Entity::set_kind_id(ArgT0&& arg0, ArgT... args) {
 
 kind_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Entity.kind_id)
}
inline std::string* Entity::mutable_kind_id() {
  std::string* _s = _internal_mutable_kind_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.Entity.kind_id)
  return _s;
}
inline const std::string& Entity::_internal_kind_id() const {
  return kind_id_.Get();
}
inline void Entity::_internal_set_kind_id(const std::string& value) {
  
  kind_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Entity::_internal_mutable_kind_id() {
  
  return kind_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Entity::release_kind_id() {
  // @@protoc_insertion_point(field_release:onos.topo.Entity.kind_id)
  return kind_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Entity::set_allocated_kind_id(std::string* kind_id) {
  if (kind_id != nullptr) {
    
  } else {
    
  }
  kind_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (kind_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    kind_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Entity.kind_id)
}

// repeated string src_relation_ids = 2 [(.gogoproto.customname) = "SrcRelationIDs", (.gogoproto.casttype) = "ID"];
inline int Entity::_internal_src_relation_ids_size() const {
  return src_relation_ids_.size();
}
inline int Entity::src_relation_ids_size() const {
  return _internal_src_relation_ids_size();
}
inline void Entity::clear_src_relation_ids() {
  src_relation_ids_.Clear();
}
inline std::string* Entity::add_src_relation_ids() {
  std::string* _s = _internal_add_src_relation_ids();
  // @@protoc_insertion_point(field_add_mutable:onos.topo.Entity.src_relation_ids)
  return _s;
}
inline const std::string& Entity::_internal_src_relation_ids(int index) const {
  return src_relation_ids_.Get(index);
}
inline const std::string& Entity::src_relation_ids(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.Entity.src_relation_ids)
  return _internal_src_relation_ids(index);
}
inline std::string* Entity::mutable_src_relation_ids(int index) {
  // @@protoc_insertion_point(field_mutable:onos.topo.Entity.src_relation_ids)
  return src_relation_ids_.Mutable(index);
}
inline void Entity::set_src_relation_ids(int index, const std::string& value) {
  src_relation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.topo.Entity.src_relation_ids)
}
inline void Entity::set_src_relation_ids(int index, std::string&& value) {
  src_relation_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.topo.Entity.src_relation_ids)
}
inline void Entity::set_src_relation_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  src_relation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.topo.Entity.src_relation_ids)
}
inline void Entity::set_src_relation_ids(int index, const char* value, size_t size) {
  src_relation_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.topo.Entity.src_relation_ids)
}
inline std::string* Entity::_internal_add_src_relation_ids() {
  return src_relation_ids_.Add();
}
inline void Entity::add_src_relation_ids(const std::string& value) {
  src_relation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.topo.Entity.src_relation_ids)
}
inline void Entity::add_src_relation_ids(std::string&& value) {
  src_relation_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.topo.Entity.src_relation_ids)
}
inline void Entity::add_src_relation_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  src_relation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.topo.Entity.src_relation_ids)
}
inline void Entity::add_src_relation_ids(const char* value, size_t size) {
  src_relation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.topo.Entity.src_relation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Entity::src_relation_ids() const {
  // @@protoc_insertion_point(field_list:onos.topo.Entity.src_relation_ids)
  return src_relation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Entity::mutable_src_relation_ids() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.Entity.src_relation_ids)
  return &src_relation_ids_;
}

// repeated string tgt_relation_ids = 3 [(.gogoproto.customname) = "TgtRelationIDs", (.gogoproto.casttype) = "ID"];
inline int Entity::_internal_tgt_relation_ids_size() const {
  return tgt_relation_ids_.size();
}
inline int Entity::tgt_relation_ids_size() const {
  return _internal_tgt_relation_ids_size();
}
inline void Entity::clear_tgt_relation_ids() {
  tgt_relation_ids_.Clear();
}
inline std::string* Entity::add_tgt_relation_ids() {
  std::string* _s = _internal_add_tgt_relation_ids();
  // @@protoc_insertion_point(field_add_mutable:onos.topo.Entity.tgt_relation_ids)
  return _s;
}
inline const std::string& Entity::_internal_tgt_relation_ids(int index) const {
  return tgt_relation_ids_.Get(index);
}
inline const std::string& Entity::tgt_relation_ids(int index) const {
  // @@protoc_insertion_point(field_get:onos.topo.Entity.tgt_relation_ids)
  return _internal_tgt_relation_ids(index);
}
inline std::string* Entity::mutable_tgt_relation_ids(int index) {
  // @@protoc_insertion_point(field_mutable:onos.topo.Entity.tgt_relation_ids)
  return tgt_relation_ids_.Mutable(index);
}
inline void Entity::set_tgt_relation_ids(int index, const std::string& value) {
  tgt_relation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.topo.Entity.tgt_relation_ids)
}
inline void Entity::set_tgt_relation_ids(int index, std::string&& value) {
  tgt_relation_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.topo.Entity.tgt_relation_ids)
}
inline void Entity::set_tgt_relation_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tgt_relation_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.topo.Entity.tgt_relation_ids)
}
inline void Entity::set_tgt_relation_ids(int index, const char* value, size_t size) {
  tgt_relation_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.topo.Entity.tgt_relation_ids)
}
inline std::string* Entity::_internal_add_tgt_relation_ids() {
  return tgt_relation_ids_.Add();
}
inline void Entity::add_tgt_relation_ids(const std::string& value) {
  tgt_relation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.topo.Entity.tgt_relation_ids)
}
inline void Entity::add_tgt_relation_ids(std::string&& value) {
  tgt_relation_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.topo.Entity.tgt_relation_ids)
}
inline void Entity::add_tgt_relation_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tgt_relation_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.topo.Entity.tgt_relation_ids)
}
inline void Entity::add_tgt_relation_ids(const char* value, size_t size) {
  tgt_relation_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.topo.Entity.tgt_relation_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Entity::tgt_relation_ids() const {
  // @@protoc_insertion_point(field_list:onos.topo.Entity.tgt_relation_ids)
  return tgt_relation_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Entity::mutable_tgt_relation_ids() {
  // @@protoc_insertion_point(field_mutable_list:onos.topo.Entity.tgt_relation_ids)
  return &tgt_relation_ids_;
}

// -------------------------------------------------------------------

// Relation

// string kind_id = 1 [(.gogoproto.customname) = "KindID", (.gogoproto.casttype) = "ID"];
inline void Relation::clear_kind_id() {
  kind_id_.ClearToEmpty();
}
inline const std::string& Relation::kind_id() const {
  // @@protoc_insertion_point(field_get:onos.topo.Relation.kind_id)
  return _internal_kind_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relation::set_kind_id(ArgT0&& arg0, ArgT... args) {
 
 kind_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Relation.kind_id)
}
inline std::string* Relation::mutable_kind_id() {
  std::string* _s = _internal_mutable_kind_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.Relation.kind_id)
  return _s;
}
inline const std::string& Relation::_internal_kind_id() const {
  return kind_id_.Get();
}
inline void Relation::_internal_set_kind_id(const std::string& value) {
  
  kind_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Relation::_internal_mutable_kind_id() {
  
  return kind_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Relation::release_kind_id() {
  // @@protoc_insertion_point(field_release:onos.topo.Relation.kind_id)
  return kind_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Relation::set_allocated_kind_id(std::string* kind_id) {
  if (kind_id != nullptr) {
    
  } else {
    
  }
  kind_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (kind_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    kind_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Relation.kind_id)
}

// string src_entity_id = 2 [(.gogoproto.customname) = "SrcEntityID", (.gogoproto.casttype) = "ID"];
inline void Relation::clear_src_entity_id() {
  src_entity_id_.ClearToEmpty();
}
inline const std::string& Relation::src_entity_id() const {
  // @@protoc_insertion_point(field_get:onos.topo.Relation.src_entity_id)
  return _internal_src_entity_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relation::set_src_entity_id(ArgT0&& arg0, ArgT... args) {
 
 src_entity_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Relation.src_entity_id)
}
inline std::string* Relation::mutable_src_entity_id() {
  std::string* _s = _internal_mutable_src_entity_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.Relation.src_entity_id)
  return _s;
}
inline const std::string& Relation::_internal_src_entity_id() const {
  return src_entity_id_.Get();
}
inline void Relation::_internal_set_src_entity_id(const std::string& value) {
  
  src_entity_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Relation::_internal_mutable_src_entity_id() {
  
  return src_entity_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Relation::release_src_entity_id() {
  // @@protoc_insertion_point(field_release:onos.topo.Relation.src_entity_id)
  return src_entity_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Relation::set_allocated_src_entity_id(std::string* src_entity_id) {
  if (src_entity_id != nullptr) {
    
  } else {
    
  }
  src_entity_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_entity_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (src_entity_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    src_entity_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Relation.src_entity_id)
}

// string tgt_entity_id = 3 [(.gogoproto.customname) = "TgtEntityID", (.gogoproto.casttype) = "ID"];
inline void Relation::clear_tgt_entity_id() {
  tgt_entity_id_.ClearToEmpty();
}
inline const std::string& Relation::tgt_entity_id() const {
  // @@protoc_insertion_point(field_get:onos.topo.Relation.tgt_entity_id)
  return _internal_tgt_entity_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Relation::set_tgt_entity_id(ArgT0&& arg0, ArgT... args) {
 
 tgt_entity_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Relation.tgt_entity_id)
}
inline std::string* Relation::mutable_tgt_entity_id() {
  std::string* _s = _internal_mutable_tgt_entity_id();
  // @@protoc_insertion_point(field_mutable:onos.topo.Relation.tgt_entity_id)
  return _s;
}
inline const std::string& Relation::_internal_tgt_entity_id() const {
  return tgt_entity_id_.Get();
}
inline void Relation::_internal_set_tgt_entity_id(const std::string& value) {
  
  tgt_entity_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Relation::_internal_mutable_tgt_entity_id() {
  
  return tgt_entity_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Relation::release_tgt_entity_id() {
  // @@protoc_insertion_point(field_release:onos.topo.Relation.tgt_entity_id)
  return tgt_entity_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Relation::set_allocated_tgt_entity_id(std::string* tgt_entity_id) {
  if (tgt_entity_id != nullptr) {
    
  } else {
    
  }
  tgt_entity_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tgt_entity_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tgt_entity_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tgt_entity_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Relation.tgt_entity_id)
}

// -------------------------------------------------------------------

// Kind

// string name = 1;
inline void Kind::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Kind::name() const {
  // @@protoc_insertion_point(field_get:onos.topo.Kind.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Kind::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.topo.Kind.name)
}
inline std::string* Kind::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:onos.topo.Kind.name)
  return _s;
}
inline const std::string& Kind::_internal_name() const {
  return name_.Get();
}
inline void Kind::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Kind::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Kind::release_name() {
  // @@protoc_insertion_point(field_release:onos.topo.Kind.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Kind::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.topo.Kind.name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace topo
}  // namespace onos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::onos::topo::Object_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::topo::Object_Type>() {
  return ::onos::topo::Object_Type_descriptor();
}
template <> struct is_proto_enum< ::onos::topo::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::topo::EventType>() {
  return ::onos::topo::EventType_descriptor();
}
template <> struct is_proto_enum< ::onos::topo::RelationFilterScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::topo::RelationFilterScope>() {
  return ::onos::topo::RelationFilterScope_descriptor();
}
template <> struct is_proto_enum< ::onos::topo::SortOrder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::topo::SortOrder>() {
  return ::onos::topo::SortOrder_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onos_2ftopo_2ftopo_2eproto
