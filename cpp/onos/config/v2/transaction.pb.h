// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onos/config/v2/transaction.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_onos_2fconfig_2fv2_2ftransaction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_onos_2fconfig_2fv2_2ftransaction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
#include "onos/config/v2/object.pb.h"
#include "onos/config/v2/value.pb.h"
#include "onos/config/v2/failure.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_onos_2fconfig_2fv2_2ftransaction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_onos_2fconfig_2fv2_2ftransaction_2eproto;
namespace onos {
namespace config {
namespace v2 {
class ChangeTransaction;
struct ChangeTransactionDefaultTypeInternal;
extern ChangeTransactionDefaultTypeInternal _ChangeTransaction_default_instance_;
class ChangeTransaction_ValuesEntry_DoNotUse;
struct ChangeTransaction_ValuesEntry_DoNotUseDefaultTypeInternal;
extern ChangeTransaction_ValuesEntry_DoNotUseDefaultTypeInternal _ChangeTransaction_ValuesEntry_DoNotUse_default_instance_;
class RollbackTransaction;
struct RollbackTransactionDefaultTypeInternal;
extern RollbackTransactionDefaultTypeInternal _RollbackTransaction_default_instance_;
class TargetVersionOverrides;
struct TargetVersionOverridesDefaultTypeInternal;
extern TargetVersionOverridesDefaultTypeInternal _TargetVersionOverrides_default_instance_;
class TargetVersionOverrides_OverridesEntry_DoNotUse;
struct TargetVersionOverrides_OverridesEntry_DoNotUseDefaultTypeInternal;
extern TargetVersionOverrides_OverridesEntry_DoNotUseDefaultTypeInternal _TargetVersionOverrides_OverridesEntry_DoNotUse_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionAbortPhase;
struct TransactionAbortPhaseDefaultTypeInternal;
extern TransactionAbortPhaseDefaultTypeInternal _TransactionAbortPhase_default_instance_;
class TransactionApplyPhase;
struct TransactionApplyPhaseDefaultTypeInternal;
extern TransactionApplyPhaseDefaultTypeInternal _TransactionApplyPhase_default_instance_;
class TransactionCommitPhase;
struct TransactionCommitPhaseDefaultTypeInternal;
extern TransactionCommitPhaseDefaultTypeInternal _TransactionCommitPhase_default_instance_;
class TransactionEvent;
struct TransactionEventDefaultTypeInternal;
extern TransactionEventDefaultTypeInternal _TransactionEvent_default_instance_;
class TransactionInfo;
struct TransactionInfoDefaultTypeInternal;
extern TransactionInfoDefaultTypeInternal _TransactionInfo_default_instance_;
class TransactionInitializePhase;
struct TransactionInitializePhaseDefaultTypeInternal;
extern TransactionInitializePhaseDefaultTypeInternal _TransactionInitializePhase_default_instance_;
class TransactionPhaseStatus;
struct TransactionPhaseStatusDefaultTypeInternal;
extern TransactionPhaseStatusDefaultTypeInternal _TransactionPhaseStatus_default_instance_;
class TransactionPhases;
struct TransactionPhasesDefaultTypeInternal;
extern TransactionPhasesDefaultTypeInternal _TransactionPhases_default_instance_;
class TransactionStatus;
struct TransactionStatusDefaultTypeInternal;
extern TransactionStatusDefaultTypeInternal _TransactionStatus_default_instance_;
class TransactionStrategy;
struct TransactionStrategyDefaultTypeInternal;
extern TransactionStrategyDefaultTypeInternal _TransactionStrategy_default_instance_;
class TransactionValidatePhase;
struct TransactionValidatePhaseDefaultTypeInternal;
extern TransactionValidatePhaseDefaultTypeInternal _TransactionValidatePhase_default_instance_;
}  // namespace v2
}  // namespace config
}  // namespace onos
PROTOBUF_NAMESPACE_OPEN
template<> ::onos::config::v2::ChangeTransaction* Arena::CreateMaybeMessage<::onos::config::v2::ChangeTransaction>(Arena*);
template<> ::onos::config::v2::ChangeTransaction_ValuesEntry_DoNotUse* Arena::CreateMaybeMessage<::onos::config::v2::ChangeTransaction_ValuesEntry_DoNotUse>(Arena*);
template<> ::onos::config::v2::RollbackTransaction* Arena::CreateMaybeMessage<::onos::config::v2::RollbackTransaction>(Arena*);
template<> ::onos::config::v2::TargetVersionOverrides* Arena::CreateMaybeMessage<::onos::config::v2::TargetVersionOverrides>(Arena*);
template<> ::onos::config::v2::TargetVersionOverrides_OverridesEntry_DoNotUse* Arena::CreateMaybeMessage<::onos::config::v2::TargetVersionOverrides_OverridesEntry_DoNotUse>(Arena*);
template<> ::onos::config::v2::Transaction* Arena::CreateMaybeMessage<::onos::config::v2::Transaction>(Arena*);
template<> ::onos::config::v2::TransactionAbortPhase* Arena::CreateMaybeMessage<::onos::config::v2::TransactionAbortPhase>(Arena*);
template<> ::onos::config::v2::TransactionApplyPhase* Arena::CreateMaybeMessage<::onos::config::v2::TransactionApplyPhase>(Arena*);
template<> ::onos::config::v2::TransactionCommitPhase* Arena::CreateMaybeMessage<::onos::config::v2::TransactionCommitPhase>(Arena*);
template<> ::onos::config::v2::TransactionEvent* Arena::CreateMaybeMessage<::onos::config::v2::TransactionEvent>(Arena*);
template<> ::onos::config::v2::TransactionInfo* Arena::CreateMaybeMessage<::onos::config::v2::TransactionInfo>(Arena*);
template<> ::onos::config::v2::TransactionInitializePhase* Arena::CreateMaybeMessage<::onos::config::v2::TransactionInitializePhase>(Arena*);
template<> ::onos::config::v2::TransactionPhaseStatus* Arena::CreateMaybeMessage<::onos::config::v2::TransactionPhaseStatus>(Arena*);
template<> ::onos::config::v2::TransactionPhases* Arena::CreateMaybeMessage<::onos::config::v2::TransactionPhases>(Arena*);
template<> ::onos::config::v2::TransactionStatus* Arena::CreateMaybeMessage<::onos::config::v2::TransactionStatus>(Arena*);
template<> ::onos::config::v2::TransactionStrategy* Arena::CreateMaybeMessage<::onos::config::v2::TransactionStrategy>(Arena*);
template<> ::onos::config::v2::TransactionValidatePhase* Arena::CreateMaybeMessage<::onos::config::v2::TransactionValidatePhase>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace onos {
namespace config {
namespace v2 {

enum TransactionStrategy_Synchronicity : int {
  TransactionStrategy_Synchronicity_ASYNCHRONOUS = 0,
  TransactionStrategy_Synchronicity_SYNCHRONOUS = 1,
  TransactionStrategy_Synchronicity_TransactionStrategy_Synchronicity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionStrategy_Synchronicity_TransactionStrategy_Synchronicity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionStrategy_Synchronicity_IsValid(int value);
constexpr TransactionStrategy_Synchronicity TransactionStrategy_Synchronicity_Synchronicity_MIN = TransactionStrategy_Synchronicity_ASYNCHRONOUS;
constexpr TransactionStrategy_Synchronicity TransactionStrategy_Synchronicity_Synchronicity_MAX = TransactionStrategy_Synchronicity_SYNCHRONOUS;
constexpr int TransactionStrategy_Synchronicity_Synchronicity_ARRAYSIZE = TransactionStrategy_Synchronicity_Synchronicity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStrategy_Synchronicity_descriptor();
template<typename T>
inline const std::string& TransactionStrategy_Synchronicity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionStrategy_Synchronicity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionStrategy_Synchronicity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionStrategy_Synchronicity_descriptor(), enum_t_value);
}
inline bool TransactionStrategy_Synchronicity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionStrategy_Synchronicity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionStrategy_Synchronicity>(
    TransactionStrategy_Synchronicity_descriptor(), name, value);
}
enum TransactionStrategy_Isolation : int {
  TransactionStrategy_Isolation_DEFAULT = 0,
  TransactionStrategy_Isolation_SERIALIZABLE = 1,
  TransactionStrategy_Isolation_TransactionStrategy_Isolation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionStrategy_Isolation_TransactionStrategy_Isolation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionStrategy_Isolation_IsValid(int value);
constexpr TransactionStrategy_Isolation TransactionStrategy_Isolation_Isolation_MIN = TransactionStrategy_Isolation_DEFAULT;
constexpr TransactionStrategy_Isolation TransactionStrategy_Isolation_Isolation_MAX = TransactionStrategy_Isolation_SERIALIZABLE;
constexpr int TransactionStrategy_Isolation_Isolation_ARRAYSIZE = TransactionStrategy_Isolation_Isolation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStrategy_Isolation_descriptor();
template<typename T>
inline const std::string& TransactionStrategy_Isolation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionStrategy_Isolation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionStrategy_Isolation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionStrategy_Isolation_descriptor(), enum_t_value);
}
inline bool TransactionStrategy_Isolation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionStrategy_Isolation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionStrategy_Isolation>(
    TransactionStrategy_Isolation_descriptor(), name, value);
}
enum TransactionStatus_State : int {
  TransactionStatus_State_PENDING = 0,
  TransactionStatus_State_VALIDATED = 1,
  TransactionStatus_State_COMMITTED = 2,
  TransactionStatus_State_APPLIED = 3,
  TransactionStatus_State_FAILED = 4,
  TransactionStatus_State_TransactionStatus_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionStatus_State_TransactionStatus_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionStatus_State_IsValid(int value);
constexpr TransactionStatus_State TransactionStatus_State_State_MIN = TransactionStatus_State_PENDING;
constexpr TransactionStatus_State TransactionStatus_State_State_MAX = TransactionStatus_State_FAILED;
constexpr int TransactionStatus_State_State_ARRAYSIZE = TransactionStatus_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_State_descriptor();
template<typename T>
inline const std::string& TransactionStatus_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionStatus_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionStatus_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionStatus_State_descriptor(), enum_t_value);
}
inline bool TransactionStatus_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionStatus_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionStatus_State>(
    TransactionStatus_State_descriptor(), name, value);
}
enum TransactionInitializePhase_State : int {
  TransactionInitializePhase_State_INITIALIZING = 0,
  TransactionInitializePhase_State_INITIALIZED = 1,
  TransactionInitializePhase_State_FAILED = 2,
  TransactionInitializePhase_State_TransactionInitializePhase_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionInitializePhase_State_TransactionInitializePhase_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionInitializePhase_State_IsValid(int value);
constexpr TransactionInitializePhase_State TransactionInitializePhase_State_State_MIN = TransactionInitializePhase_State_INITIALIZING;
constexpr TransactionInitializePhase_State TransactionInitializePhase_State_State_MAX = TransactionInitializePhase_State_FAILED;
constexpr int TransactionInitializePhase_State_State_ARRAYSIZE = TransactionInitializePhase_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionInitializePhase_State_descriptor();
template<typename T>
inline const std::string& TransactionInitializePhase_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionInitializePhase_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionInitializePhase_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionInitializePhase_State_descriptor(), enum_t_value);
}
inline bool TransactionInitializePhase_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionInitializePhase_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionInitializePhase_State>(
    TransactionInitializePhase_State_descriptor(), name, value);
}
enum TransactionValidatePhase_State : int {
  TransactionValidatePhase_State_VALIDATING = 0,
  TransactionValidatePhase_State_VALIDATED = 1,
  TransactionValidatePhase_State_FAILED = 2,
  TransactionValidatePhase_State_TransactionValidatePhase_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionValidatePhase_State_TransactionValidatePhase_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionValidatePhase_State_IsValid(int value);
constexpr TransactionValidatePhase_State TransactionValidatePhase_State_State_MIN = TransactionValidatePhase_State_VALIDATING;
constexpr TransactionValidatePhase_State TransactionValidatePhase_State_State_MAX = TransactionValidatePhase_State_FAILED;
constexpr int TransactionValidatePhase_State_State_ARRAYSIZE = TransactionValidatePhase_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionValidatePhase_State_descriptor();
template<typename T>
inline const std::string& TransactionValidatePhase_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionValidatePhase_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionValidatePhase_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionValidatePhase_State_descriptor(), enum_t_value);
}
inline bool TransactionValidatePhase_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionValidatePhase_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionValidatePhase_State>(
    TransactionValidatePhase_State_descriptor(), name, value);
}
enum TransactionCommitPhase_State : int {
  TransactionCommitPhase_State_COMMITTING = 0,
  TransactionCommitPhase_State_COMMITTED = 1,
  TransactionCommitPhase_State_TransactionCommitPhase_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionCommitPhase_State_TransactionCommitPhase_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionCommitPhase_State_IsValid(int value);
constexpr TransactionCommitPhase_State TransactionCommitPhase_State_State_MIN = TransactionCommitPhase_State_COMMITTING;
constexpr TransactionCommitPhase_State TransactionCommitPhase_State_State_MAX = TransactionCommitPhase_State_COMMITTED;
constexpr int TransactionCommitPhase_State_State_ARRAYSIZE = TransactionCommitPhase_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionCommitPhase_State_descriptor();
template<typename T>
inline const std::string& TransactionCommitPhase_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionCommitPhase_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionCommitPhase_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionCommitPhase_State_descriptor(), enum_t_value);
}
inline bool TransactionCommitPhase_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionCommitPhase_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionCommitPhase_State>(
    TransactionCommitPhase_State_descriptor(), name, value);
}
enum TransactionApplyPhase_State : int {
  TransactionApplyPhase_State_APPLYING = 0,
  TransactionApplyPhase_State_APPLIED = 1,
  TransactionApplyPhase_State_FAILED = 2,
  TransactionApplyPhase_State_TransactionApplyPhase_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionApplyPhase_State_TransactionApplyPhase_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionApplyPhase_State_IsValid(int value);
constexpr TransactionApplyPhase_State TransactionApplyPhase_State_State_MIN = TransactionApplyPhase_State_APPLYING;
constexpr TransactionApplyPhase_State TransactionApplyPhase_State_State_MAX = TransactionApplyPhase_State_FAILED;
constexpr int TransactionApplyPhase_State_State_ARRAYSIZE = TransactionApplyPhase_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionApplyPhase_State_descriptor();
template<typename T>
inline const std::string& TransactionApplyPhase_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionApplyPhase_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionApplyPhase_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionApplyPhase_State_descriptor(), enum_t_value);
}
inline bool TransactionApplyPhase_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionApplyPhase_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionApplyPhase_State>(
    TransactionApplyPhase_State_descriptor(), name, value);
}
enum TransactionAbortPhase_State : int {
  TransactionAbortPhase_State_ABORTING = 0,
  TransactionAbortPhase_State_ABORTED = 1,
  TransactionAbortPhase_State_TransactionAbortPhase_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionAbortPhase_State_TransactionAbortPhase_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionAbortPhase_State_IsValid(int value);
constexpr TransactionAbortPhase_State TransactionAbortPhase_State_State_MIN = TransactionAbortPhase_State_ABORTING;
constexpr TransactionAbortPhase_State TransactionAbortPhase_State_State_MAX = TransactionAbortPhase_State_ABORTED;
constexpr int TransactionAbortPhase_State_State_ARRAYSIZE = TransactionAbortPhase_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionAbortPhase_State_descriptor();
template<typename T>
inline const std::string& TransactionAbortPhase_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionAbortPhase_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionAbortPhase_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionAbortPhase_State_descriptor(), enum_t_value);
}
inline bool TransactionAbortPhase_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionAbortPhase_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionAbortPhase_State>(
    TransactionAbortPhase_State_descriptor(), name, value);
}
enum TransactionEvent_EventType : int {
  TransactionEvent_EventType_UNKNOWN = 0,
  TransactionEvent_EventType_CREATED = 1,
  TransactionEvent_EventType_UPDATED = 2,
  TransactionEvent_EventType_DELETED = 3,
  TransactionEvent_EventType_REPLAYED = 4,
  TransactionEvent_EventType_TransactionEvent_EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransactionEvent_EventType_TransactionEvent_EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransactionEvent_EventType_IsValid(int value);
constexpr TransactionEvent_EventType TransactionEvent_EventType_EventType_MIN = TransactionEvent_EventType_UNKNOWN;
constexpr TransactionEvent_EventType TransactionEvent_EventType_EventType_MAX = TransactionEvent_EventType_REPLAYED;
constexpr int TransactionEvent_EventType_EventType_ARRAYSIZE = TransactionEvent_EventType_EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionEvent_EventType_descriptor();
template<typename T>
inline const std::string& TransactionEvent_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionEvent_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionEvent_EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionEvent_EventType_descriptor(), enum_t_value);
}
inline bool TransactionEvent_EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionEvent_EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionEvent_EventType>(
    TransactionEvent_EventType_descriptor(), name, value);
}
// ===================================================================

class TransactionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionInfo) */ {
 public:
  inline TransactionInfo() : TransactionInfo(nullptr) {}
  ~TransactionInfo() override;
  explicit constexpr TransactionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionInfo(const TransactionInfo& from);
  TransactionInfo(TransactionInfo&& from) noexcept
    : TransactionInfo() {
    *this = ::std::move(from);
  }

  inline TransactionInfo& operator=(const TransactionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionInfo& operator=(TransactionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionInfo* internal_default_instance() {
    return reinterpret_cast<const TransactionInfo*>(
               &_TransactionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TransactionInfo& a, TransactionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionInfo";
  }
  protected:
  explicit TransactionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "TransactionID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 index = 2 [(.gogoproto.casttype) = "Index"];
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  uint64_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit constexpr Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  enum DetailsCase {
    kChange = 6,
    kRollback = 7,
    DETAILS_NOT_SET = 0,
  };

  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kUsernameFieldNumber = 4,
    kMetaFieldNumber = 1,
    kStrategyFieldNumber = 5,
    kStatusFieldNumber = 8,
    kVersionOverridesFieldNumber = 9,
    kIndexFieldNumber = 3,
    kChangeFieldNumber = 6,
    kRollbackFieldNumber = 7,
  };
  // string id = 2 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "TransactionID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // .onos.config.v2.ObjectMeta meta = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::onos::config::v2::ObjectMeta& meta() const;
  PROTOBUF_NODISCARD ::onos::config::v2::ObjectMeta* release_meta();
  ::onos::config::v2::ObjectMeta* mutable_meta();
  void set_allocated_meta(::onos::config::v2::ObjectMeta* meta);
  private:
  const ::onos::config::v2::ObjectMeta& _internal_meta() const;
  ::onos::config::v2::ObjectMeta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::onos::config::v2::ObjectMeta* meta);
  ::onos::config::v2::ObjectMeta* unsafe_arena_release_meta();

  // .onos.config.v2.TransactionStrategy strategy = 5 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_strategy() const;
  private:
  bool _internal_has_strategy() const;
  public:
  void clear_strategy();
  const ::onos::config::v2::TransactionStrategy& strategy() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionStrategy* release_strategy();
  ::onos::config::v2::TransactionStrategy* mutable_strategy();
  void set_allocated_strategy(::onos::config::v2::TransactionStrategy* strategy);
  private:
  const ::onos::config::v2::TransactionStrategy& _internal_strategy() const;
  ::onos::config::v2::TransactionStrategy* _internal_mutable_strategy();
  public:
  void unsafe_arena_set_allocated_strategy(
      ::onos::config::v2::TransactionStrategy* strategy);
  ::onos::config::v2::TransactionStrategy* unsafe_arena_release_strategy();

  // .onos.config.v2.TransactionStatus status = 8 [(.gogoproto.nullable) = false];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::config::v2::TransactionStatus& status() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionStatus* release_status();
  ::onos::config::v2::TransactionStatus* mutable_status();
  void set_allocated_status(::onos::config::v2::TransactionStatus* status);
  private:
  const ::onos::config::v2::TransactionStatus& _internal_status() const;
  ::onos::config::v2::TransactionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::config::v2::TransactionStatus* status);
  ::onos::config::v2::TransactionStatus* unsafe_arena_release_status();

  // .onos.config.v2.TargetVersionOverrides version_overrides = 9 [(.gogoproto.embed) = true];
  bool has_version_overrides() const;
  private:
  bool _internal_has_version_overrides() const;
  public:
  void clear_version_overrides();
  const ::onos::config::v2::TargetVersionOverrides& version_overrides() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TargetVersionOverrides* release_version_overrides();
  ::onos::config::v2::TargetVersionOverrides* mutable_version_overrides();
  void set_allocated_version_overrides(::onos::config::v2::TargetVersionOverrides* version_overrides);
  private:
  const ::onos::config::v2::TargetVersionOverrides& _internal_version_overrides() const;
  ::onos::config::v2::TargetVersionOverrides* _internal_mutable_version_overrides();
  public:
  void unsafe_arena_set_allocated_version_overrides(
      ::onos::config::v2::TargetVersionOverrides* version_overrides);
  ::onos::config::v2::TargetVersionOverrides* unsafe_arena_release_version_overrides();

  // uint64 index = 3 [(.gogoproto.casttype) = "Index"];
  void clear_index();
  uint64_t index() const;
  void set_index(uint64_t value);
  private:
  uint64_t _internal_index() const;
  void _internal_set_index(uint64_t value);
  public:

  // .onos.config.v2.ChangeTransaction change = 6;
  bool has_change() const;
  private:
  bool _internal_has_change() const;
  public:
  void clear_change();
  const ::onos::config::v2::ChangeTransaction& change() const;
  PROTOBUF_NODISCARD ::onos::config::v2::ChangeTransaction* release_change();
  ::onos::config::v2::ChangeTransaction* mutable_change();
  void set_allocated_change(::onos::config::v2::ChangeTransaction* change);
  private:
  const ::onos::config::v2::ChangeTransaction& _internal_change() const;
  ::onos::config::v2::ChangeTransaction* _internal_mutable_change();
  public:
  void unsafe_arena_set_allocated_change(
      ::onos::config::v2::ChangeTransaction* change);
  ::onos::config::v2::ChangeTransaction* unsafe_arena_release_change();

  // .onos.config.v2.RollbackTransaction rollback = 7;
  bool has_rollback() const;
  private:
  bool _internal_has_rollback() const;
  public:
  void clear_rollback();
  const ::onos::config::v2::RollbackTransaction& rollback() const;
  PROTOBUF_NODISCARD ::onos::config::v2::RollbackTransaction* release_rollback();
  ::onos::config::v2::RollbackTransaction* mutable_rollback();
  void set_allocated_rollback(::onos::config::v2::RollbackTransaction* rollback);
  private:
  const ::onos::config::v2::RollbackTransaction& _internal_rollback() const;
  ::onos::config::v2::RollbackTransaction* _internal_mutable_rollback();
  public:
  void unsafe_arena_set_allocated_rollback(
      ::onos::config::v2::RollbackTransaction* rollback);
  ::onos::config::v2::RollbackTransaction* unsafe_arena_release_rollback();

  void clear_details();
  DetailsCase details_case() const;
  // @@protoc_insertion_point(class_scope:onos.config.v2.Transaction)
 private:
  class _Internal;
  void set_has_change();
  void set_has_rollback();

  inline bool has_details() const;
  inline void clear_has_details();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::onos::config::v2::ObjectMeta* meta_;
  ::onos::config::v2::TransactionStrategy* strategy_;
  ::onos::config::v2::TransactionStatus* status_;
  ::onos::config::v2::TargetVersionOverrides* version_overrides_;
  uint64_t index_;
  union DetailsUnion {
    constexpr DetailsUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::onos::config::v2::ChangeTransaction* change_;
    ::onos::config::v2::RollbackTransaction* rollback_;
  } details_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionStrategy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionStrategy) */ {
 public:
  inline TransactionStrategy() : TransactionStrategy(nullptr) {}
  ~TransactionStrategy() override;
  explicit constexpr TransactionStrategy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionStrategy(const TransactionStrategy& from);
  TransactionStrategy(TransactionStrategy&& from) noexcept
    : TransactionStrategy() {
    *this = ::std::move(from);
  }

  inline TransactionStrategy& operator=(const TransactionStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionStrategy& operator=(TransactionStrategy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionStrategy& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionStrategy* internal_default_instance() {
    return reinterpret_cast<const TransactionStrategy*>(
               &_TransactionStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TransactionStrategy& a, TransactionStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionStrategy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionStrategy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionStrategy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionStrategy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionStrategy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionStrategy";
  }
  protected:
  explicit TransactionStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionStrategy_Synchronicity Synchronicity;
  static constexpr Synchronicity ASYNCHRONOUS =
    TransactionStrategy_Synchronicity_ASYNCHRONOUS;
  static constexpr Synchronicity SYNCHRONOUS =
    TransactionStrategy_Synchronicity_SYNCHRONOUS;
  static inline bool Synchronicity_IsValid(int value) {
    return TransactionStrategy_Synchronicity_IsValid(value);
  }
  static constexpr Synchronicity Synchronicity_MIN =
    TransactionStrategy_Synchronicity_Synchronicity_MIN;
  static constexpr Synchronicity Synchronicity_MAX =
    TransactionStrategy_Synchronicity_Synchronicity_MAX;
  static constexpr int Synchronicity_ARRAYSIZE =
    TransactionStrategy_Synchronicity_Synchronicity_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Synchronicity_descriptor() {
    return TransactionStrategy_Synchronicity_descriptor();
  }
  template<typename T>
  static inline const std::string& Synchronicity_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Synchronicity>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Synchronicity_Name.");
    return TransactionStrategy_Synchronicity_Name(enum_t_value);
  }
  static inline bool Synchronicity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Synchronicity* value) {
    return TransactionStrategy_Synchronicity_Parse(name, value);
  }

  typedef TransactionStrategy_Isolation Isolation;
  static constexpr Isolation DEFAULT =
    TransactionStrategy_Isolation_DEFAULT;
  static constexpr Isolation SERIALIZABLE =
    TransactionStrategy_Isolation_SERIALIZABLE;
  static inline bool Isolation_IsValid(int value) {
    return TransactionStrategy_Isolation_IsValid(value);
  }
  static constexpr Isolation Isolation_MIN =
    TransactionStrategy_Isolation_Isolation_MIN;
  static constexpr Isolation Isolation_MAX =
    TransactionStrategy_Isolation_Isolation_MAX;
  static constexpr int Isolation_ARRAYSIZE =
    TransactionStrategy_Isolation_Isolation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Isolation_descriptor() {
    return TransactionStrategy_Isolation_descriptor();
  }
  template<typename T>
  static inline const std::string& Isolation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Isolation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Isolation_Name.");
    return TransactionStrategy_Isolation_Name(enum_t_value);
  }
  static inline bool Isolation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Isolation* value) {
    return TransactionStrategy_Isolation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSynchronicityFieldNumber = 1,
    kIsolationFieldNumber = 2,
  };
  // .onos.config.v2.TransactionStrategy.Synchronicity synchronicity = 1;
  void clear_synchronicity();
  ::onos::config::v2::TransactionStrategy_Synchronicity synchronicity() const;
  void set_synchronicity(::onos::config::v2::TransactionStrategy_Synchronicity value);
  private:
  ::onos::config::v2::TransactionStrategy_Synchronicity _internal_synchronicity() const;
  void _internal_set_synchronicity(::onos::config::v2::TransactionStrategy_Synchronicity value);
  public:

  // .onos.config.v2.TransactionStrategy.Isolation isolation = 2;
  void clear_isolation();
  ::onos::config::v2::TransactionStrategy_Isolation isolation() const;
  void set_isolation(::onos::config::v2::TransactionStrategy_Isolation value);
  private:
  ::onos::config::v2::TransactionStrategy_Isolation _internal_isolation() const;
  void _internal_set_isolation(::onos::config::v2::TransactionStrategy_Isolation value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int synchronicity_;
  int isolation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class ChangeTransaction_ValuesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ChangeTransaction_ValuesEntry_DoNotUse, 
    std::string, ::onos::config::v2::PathValues,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ChangeTransaction_ValuesEntry_DoNotUse, 
    std::string, ::onos::config::v2::PathValues,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  ChangeTransaction_ValuesEntry_DoNotUse();
  explicit constexpr ChangeTransaction_ValuesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ChangeTransaction_ValuesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ChangeTransaction_ValuesEntry_DoNotUse& other);
  static const ChangeTransaction_ValuesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ChangeTransaction_ValuesEntry_DoNotUse*>(&_ChangeTransaction_ValuesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "onos.config.v2.ChangeTransaction.ValuesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ChangeTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.ChangeTransaction) */ {
 public:
  inline ChangeTransaction() : ChangeTransaction(nullptr) {}
  ~ChangeTransaction() override;
  explicit constexpr ChangeTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeTransaction(const ChangeTransaction& from);
  ChangeTransaction(ChangeTransaction&& from) noexcept
    : ChangeTransaction() {
    *this = ::std::move(from);
  }

  inline ChangeTransaction& operator=(const ChangeTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeTransaction& operator=(ChangeTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeTransaction* internal_default_instance() {
    return reinterpret_cast<const ChangeTransaction*>(
               &_ChangeTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChangeTransaction& a, ChangeTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeTransaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.ChangeTransaction";
  }
  protected:
  explicit ChangeTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // map<string, .onos.config.v2.PathValues> values = 1 [(.gogoproto.castkey) = "TargetID"];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >&
      _internal_values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >*
      _internal_mutable_values();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:onos.config.v2.ChangeTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ChangeTransaction_ValuesEntry_DoNotUse,
      std::string, ::onos::config::v2::PathValues,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class RollbackTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.RollbackTransaction) */ {
 public:
  inline RollbackTransaction() : RollbackTransaction(nullptr) {}
  ~RollbackTransaction() override;
  explicit constexpr RollbackTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RollbackTransaction(const RollbackTransaction& from);
  RollbackTransaction(RollbackTransaction&& from) noexcept
    : RollbackTransaction() {
    *this = ::std::move(from);
  }

  inline RollbackTransaction& operator=(const RollbackTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollbackTransaction& operator=(RollbackTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollbackTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const RollbackTransaction* internal_default_instance() {
    return reinterpret_cast<const RollbackTransaction*>(
               &_RollbackTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RollbackTransaction& a, RollbackTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(RollbackTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollbackTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollbackTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RollbackTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RollbackTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RollbackTransaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RollbackTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.RollbackTransaction";
  }
  protected:
  explicit RollbackTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollbackIndexFieldNumber = 1,
  };
  // uint64 rollback_index = 1 [(.gogoproto.casttype) = "Index"];
  void clear_rollback_index();
  uint64_t rollback_index() const;
  void set_rollback_index(uint64_t value);
  private:
  uint64_t _internal_rollback_index() const;
  void _internal_set_rollback_index(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.RollbackTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t rollback_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionStatus) */ {
 public:
  inline TransactionStatus() : TransactionStatus(nullptr) {}
  ~TransactionStatus() override;
  explicit constexpr TransactionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionStatus(const TransactionStatus& from);
  TransactionStatus(TransactionStatus&& from) noexcept
    : TransactionStatus() {
    *this = ::std::move(from);
  }

  inline TransactionStatus& operator=(const TransactionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionStatus& operator=(TransactionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionStatus* internal_default_instance() {
    return reinterpret_cast<const TransactionStatus*>(
               &_TransactionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TransactionStatus& a, TransactionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionStatus";
  }
  protected:
  explicit TransactionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionStatus_State State;
  static constexpr State PENDING =
    TransactionStatus_State_PENDING;
  static constexpr State VALIDATED =
    TransactionStatus_State_VALIDATED;
  static constexpr State COMMITTED =
    TransactionStatus_State_COMMITTED;
  static constexpr State APPLIED =
    TransactionStatus_State_APPLIED;
  static constexpr State FAILED =
    TransactionStatus_State_FAILED;
  static inline bool State_IsValid(int value) {
    return TransactionStatus_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TransactionStatus_State_State_MIN;
  static constexpr State State_MAX =
    TransactionStatus_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TransactionStatus_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TransactionStatus_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TransactionStatus_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TransactionStatus_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kProposalsFieldNumber = 2,
    kPhasesFieldNumber = 1,
    kFailureFieldNumber = 4,
    kStateFieldNumber = 3,
  };
  // repeated string proposals = 2 [(.gogoproto.casttype) = "ProposalID"];
  int proposals_size() const;
  private:
  int _internal_proposals_size() const;
  public:
  void clear_proposals();
  const std::string& proposals(int index) const;
  std::string* mutable_proposals(int index);
  void set_proposals(int index, const std::string& value);
  void set_proposals(int index, std::string&& value);
  void set_proposals(int index, const char* value);
  void set_proposals(int index, const char* value, size_t size);
  std::string* add_proposals();
  void add_proposals(const std::string& value);
  void add_proposals(std::string&& value);
  void add_proposals(const char* value);
  void add_proposals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& proposals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_proposals();
  private:
  const std::string& _internal_proposals(int index) const;
  std::string* _internal_add_proposals();
  public:

  // .onos.config.v2.TransactionPhases phases = 1 [(.gogoproto.nullable) = false];
  bool has_phases() const;
  private:
  bool _internal_has_phases() const;
  public:
  void clear_phases();
  const ::onos::config::v2::TransactionPhases& phases() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionPhases* release_phases();
  ::onos::config::v2::TransactionPhases* mutable_phases();
  void set_allocated_phases(::onos::config::v2::TransactionPhases* phases);
  private:
  const ::onos::config::v2::TransactionPhases& _internal_phases() const;
  ::onos::config::v2::TransactionPhases* _internal_mutable_phases();
  public:
  void unsafe_arena_set_allocated_phases(
      ::onos::config::v2::TransactionPhases* phases);
  ::onos::config::v2::TransactionPhases* unsafe_arena_release_phases();

  // .onos.config.v2.Failure failure = 4;
  bool has_failure() const;
  private:
  bool _internal_has_failure() const;
  public:
  void clear_failure();
  const ::onos::config::v2::Failure& failure() const;
  PROTOBUF_NODISCARD ::onos::config::v2::Failure* release_failure();
  ::onos::config::v2::Failure* mutable_failure();
  void set_allocated_failure(::onos::config::v2::Failure* failure);
  private:
  const ::onos::config::v2::Failure& _internal_failure() const;
  ::onos::config::v2::Failure* _internal_mutable_failure();
  public:
  void unsafe_arena_set_allocated_failure(
      ::onos::config::v2::Failure* failure);
  ::onos::config::v2::Failure* unsafe_arena_release_failure();

  // .onos.config.v2.TransactionStatus.State state = 3;
  void clear_state();
  ::onos::config::v2::TransactionStatus_State state() const;
  void set_state(::onos::config::v2::TransactionStatus_State value);
  private:
  ::onos::config::v2::TransactionStatus_State _internal_state() const;
  void _internal_set_state(::onos::config::v2::TransactionStatus_State value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> proposals_;
  ::onos::config::v2::TransactionPhases* phases_;
  ::onos::config::v2::Failure* failure_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionPhases final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionPhases) */ {
 public:
  inline TransactionPhases() : TransactionPhases(nullptr) {}
  ~TransactionPhases() override;
  explicit constexpr TransactionPhases(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionPhases(const TransactionPhases& from);
  TransactionPhases(TransactionPhases&& from) noexcept
    : TransactionPhases() {
    *this = ::std::move(from);
  }

  inline TransactionPhases& operator=(const TransactionPhases& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionPhases& operator=(TransactionPhases&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionPhases& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionPhases* internal_default_instance() {
    return reinterpret_cast<const TransactionPhases*>(
               &_TransactionPhases_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransactionPhases& a, TransactionPhases& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionPhases* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionPhases* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionPhases* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionPhases>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionPhases& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionPhases& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionPhases* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionPhases";
  }
  protected:
  explicit TransactionPhases(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitializeFieldNumber = 1,
    kValidateFieldNumber = 2,
    kCommitFieldNumber = 3,
    kApplyFieldNumber = 4,
    kAbortFieldNumber = 5,
  };
  // .onos.config.v2.TransactionInitializePhase initialize = 1;
  bool has_initialize() const;
  private:
  bool _internal_has_initialize() const;
  public:
  void clear_initialize();
  const ::onos::config::v2::TransactionInitializePhase& initialize() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionInitializePhase* release_initialize();
  ::onos::config::v2::TransactionInitializePhase* mutable_initialize();
  void set_allocated_initialize(::onos::config::v2::TransactionInitializePhase* initialize);
  private:
  const ::onos::config::v2::TransactionInitializePhase& _internal_initialize() const;
  ::onos::config::v2::TransactionInitializePhase* _internal_mutable_initialize();
  public:
  void unsafe_arena_set_allocated_initialize(
      ::onos::config::v2::TransactionInitializePhase* initialize);
  ::onos::config::v2::TransactionInitializePhase* unsafe_arena_release_initialize();

  // .onos.config.v2.TransactionValidatePhase validate = 2;
  bool has_validate() const;
  private:
  bool _internal_has_validate() const;
  public:
  void clear_validate();
  const ::onos::config::v2::TransactionValidatePhase& validate() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionValidatePhase* release_validate();
  ::onos::config::v2::TransactionValidatePhase* mutable_validate();
  void set_allocated_validate(::onos::config::v2::TransactionValidatePhase* validate);
  private:
  const ::onos::config::v2::TransactionValidatePhase& _internal_validate() const;
  ::onos::config::v2::TransactionValidatePhase* _internal_mutable_validate();
  public:
  void unsafe_arena_set_allocated_validate(
      ::onos::config::v2::TransactionValidatePhase* validate);
  ::onos::config::v2::TransactionValidatePhase* unsafe_arena_release_validate();

  // .onos.config.v2.TransactionCommitPhase commit = 3;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::onos::config::v2::TransactionCommitPhase& commit() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionCommitPhase* release_commit();
  ::onos::config::v2::TransactionCommitPhase* mutable_commit();
  void set_allocated_commit(::onos::config::v2::TransactionCommitPhase* commit);
  private:
  const ::onos::config::v2::TransactionCommitPhase& _internal_commit() const;
  ::onos::config::v2::TransactionCommitPhase* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::onos::config::v2::TransactionCommitPhase* commit);
  ::onos::config::v2::TransactionCommitPhase* unsafe_arena_release_commit();

  // .onos.config.v2.TransactionApplyPhase apply = 4;
  bool has_apply() const;
  private:
  bool _internal_has_apply() const;
  public:
  void clear_apply();
  const ::onos::config::v2::TransactionApplyPhase& apply() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionApplyPhase* release_apply();
  ::onos::config::v2::TransactionApplyPhase* mutable_apply();
  void set_allocated_apply(::onos::config::v2::TransactionApplyPhase* apply);
  private:
  const ::onos::config::v2::TransactionApplyPhase& _internal_apply() const;
  ::onos::config::v2::TransactionApplyPhase* _internal_mutable_apply();
  public:
  void unsafe_arena_set_allocated_apply(
      ::onos::config::v2::TransactionApplyPhase* apply);
  ::onos::config::v2::TransactionApplyPhase* unsafe_arena_release_apply();

  // .onos.config.v2.TransactionAbortPhase abort = 5;
  bool has_abort() const;
  private:
  bool _internal_has_abort() const;
  public:
  void clear_abort();
  const ::onos::config::v2::TransactionAbortPhase& abort() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionAbortPhase* release_abort();
  ::onos::config::v2::TransactionAbortPhase* mutable_abort();
  void set_allocated_abort(::onos::config::v2::TransactionAbortPhase* abort);
  private:
  const ::onos::config::v2::TransactionAbortPhase& _internal_abort() const;
  ::onos::config::v2::TransactionAbortPhase* _internal_mutable_abort();
  public:
  void unsafe_arena_set_allocated_abort(
      ::onos::config::v2::TransactionAbortPhase* abort);
  ::onos::config::v2::TransactionAbortPhase* unsafe_arena_release_abort();

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionPhases)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::TransactionInitializePhase* initialize_;
  ::onos::config::v2::TransactionValidatePhase* validate_;
  ::onos::config::v2::TransactionCommitPhase* commit_;
  ::onos::config::v2::TransactionApplyPhase* apply_;
  ::onos::config::v2::TransactionAbortPhase* abort_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionPhaseStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionPhaseStatus) */ {
 public:
  inline TransactionPhaseStatus() : TransactionPhaseStatus(nullptr) {}
  ~TransactionPhaseStatus() override;
  explicit constexpr TransactionPhaseStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionPhaseStatus(const TransactionPhaseStatus& from);
  TransactionPhaseStatus(TransactionPhaseStatus&& from) noexcept
    : TransactionPhaseStatus() {
    *this = ::std::move(from);
  }

  inline TransactionPhaseStatus& operator=(const TransactionPhaseStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionPhaseStatus& operator=(TransactionPhaseStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionPhaseStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionPhaseStatus* internal_default_instance() {
    return reinterpret_cast<const TransactionPhaseStatus*>(
               &_TransactionPhaseStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TransactionPhaseStatus& a, TransactionPhaseStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionPhaseStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionPhaseStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionPhaseStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionPhaseStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionPhaseStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionPhaseStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionPhaseStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionPhaseStatus";
  }
  protected:
  explicit TransactionPhaseStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .google.protobuf.Timestamp start = 1 [(.gogoproto.stdtime) = true];
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& start() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_start();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_start();
  void set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_start() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* start);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_start();

  // .google.protobuf.Timestamp end = 2 [(.gogoproto.stdtime) = true];
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end();
  void set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionPhaseStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* start_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionInitializePhase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionInitializePhase) */ {
 public:
  inline TransactionInitializePhase() : TransactionInitializePhase(nullptr) {}
  ~TransactionInitializePhase() override;
  explicit constexpr TransactionInitializePhase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionInitializePhase(const TransactionInitializePhase& from);
  TransactionInitializePhase(TransactionInitializePhase&& from) noexcept
    : TransactionInitializePhase() {
    *this = ::std::move(from);
  }

  inline TransactionInitializePhase& operator=(const TransactionInitializePhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionInitializePhase& operator=(TransactionInitializePhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionInitializePhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionInitializePhase* internal_default_instance() {
    return reinterpret_cast<const TransactionInitializePhase*>(
               &_TransactionInitializePhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TransactionInitializePhase& a, TransactionInitializePhase& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionInitializePhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionInitializePhase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionInitializePhase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionInitializePhase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionInitializePhase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionInitializePhase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionInitializePhase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionInitializePhase";
  }
  protected:
  explicit TransactionInitializePhase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionInitializePhase_State State;
  static constexpr State INITIALIZING =
    TransactionInitializePhase_State_INITIALIZING;
  static constexpr State INITIALIZED =
    TransactionInitializePhase_State_INITIALIZED;
  static constexpr State FAILED =
    TransactionInitializePhase_State_FAILED;
  static inline bool State_IsValid(int value) {
    return TransactionInitializePhase_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TransactionInitializePhase_State_State_MIN;
  static constexpr State State_MAX =
    TransactionInitializePhase_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TransactionInitializePhase_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TransactionInitializePhase_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TransactionInitializePhase_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TransactionInitializePhase_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kFailureFieldNumber = 3,
    kStateFieldNumber = 2,
  };
  // .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::config::v2::TransactionPhaseStatus& status() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionPhaseStatus* release_status();
  ::onos::config::v2::TransactionPhaseStatus* mutable_status();
  void set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status);
  private:
  const ::onos::config::v2::TransactionPhaseStatus& _internal_status() const;
  ::onos::config::v2::TransactionPhaseStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::config::v2::TransactionPhaseStatus* status);
  ::onos::config::v2::TransactionPhaseStatus* unsafe_arena_release_status();

  // .onos.config.v2.Failure failure = 3;
  bool has_failure() const;
  private:
  bool _internal_has_failure() const;
  public:
  void clear_failure();
  const ::onos::config::v2::Failure& failure() const;
  PROTOBUF_NODISCARD ::onos::config::v2::Failure* release_failure();
  ::onos::config::v2::Failure* mutable_failure();
  void set_allocated_failure(::onos::config::v2::Failure* failure);
  private:
  const ::onos::config::v2::Failure& _internal_failure() const;
  ::onos::config::v2::Failure* _internal_mutable_failure();
  public:
  void unsafe_arena_set_allocated_failure(
      ::onos::config::v2::Failure* failure);
  ::onos::config::v2::Failure* unsafe_arena_release_failure();

  // .onos.config.v2.TransactionInitializePhase.State state = 2;
  void clear_state();
  ::onos::config::v2::TransactionInitializePhase_State state() const;
  void set_state(::onos::config::v2::TransactionInitializePhase_State value);
  private:
  ::onos::config::v2::TransactionInitializePhase_State _internal_state() const;
  void _internal_set_state(::onos::config::v2::TransactionInitializePhase_State value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionInitializePhase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::TransactionPhaseStatus* status_;
  ::onos::config::v2::Failure* failure_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionValidatePhase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionValidatePhase) */ {
 public:
  inline TransactionValidatePhase() : TransactionValidatePhase(nullptr) {}
  ~TransactionValidatePhase() override;
  explicit constexpr TransactionValidatePhase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionValidatePhase(const TransactionValidatePhase& from);
  TransactionValidatePhase(TransactionValidatePhase&& from) noexcept
    : TransactionValidatePhase() {
    *this = ::std::move(from);
  }

  inline TransactionValidatePhase& operator=(const TransactionValidatePhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionValidatePhase& operator=(TransactionValidatePhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionValidatePhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionValidatePhase* internal_default_instance() {
    return reinterpret_cast<const TransactionValidatePhase*>(
               &_TransactionValidatePhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TransactionValidatePhase& a, TransactionValidatePhase& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionValidatePhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionValidatePhase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionValidatePhase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionValidatePhase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionValidatePhase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionValidatePhase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionValidatePhase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionValidatePhase";
  }
  protected:
  explicit TransactionValidatePhase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionValidatePhase_State State;
  static constexpr State VALIDATING =
    TransactionValidatePhase_State_VALIDATING;
  static constexpr State VALIDATED =
    TransactionValidatePhase_State_VALIDATED;
  static constexpr State FAILED =
    TransactionValidatePhase_State_FAILED;
  static inline bool State_IsValid(int value) {
    return TransactionValidatePhase_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TransactionValidatePhase_State_State_MIN;
  static constexpr State State_MAX =
    TransactionValidatePhase_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TransactionValidatePhase_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TransactionValidatePhase_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TransactionValidatePhase_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TransactionValidatePhase_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kFailureFieldNumber = 3,
    kStateFieldNumber = 2,
  };
  // .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::config::v2::TransactionPhaseStatus& status() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionPhaseStatus* release_status();
  ::onos::config::v2::TransactionPhaseStatus* mutable_status();
  void set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status);
  private:
  const ::onos::config::v2::TransactionPhaseStatus& _internal_status() const;
  ::onos::config::v2::TransactionPhaseStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::config::v2::TransactionPhaseStatus* status);
  ::onos::config::v2::TransactionPhaseStatus* unsafe_arena_release_status();

  // .onos.config.v2.Failure failure = 3;
  bool has_failure() const;
  private:
  bool _internal_has_failure() const;
  public:
  void clear_failure();
  const ::onos::config::v2::Failure& failure() const;
  PROTOBUF_NODISCARD ::onos::config::v2::Failure* release_failure();
  ::onos::config::v2::Failure* mutable_failure();
  void set_allocated_failure(::onos::config::v2::Failure* failure);
  private:
  const ::onos::config::v2::Failure& _internal_failure() const;
  ::onos::config::v2::Failure* _internal_mutable_failure();
  public:
  void unsafe_arena_set_allocated_failure(
      ::onos::config::v2::Failure* failure);
  ::onos::config::v2::Failure* unsafe_arena_release_failure();

  // .onos.config.v2.TransactionValidatePhase.State state = 2;
  void clear_state();
  ::onos::config::v2::TransactionValidatePhase_State state() const;
  void set_state(::onos::config::v2::TransactionValidatePhase_State value);
  private:
  ::onos::config::v2::TransactionValidatePhase_State _internal_state() const;
  void _internal_set_state(::onos::config::v2::TransactionValidatePhase_State value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionValidatePhase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::TransactionPhaseStatus* status_;
  ::onos::config::v2::Failure* failure_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionCommitPhase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionCommitPhase) */ {
 public:
  inline TransactionCommitPhase() : TransactionCommitPhase(nullptr) {}
  ~TransactionCommitPhase() override;
  explicit constexpr TransactionCommitPhase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionCommitPhase(const TransactionCommitPhase& from);
  TransactionCommitPhase(TransactionCommitPhase&& from) noexcept
    : TransactionCommitPhase() {
    *this = ::std::move(from);
  }

  inline TransactionCommitPhase& operator=(const TransactionCommitPhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionCommitPhase& operator=(TransactionCommitPhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionCommitPhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionCommitPhase* internal_default_instance() {
    return reinterpret_cast<const TransactionCommitPhase*>(
               &_TransactionCommitPhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransactionCommitPhase& a, TransactionCommitPhase& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionCommitPhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionCommitPhase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionCommitPhase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionCommitPhase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionCommitPhase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionCommitPhase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionCommitPhase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionCommitPhase";
  }
  protected:
  explicit TransactionCommitPhase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionCommitPhase_State State;
  static constexpr State COMMITTING =
    TransactionCommitPhase_State_COMMITTING;
  static constexpr State COMMITTED =
    TransactionCommitPhase_State_COMMITTED;
  static inline bool State_IsValid(int value) {
    return TransactionCommitPhase_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TransactionCommitPhase_State_State_MIN;
  static constexpr State State_MAX =
    TransactionCommitPhase_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TransactionCommitPhase_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TransactionCommitPhase_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TransactionCommitPhase_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TransactionCommitPhase_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::config::v2::TransactionPhaseStatus& status() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionPhaseStatus* release_status();
  ::onos::config::v2::TransactionPhaseStatus* mutable_status();
  void set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status);
  private:
  const ::onos::config::v2::TransactionPhaseStatus& _internal_status() const;
  ::onos::config::v2::TransactionPhaseStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::config::v2::TransactionPhaseStatus* status);
  ::onos::config::v2::TransactionPhaseStatus* unsafe_arena_release_status();

  // .onos.config.v2.TransactionCommitPhase.State state = 2;
  void clear_state();
  ::onos::config::v2::TransactionCommitPhase_State state() const;
  void set_state(::onos::config::v2::TransactionCommitPhase_State value);
  private:
  ::onos::config::v2::TransactionCommitPhase_State _internal_state() const;
  void _internal_set_state(::onos::config::v2::TransactionCommitPhase_State value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionCommitPhase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::TransactionPhaseStatus* status_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionApplyPhase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionApplyPhase) */ {
 public:
  inline TransactionApplyPhase() : TransactionApplyPhase(nullptr) {}
  ~TransactionApplyPhase() override;
  explicit constexpr TransactionApplyPhase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionApplyPhase(const TransactionApplyPhase& from);
  TransactionApplyPhase(TransactionApplyPhase&& from) noexcept
    : TransactionApplyPhase() {
    *this = ::std::move(from);
  }

  inline TransactionApplyPhase& operator=(const TransactionApplyPhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionApplyPhase& operator=(TransactionApplyPhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionApplyPhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionApplyPhase* internal_default_instance() {
    return reinterpret_cast<const TransactionApplyPhase*>(
               &_TransactionApplyPhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransactionApplyPhase& a, TransactionApplyPhase& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionApplyPhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionApplyPhase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionApplyPhase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionApplyPhase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionApplyPhase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionApplyPhase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionApplyPhase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionApplyPhase";
  }
  protected:
  explicit TransactionApplyPhase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionApplyPhase_State State;
  static constexpr State APPLYING =
    TransactionApplyPhase_State_APPLYING;
  static constexpr State APPLIED =
    TransactionApplyPhase_State_APPLIED;
  static constexpr State FAILED =
    TransactionApplyPhase_State_FAILED;
  static inline bool State_IsValid(int value) {
    return TransactionApplyPhase_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TransactionApplyPhase_State_State_MIN;
  static constexpr State State_MAX =
    TransactionApplyPhase_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TransactionApplyPhase_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TransactionApplyPhase_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TransactionApplyPhase_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TransactionApplyPhase_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kFailureFieldNumber = 3,
    kStateFieldNumber = 2,
  };
  // .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::config::v2::TransactionPhaseStatus& status() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionPhaseStatus* release_status();
  ::onos::config::v2::TransactionPhaseStatus* mutable_status();
  void set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status);
  private:
  const ::onos::config::v2::TransactionPhaseStatus& _internal_status() const;
  ::onos::config::v2::TransactionPhaseStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::config::v2::TransactionPhaseStatus* status);
  ::onos::config::v2::TransactionPhaseStatus* unsafe_arena_release_status();

  // .onos.config.v2.Failure failure = 3;
  bool has_failure() const;
  private:
  bool _internal_has_failure() const;
  public:
  void clear_failure();
  const ::onos::config::v2::Failure& failure() const;
  PROTOBUF_NODISCARD ::onos::config::v2::Failure* release_failure();
  ::onos::config::v2::Failure* mutable_failure();
  void set_allocated_failure(::onos::config::v2::Failure* failure);
  private:
  const ::onos::config::v2::Failure& _internal_failure() const;
  ::onos::config::v2::Failure* _internal_mutable_failure();
  public:
  void unsafe_arena_set_allocated_failure(
      ::onos::config::v2::Failure* failure);
  ::onos::config::v2::Failure* unsafe_arena_release_failure();

  // .onos.config.v2.TransactionApplyPhase.State state = 2;
  void clear_state();
  ::onos::config::v2::TransactionApplyPhase_State state() const;
  void set_state(::onos::config::v2::TransactionApplyPhase_State value);
  private:
  ::onos::config::v2::TransactionApplyPhase_State _internal_state() const;
  void _internal_set_state(::onos::config::v2::TransactionApplyPhase_State value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionApplyPhase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::TransactionPhaseStatus* status_;
  ::onos::config::v2::Failure* failure_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionAbortPhase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionAbortPhase) */ {
 public:
  inline TransactionAbortPhase() : TransactionAbortPhase(nullptr) {}
  ~TransactionAbortPhase() override;
  explicit constexpr TransactionAbortPhase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionAbortPhase(const TransactionAbortPhase& from);
  TransactionAbortPhase(TransactionAbortPhase&& from) noexcept
    : TransactionAbortPhase() {
    *this = ::std::move(from);
  }

  inline TransactionAbortPhase& operator=(const TransactionAbortPhase& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionAbortPhase& operator=(TransactionAbortPhase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionAbortPhase& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionAbortPhase* internal_default_instance() {
    return reinterpret_cast<const TransactionAbortPhase*>(
               &_TransactionAbortPhase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TransactionAbortPhase& a, TransactionAbortPhase& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionAbortPhase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionAbortPhase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionAbortPhase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionAbortPhase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionAbortPhase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionAbortPhase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionAbortPhase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionAbortPhase";
  }
  protected:
  explicit TransactionAbortPhase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionAbortPhase_State State;
  static constexpr State ABORTING =
    TransactionAbortPhase_State_ABORTING;
  static constexpr State ABORTED =
    TransactionAbortPhase_State_ABORTED;
  static inline bool State_IsValid(int value) {
    return TransactionAbortPhase_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TransactionAbortPhase_State_State_MIN;
  static constexpr State State_MAX =
    TransactionAbortPhase_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TransactionAbortPhase_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TransactionAbortPhase_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TransactionAbortPhase_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TransactionAbortPhase_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::config::v2::TransactionPhaseStatus& status() const;
  PROTOBUF_NODISCARD ::onos::config::v2::TransactionPhaseStatus* release_status();
  ::onos::config::v2::TransactionPhaseStatus* mutable_status();
  void set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status);
  private:
  const ::onos::config::v2::TransactionPhaseStatus& _internal_status() const;
  ::onos::config::v2::TransactionPhaseStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::config::v2::TransactionPhaseStatus* status);
  ::onos::config::v2::TransactionPhaseStatus* unsafe_arena_release_status();

  // .onos.config.v2.TransactionAbortPhase.State state = 2;
  void clear_state();
  ::onos::config::v2::TransactionAbortPhase_State state() const;
  void set_state(::onos::config::v2::TransactionAbortPhase_State value);
  private:
  ::onos::config::v2::TransactionAbortPhase_State _internal_state() const;
  void _internal_set_state(::onos::config::v2::TransactionAbortPhase_State value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionAbortPhase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::TransactionPhaseStatus* status_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TransactionEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TransactionEvent) */ {
 public:
  inline TransactionEvent() : TransactionEvent(nullptr) {}
  ~TransactionEvent() override;
  explicit constexpr TransactionEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionEvent(const TransactionEvent& from);
  TransactionEvent(TransactionEvent&& from) noexcept
    : TransactionEvent() {
    *this = ::std::move(from);
  }

  inline TransactionEvent& operator=(const TransactionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionEvent& operator=(TransactionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionEvent* internal_default_instance() {
    return reinterpret_cast<const TransactionEvent*>(
               &_TransactionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransactionEvent& a, TransactionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TransactionEvent";
  }
  protected:
  explicit TransactionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransactionEvent_EventType EventType;
  static constexpr EventType UNKNOWN =
    TransactionEvent_EventType_UNKNOWN;
  static constexpr EventType CREATED =
    TransactionEvent_EventType_CREATED;
  static constexpr EventType UPDATED =
    TransactionEvent_EventType_UPDATED;
  static constexpr EventType DELETED =
    TransactionEvent_EventType_DELETED;
  static constexpr EventType REPLAYED =
    TransactionEvent_EventType_REPLAYED;
  static inline bool EventType_IsValid(int value) {
    return TransactionEvent_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    TransactionEvent_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    TransactionEvent_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    TransactionEvent_EventType_EventType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EventType_descriptor() {
    return TransactionEvent_EventType_descriptor();
  }
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return TransactionEvent_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EventType* value) {
    return TransactionEvent_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .onos.config.v2.Transaction transaction = 2 [(.gogoproto.nullable) = false];
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::onos::config::v2::Transaction& transaction() const;
  PROTOBUF_NODISCARD ::onos::config::v2::Transaction* release_transaction();
  ::onos::config::v2::Transaction* mutable_transaction();
  void set_allocated_transaction(::onos::config::v2::Transaction* transaction);
  private:
  const ::onos::config::v2::Transaction& _internal_transaction() const;
  ::onos::config::v2::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::onos::config::v2::Transaction* transaction);
  ::onos::config::v2::Transaction* unsafe_arena_release_transaction();

  // .onos.config.v2.TransactionEvent.EventType type = 1;
  void clear_type();
  ::onos::config::v2::TransactionEvent_EventType type() const;
  void set_type(::onos::config::v2::TransactionEvent_EventType value);
  private:
  ::onos::config::v2::TransactionEvent_EventType _internal_type() const;
  void _internal_set_type(::onos::config::v2::TransactionEvent_EventType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.config.v2.TransactionEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::config::v2::Transaction* transaction_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// -------------------------------------------------------------------

class TargetVersionOverrides_OverridesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TargetVersionOverrides_OverridesEntry_DoNotUse, 
    std::string, ::onos::config::v2::TargetTypeVersion,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TargetVersionOverrides_OverridesEntry_DoNotUse, 
    std::string, ::onos::config::v2::TargetTypeVersion,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TargetVersionOverrides_OverridesEntry_DoNotUse();
  explicit constexpr TargetVersionOverrides_OverridesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TargetVersionOverrides_OverridesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TargetVersionOverrides_OverridesEntry_DoNotUse& other);
  static const TargetVersionOverrides_OverridesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TargetVersionOverrides_OverridesEntry_DoNotUse*>(&_TargetVersionOverrides_OverridesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "onos.config.v2.TargetVersionOverrides.OverridesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TargetVersionOverrides final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.config.v2.TargetVersionOverrides) */ {
 public:
  inline TargetVersionOverrides() : TargetVersionOverrides(nullptr) {}
  ~TargetVersionOverrides() override;
  explicit constexpr TargetVersionOverrides(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetVersionOverrides(const TargetVersionOverrides& from);
  TargetVersionOverrides(TargetVersionOverrides&& from) noexcept
    : TargetVersionOverrides() {
    *this = ::std::move(from);
  }

  inline TargetVersionOverrides& operator=(const TargetVersionOverrides& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetVersionOverrides& operator=(TargetVersionOverrides&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetVersionOverrides& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetVersionOverrides* internal_default_instance() {
    return reinterpret_cast<const TargetVersionOverrides*>(
               &_TargetVersionOverrides_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TargetVersionOverrides& a, TargetVersionOverrides& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetVersionOverrides* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetVersionOverrides* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetVersionOverrides* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetVersionOverrides>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetVersionOverrides& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetVersionOverrides& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetVersionOverrides* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.config.v2.TargetVersionOverrides";
  }
  protected:
  explicit TargetVersionOverrides(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOverridesFieldNumber = 1,
  };
  // map<string, .onos.config.v2.TargetTypeVersion> overrides = 1;
  int overrides_size() const;
  private:
  int _internal_overrides_size() const;
  public:
  void clear_overrides();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >&
      _internal_overrides() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >*
      _internal_mutable_overrides();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >&
      overrides() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >*
      mutable_overrides();

  // @@protoc_insertion_point(class_scope:onos.config.v2.TargetVersionOverrides)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TargetVersionOverrides_OverridesEntry_DoNotUse,
      std::string, ::onos::config::v2::TargetTypeVersion,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> overrides_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fconfig_2fv2_2ftransaction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransactionInfo

// string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "TransactionID"];
inline void TransactionInfo::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TransactionInfo::id() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionInfo.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionInfo::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionInfo.id)
}
inline std::string* TransactionInfo::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionInfo.id)
  return _s;
}
inline const std::string& TransactionInfo::_internal_id() const {
  return id_.Get();
}
inline void TransactionInfo::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionInfo::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionInfo::release_id() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionInfo.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionInfo::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionInfo.id)
}

// uint64 index = 2 [(.gogoproto.casttype) = "Index"];
inline void TransactionInfo::clear_index() {
  index_ = uint64_t{0u};
}
inline uint64_t TransactionInfo::_internal_index() const {
  return index_;
}
inline uint64_t TransactionInfo::index() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionInfo.index)
  return _internal_index();
}
inline void TransactionInfo::_internal_set_index(uint64_t value) {
  
  index_ = value;
}
inline void TransactionInfo::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionInfo.index)
}

// -------------------------------------------------------------------

// Transaction

// .onos.config.v2.ObjectMeta meta = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool Transaction::_internal_has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline bool Transaction::has_meta() const {
  return _internal_has_meta();
}
inline const ::onos::config::v2::ObjectMeta& Transaction::_internal_meta() const {
  const ::onos::config::v2::ObjectMeta* p = meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::ObjectMeta&>(
      ::onos::config::v2::_ObjectMeta_default_instance_);
}
inline const ::onos::config::v2::ObjectMeta& Transaction::meta() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.meta)
  return _internal_meta();
}
inline void Transaction::unsafe_arena_set_allocated_meta(
    ::onos::config::v2::ObjectMeta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.Transaction.meta)
}
inline ::onos::config::v2::ObjectMeta* Transaction::release_meta() {
  
  ::onos::config::v2::ObjectMeta* temp = meta_;
  meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::ObjectMeta* Transaction::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.meta)
  
  ::onos::config::v2::ObjectMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::onos::config::v2::ObjectMeta* Transaction::_internal_mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::ObjectMeta>(GetArenaForAllocation());
    meta_ = p;
  }
  return meta_;
}
inline ::onos::config::v2::ObjectMeta* Transaction::mutable_meta() {
  ::onos::config::v2::ObjectMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.meta)
  return _msg;
}
inline void Transaction::set_allocated_meta(::onos::config::v2::ObjectMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta));
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.Transaction.meta)
}

// string id = 2 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "TransactionID"];
inline void Transaction::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Transaction::id() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.config.v2.Transaction.id)
}
inline std::string* Transaction::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.id)
  return _s;
}
inline const std::string& Transaction::_internal_id() const {
  return id_.Get();
}
inline void Transaction::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction::release_id() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.Transaction.id)
}

// uint64 index = 3 [(.gogoproto.casttype) = "Index"];
inline void Transaction::clear_index() {
  index_ = uint64_t{0u};
}
inline uint64_t Transaction::_internal_index() const {
  return index_;
}
inline uint64_t Transaction::index() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.index)
  return _internal_index();
}
inline void Transaction::_internal_set_index(uint64_t value) {
  
  index_ = value;
}
inline void Transaction::set_index(uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.Transaction.index)
}

// string username = 4;
inline void Transaction::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& Transaction::username() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.config.v2.Transaction.username)
}
inline std::string* Transaction::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.username)
  return _s;
}
inline const std::string& Transaction::_internal_username() const {
  return username_.Get();
}
inline void Transaction::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction::release_username() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.Transaction.username)
}

// .onos.config.v2.TransactionStrategy strategy = 5 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool Transaction::_internal_has_strategy() const {
  return this != internal_default_instance() && strategy_ != nullptr;
}
inline bool Transaction::has_strategy() const {
  return _internal_has_strategy();
}
inline void Transaction::clear_strategy() {
  if (GetArenaForAllocation() == nullptr && strategy_ != nullptr) {
    delete strategy_;
  }
  strategy_ = nullptr;
}
inline const ::onos::config::v2::TransactionStrategy& Transaction::_internal_strategy() const {
  const ::onos::config::v2::TransactionStrategy* p = strategy_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionStrategy&>(
      ::onos::config::v2::_TransactionStrategy_default_instance_);
}
inline const ::onos::config::v2::TransactionStrategy& Transaction::strategy() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.strategy)
  return _internal_strategy();
}
inline void Transaction::unsafe_arena_set_allocated_strategy(
    ::onos::config::v2::TransactionStrategy* strategy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_);
  }
  strategy_ = strategy;
  if (strategy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.Transaction.strategy)
}
inline ::onos::config::v2::TransactionStrategy* Transaction::release_strategy() {
  
  ::onos::config::v2::TransactionStrategy* temp = strategy_;
  strategy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionStrategy* Transaction::unsafe_arena_release_strategy() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.strategy)
  
  ::onos::config::v2::TransactionStrategy* temp = strategy_;
  strategy_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionStrategy* Transaction::_internal_mutable_strategy() {
  
  if (strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionStrategy>(GetArenaForAllocation());
    strategy_ = p;
  }
  return strategy_;
}
inline ::onos::config::v2::TransactionStrategy* Transaction::mutable_strategy() {
  ::onos::config::v2::TransactionStrategy* _msg = _internal_mutable_strategy();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.strategy)
  return _msg;
}
inline void Transaction::set_allocated_strategy(::onos::config::v2::TransactionStrategy* strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete strategy_;
  }
  if (strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionStrategy>::GetOwningArena(strategy);
    if (message_arena != submessage_arena) {
      strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy, submessage_arena);
    }
    
  } else {
    
  }
  strategy_ = strategy;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.Transaction.strategy)
}

// .onos.config.v2.ChangeTransaction change = 6;
inline bool Transaction::_internal_has_change() const {
  return details_case() == kChange;
}
inline bool Transaction::has_change() const {
  return _internal_has_change();
}
inline void Transaction::set_has_change() {
  _oneof_case_[0] = kChange;
}
inline void Transaction::clear_change() {
  if (_internal_has_change()) {
    if (GetArenaForAllocation() == nullptr) {
      delete details_.change_;
    }
    clear_has_details();
  }
}
inline ::onos::config::v2::ChangeTransaction* Transaction::release_change() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.change)
  if (_internal_has_change()) {
    clear_has_details();
      ::onos::config::v2::ChangeTransaction* temp = details_.change_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    details_.change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::config::v2::ChangeTransaction& Transaction::_internal_change() const {
  return _internal_has_change()
      ? *details_.change_
      : reinterpret_cast< ::onos::config::v2::ChangeTransaction&>(::onos::config::v2::_ChangeTransaction_default_instance_);
}
inline const ::onos::config::v2::ChangeTransaction& Transaction::change() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.change)
  return _internal_change();
}
inline ::onos::config::v2::ChangeTransaction* Transaction::unsafe_arena_release_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.config.v2.Transaction.change)
  if (_internal_has_change()) {
    clear_has_details();
    ::onos::config::v2::ChangeTransaction* temp = details_.change_;
    details_.change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_change(::onos::config::v2::ChangeTransaction* change) {
  clear_details();
  if (change) {
    set_has_change();
    details_.change_ = change;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.Transaction.change)
}
inline ::onos::config::v2::ChangeTransaction* Transaction::_internal_mutable_change() {
  if (!_internal_has_change()) {
    clear_details();
    set_has_change();
    details_.change_ = CreateMaybeMessage< ::onos::config::v2::ChangeTransaction >(GetArenaForAllocation());
  }
  return details_.change_;
}
inline ::onos::config::v2::ChangeTransaction* Transaction::mutable_change() {
  ::onos::config::v2::ChangeTransaction* _msg = _internal_mutable_change();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.change)
  return _msg;
}

// .onos.config.v2.RollbackTransaction rollback = 7;
inline bool Transaction::_internal_has_rollback() const {
  return details_case() == kRollback;
}
inline bool Transaction::has_rollback() const {
  return _internal_has_rollback();
}
inline void Transaction::set_has_rollback() {
  _oneof_case_[0] = kRollback;
}
inline void Transaction::clear_rollback() {
  if (_internal_has_rollback()) {
    if (GetArenaForAllocation() == nullptr) {
      delete details_.rollback_;
    }
    clear_has_details();
  }
}
inline ::onos::config::v2::RollbackTransaction* Transaction::release_rollback() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.rollback)
  if (_internal_has_rollback()) {
    clear_has_details();
      ::onos::config::v2::RollbackTransaction* temp = details_.rollback_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    details_.rollback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::config::v2::RollbackTransaction& Transaction::_internal_rollback() const {
  return _internal_has_rollback()
      ? *details_.rollback_
      : reinterpret_cast< ::onos::config::v2::RollbackTransaction&>(::onos::config::v2::_RollbackTransaction_default_instance_);
}
inline const ::onos::config::v2::RollbackTransaction& Transaction::rollback() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.rollback)
  return _internal_rollback();
}
inline ::onos::config::v2::RollbackTransaction* Transaction::unsafe_arena_release_rollback() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.config.v2.Transaction.rollback)
  if (_internal_has_rollback()) {
    clear_has_details();
    ::onos::config::v2::RollbackTransaction* temp = details_.rollback_;
    details_.rollback_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Transaction::unsafe_arena_set_allocated_rollback(::onos::config::v2::RollbackTransaction* rollback) {
  clear_details();
  if (rollback) {
    set_has_rollback();
    details_.rollback_ = rollback;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.Transaction.rollback)
}
inline ::onos::config::v2::RollbackTransaction* Transaction::_internal_mutable_rollback() {
  if (!_internal_has_rollback()) {
    clear_details();
    set_has_rollback();
    details_.rollback_ = CreateMaybeMessage< ::onos::config::v2::RollbackTransaction >(GetArenaForAllocation());
  }
  return details_.rollback_;
}
inline ::onos::config::v2::RollbackTransaction* Transaction::mutable_rollback() {
  ::onos::config::v2::RollbackTransaction* _msg = _internal_mutable_rollback();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.rollback)
  return _msg;
}

// .onos.config.v2.TransactionStatus status = 8 [(.gogoproto.nullable) = false];
inline bool Transaction::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Transaction::has_status() const {
  return _internal_has_status();
}
inline void Transaction::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::config::v2::TransactionStatus& Transaction::_internal_status() const {
  const ::onos::config::v2::TransactionStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionStatus&>(
      ::onos::config::v2::_TransactionStatus_default_instance_);
}
inline const ::onos::config::v2::TransactionStatus& Transaction::status() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.status)
  return _internal_status();
}
inline void Transaction::unsafe_arena_set_allocated_status(
    ::onos::config::v2::TransactionStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.Transaction.status)
}
inline ::onos::config::v2::TransactionStatus* Transaction::release_status() {
  
  ::onos::config::v2::TransactionStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionStatus* Transaction::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.status)
  
  ::onos::config::v2::TransactionStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionStatus* Transaction::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::config::v2::TransactionStatus* Transaction::mutable_status() {
  ::onos::config::v2::TransactionStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.status)
  return _msg;
}
inline void Transaction::set_allocated_status(::onos::config::v2::TransactionStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.Transaction.status)
}

// .onos.config.v2.TargetVersionOverrides version_overrides = 9 [(.gogoproto.embed) = true];
inline bool Transaction::_internal_has_version_overrides() const {
  return this != internal_default_instance() && version_overrides_ != nullptr;
}
inline bool Transaction::has_version_overrides() const {
  return _internal_has_version_overrides();
}
inline void Transaction::clear_version_overrides() {
  if (GetArenaForAllocation() == nullptr && version_overrides_ != nullptr) {
    delete version_overrides_;
  }
  version_overrides_ = nullptr;
}
inline const ::onos::config::v2::TargetVersionOverrides& Transaction::_internal_version_overrides() const {
  const ::onos::config::v2::TargetVersionOverrides* p = version_overrides_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TargetVersionOverrides&>(
      ::onos::config::v2::_TargetVersionOverrides_default_instance_);
}
inline const ::onos::config::v2::TargetVersionOverrides& Transaction::version_overrides() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.Transaction.version_overrides)
  return _internal_version_overrides();
}
inline void Transaction::unsafe_arena_set_allocated_version_overrides(
    ::onos::config::v2::TargetVersionOverrides* version_overrides) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_overrides_);
  }
  version_overrides_ = version_overrides;
  if (version_overrides) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.Transaction.version_overrides)
}
inline ::onos::config::v2::TargetVersionOverrides* Transaction::release_version_overrides() {
  
  ::onos::config::v2::TargetVersionOverrides* temp = version_overrides_;
  version_overrides_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TargetVersionOverrides* Transaction::unsafe_arena_release_version_overrides() {
  // @@protoc_insertion_point(field_release:onos.config.v2.Transaction.version_overrides)
  
  ::onos::config::v2::TargetVersionOverrides* temp = version_overrides_;
  version_overrides_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TargetVersionOverrides* Transaction::_internal_mutable_version_overrides() {
  
  if (version_overrides_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TargetVersionOverrides>(GetArenaForAllocation());
    version_overrides_ = p;
  }
  return version_overrides_;
}
inline ::onos::config::v2::TargetVersionOverrides* Transaction::mutable_version_overrides() {
  ::onos::config::v2::TargetVersionOverrides* _msg = _internal_mutable_version_overrides();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.Transaction.version_overrides)
  return _msg;
}
inline void Transaction::set_allocated_version_overrides(::onos::config::v2::TargetVersionOverrides* version_overrides) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete version_overrides_;
  }
  if (version_overrides) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TargetVersionOverrides>::GetOwningArena(version_overrides);
    if (message_arena != submessage_arena) {
      version_overrides = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version_overrides, submessage_arena);
    }
    
  } else {
    
  }
  version_overrides_ = version_overrides;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.Transaction.version_overrides)
}

inline bool Transaction::has_details() const {
  return details_case() != DETAILS_NOT_SET;
}
inline void Transaction::clear_has_details() {
  _oneof_case_[0] = DETAILS_NOT_SET;
}
inline Transaction::DetailsCase Transaction::details_case() const {
  return Transaction::DetailsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransactionStrategy

// .onos.config.v2.TransactionStrategy.Synchronicity synchronicity = 1;
inline void TransactionStrategy::clear_synchronicity() {
  synchronicity_ = 0;
}
inline ::onos::config::v2::TransactionStrategy_Synchronicity TransactionStrategy::_internal_synchronicity() const {
  return static_cast< ::onos::config::v2::TransactionStrategy_Synchronicity >(synchronicity_);
}
inline ::onos::config::v2::TransactionStrategy_Synchronicity TransactionStrategy::synchronicity() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionStrategy.synchronicity)
  return _internal_synchronicity();
}
inline void TransactionStrategy::_internal_set_synchronicity(::onos::config::v2::TransactionStrategy_Synchronicity value) {
  
  synchronicity_ = value;
}
inline void TransactionStrategy::set_synchronicity(::onos::config::v2::TransactionStrategy_Synchronicity value) {
  _internal_set_synchronicity(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionStrategy.synchronicity)
}

// .onos.config.v2.TransactionStrategy.Isolation isolation = 2;
inline void TransactionStrategy::clear_isolation() {
  isolation_ = 0;
}
inline ::onos::config::v2::TransactionStrategy_Isolation TransactionStrategy::_internal_isolation() const {
  return static_cast< ::onos::config::v2::TransactionStrategy_Isolation >(isolation_);
}
inline ::onos::config::v2::TransactionStrategy_Isolation TransactionStrategy::isolation() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionStrategy.isolation)
  return _internal_isolation();
}
inline void TransactionStrategy::_internal_set_isolation(::onos::config::v2::TransactionStrategy_Isolation value) {
  
  isolation_ = value;
}
inline void TransactionStrategy::set_isolation(::onos::config::v2::TransactionStrategy_Isolation value) {
  _internal_set_isolation(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionStrategy.isolation)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ChangeTransaction

// map<string, .onos.config.v2.PathValues> values = 1 [(.gogoproto.castkey) = "TargetID"];
inline int ChangeTransaction::_internal_values_size() const {
  return values_.size();
}
inline int ChangeTransaction::values_size() const {
  return _internal_values_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >&
ChangeTransaction::_internal_values() const {
  return values_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >&
ChangeTransaction::values() const {
  // @@protoc_insertion_point(field_map:onos.config.v2.ChangeTransaction.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >*
ChangeTransaction::_internal_mutable_values() {
  return values_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::PathValues >*
ChangeTransaction::mutable_values() {
  // @@protoc_insertion_point(field_mutable_map:onos.config.v2.ChangeTransaction.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// RollbackTransaction

// uint64 rollback_index = 1 [(.gogoproto.casttype) = "Index"];
inline void RollbackTransaction::clear_rollback_index() {
  rollback_index_ = uint64_t{0u};
}
inline uint64_t RollbackTransaction::_internal_rollback_index() const {
  return rollback_index_;
}
inline uint64_t RollbackTransaction::rollback_index() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.RollbackTransaction.rollback_index)
  return _internal_rollback_index();
}
inline void RollbackTransaction::_internal_set_rollback_index(uint64_t value) {
  
  rollback_index_ = value;
}
inline void RollbackTransaction::set_rollback_index(uint64_t value) {
  _internal_set_rollback_index(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.RollbackTransaction.rollback_index)
}

// -------------------------------------------------------------------

// TransactionStatus

// .onos.config.v2.TransactionPhases phases = 1 [(.gogoproto.nullable) = false];
inline bool TransactionStatus::_internal_has_phases() const {
  return this != internal_default_instance() && phases_ != nullptr;
}
inline bool TransactionStatus::has_phases() const {
  return _internal_has_phases();
}
inline void TransactionStatus::clear_phases() {
  if (GetArenaForAllocation() == nullptr && phases_ != nullptr) {
    delete phases_;
  }
  phases_ = nullptr;
}
inline const ::onos::config::v2::TransactionPhases& TransactionStatus::_internal_phases() const {
  const ::onos::config::v2::TransactionPhases* p = phases_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionPhases&>(
      ::onos::config::v2::_TransactionPhases_default_instance_);
}
inline const ::onos::config::v2::TransactionPhases& TransactionStatus::phases() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionStatus.phases)
  return _internal_phases();
}
inline void TransactionStatus::unsafe_arena_set_allocated_phases(
    ::onos::config::v2::TransactionPhases* phases) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phases_);
  }
  phases_ = phases;
  if (phases) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionStatus.phases)
}
inline ::onos::config::v2::TransactionPhases* TransactionStatus::release_phases() {
  
  ::onos::config::v2::TransactionPhases* temp = phases_;
  phases_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionPhases* TransactionStatus::unsafe_arena_release_phases() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionStatus.phases)
  
  ::onos::config::v2::TransactionPhases* temp = phases_;
  phases_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionPhases* TransactionStatus::_internal_mutable_phases() {
  
  if (phases_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionPhases>(GetArenaForAllocation());
    phases_ = p;
  }
  return phases_;
}
inline ::onos::config::v2::TransactionPhases* TransactionStatus::mutable_phases() {
  ::onos::config::v2::TransactionPhases* _msg = _internal_mutable_phases();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionStatus.phases)
  return _msg;
}
inline void TransactionStatus::set_allocated_phases(::onos::config::v2::TransactionPhases* phases) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete phases_;
  }
  if (phases) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionPhases>::GetOwningArena(phases);
    if (message_arena != submessage_arena) {
      phases = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phases, submessage_arena);
    }
    
  } else {
    
  }
  phases_ = phases;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionStatus.phases)
}

// repeated string proposals = 2 [(.gogoproto.casttype) = "ProposalID"];
inline int TransactionStatus::_internal_proposals_size() const {
  return proposals_.size();
}
inline int TransactionStatus::proposals_size() const {
  return _internal_proposals_size();
}
inline void TransactionStatus::clear_proposals() {
  proposals_.Clear();
}
inline std::string* TransactionStatus::add_proposals() {
  std::string* _s = _internal_add_proposals();
  // @@protoc_insertion_point(field_add_mutable:onos.config.v2.TransactionStatus.proposals)
  return _s;
}
inline const std::string& TransactionStatus::_internal_proposals(int index) const {
  return proposals_.Get(index);
}
inline const std::string& TransactionStatus::proposals(int index) const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionStatus.proposals)
  return _internal_proposals(index);
}
inline std::string* TransactionStatus::mutable_proposals(int index) {
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionStatus.proposals)
  return proposals_.Mutable(index);
}
inline void TransactionStatus::set_proposals(int index, const std::string& value) {
  proposals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionStatus.proposals)
}
inline void TransactionStatus::set_proposals(int index, std::string&& value) {
  proposals_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionStatus.proposals)
}
inline void TransactionStatus::set_proposals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.config.v2.TransactionStatus.proposals)
}
inline void TransactionStatus::set_proposals(int index, const char* value, size_t size) {
  proposals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.config.v2.TransactionStatus.proposals)
}
inline std::string* TransactionStatus::_internal_add_proposals() {
  return proposals_.Add();
}
inline void TransactionStatus::add_proposals(const std::string& value) {
  proposals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.config.v2.TransactionStatus.proposals)
}
inline void TransactionStatus::add_proposals(std::string&& value) {
  proposals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.config.v2.TransactionStatus.proposals)
}
inline void TransactionStatus::add_proposals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  proposals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.config.v2.TransactionStatus.proposals)
}
inline void TransactionStatus::add_proposals(const char* value, size_t size) {
  proposals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.config.v2.TransactionStatus.proposals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransactionStatus::proposals() const {
  // @@protoc_insertion_point(field_list:onos.config.v2.TransactionStatus.proposals)
  return proposals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransactionStatus::mutable_proposals() {
  // @@protoc_insertion_point(field_mutable_list:onos.config.v2.TransactionStatus.proposals)
  return &proposals_;
}

// .onos.config.v2.TransactionStatus.State state = 3;
inline void TransactionStatus::clear_state() {
  state_ = 0;
}
inline ::onos::config::v2::TransactionStatus_State TransactionStatus::_internal_state() const {
  return static_cast< ::onos::config::v2::TransactionStatus_State >(state_);
}
inline ::onos::config::v2::TransactionStatus_State TransactionStatus::state() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionStatus.state)
  return _internal_state();
}
inline void TransactionStatus::_internal_set_state(::onos::config::v2::TransactionStatus_State value) {
  
  state_ = value;
}
inline void TransactionStatus::set_state(::onos::config::v2::TransactionStatus_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionStatus.state)
}

// .onos.config.v2.Failure failure = 4;
inline bool TransactionStatus::_internal_has_failure() const {
  return this != internal_default_instance() && failure_ != nullptr;
}
inline bool TransactionStatus::has_failure() const {
  return _internal_has_failure();
}
inline const ::onos::config::v2::Failure& TransactionStatus::_internal_failure() const {
  const ::onos::config::v2::Failure* p = failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::Failure&>(
      ::onos::config::v2::_Failure_default_instance_);
}
inline const ::onos::config::v2::Failure& TransactionStatus::failure() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionStatus.failure)
  return _internal_failure();
}
inline void TransactionStatus::unsafe_arena_set_allocated_failure(
    ::onos::config::v2::Failure* failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  failure_ = failure;
  if (failure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionStatus.failure)
}
inline ::onos::config::v2::Failure* TransactionStatus::release_failure() {
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::Failure* TransactionStatus::unsafe_arena_release_failure() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionStatus.failure)
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
  return temp;
}
inline ::onos::config::v2::Failure* TransactionStatus::_internal_mutable_failure() {
  
  if (failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::Failure>(GetArenaForAllocation());
    failure_ = p;
  }
  return failure_;
}
inline ::onos::config::v2::Failure* TransactionStatus::mutable_failure() {
  ::onos::config::v2::Failure* _msg = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionStatus.failure)
  return _msg;
}
inline void TransactionStatus::set_allocated_failure(::onos::config::v2::Failure* failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  if (failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure));
    if (message_arena != submessage_arena) {
      failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure, submessage_arena);
    }
    
  } else {
    
  }
  failure_ = failure;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionStatus.failure)
}

// -------------------------------------------------------------------

// TransactionPhases

// .onos.config.v2.TransactionInitializePhase initialize = 1;
inline bool TransactionPhases::_internal_has_initialize() const {
  return this != internal_default_instance() && initialize_ != nullptr;
}
inline bool TransactionPhases::has_initialize() const {
  return _internal_has_initialize();
}
inline void TransactionPhases::clear_initialize() {
  if (GetArenaForAllocation() == nullptr && initialize_ != nullptr) {
    delete initialize_;
  }
  initialize_ = nullptr;
}
inline const ::onos::config::v2::TransactionInitializePhase& TransactionPhases::_internal_initialize() const {
  const ::onos::config::v2::TransactionInitializePhase* p = initialize_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionInitializePhase&>(
      ::onos::config::v2::_TransactionInitializePhase_default_instance_);
}
inline const ::onos::config::v2::TransactionInitializePhase& TransactionPhases::initialize() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhases.initialize)
  return _internal_initialize();
}
inline void TransactionPhases::unsafe_arena_set_allocated_initialize(
    ::onos::config::v2::TransactionInitializePhase* initialize) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initialize_);
  }
  initialize_ = initialize;
  if (initialize) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhases.initialize)
}
inline ::onos::config::v2::TransactionInitializePhase* TransactionPhases::release_initialize() {
  
  ::onos::config::v2::TransactionInitializePhase* temp = initialize_;
  initialize_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionInitializePhase* TransactionPhases::unsafe_arena_release_initialize() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhases.initialize)
  
  ::onos::config::v2::TransactionInitializePhase* temp = initialize_;
  initialize_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionInitializePhase* TransactionPhases::_internal_mutable_initialize() {
  
  if (initialize_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionInitializePhase>(GetArenaForAllocation());
    initialize_ = p;
  }
  return initialize_;
}
inline ::onos::config::v2::TransactionInitializePhase* TransactionPhases::mutable_initialize() {
  ::onos::config::v2::TransactionInitializePhase* _msg = _internal_mutable_initialize();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhases.initialize)
  return _msg;
}
inline void TransactionPhases::set_allocated_initialize(::onos::config::v2::TransactionInitializePhase* initialize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete initialize_;
  }
  if (initialize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionInitializePhase>::GetOwningArena(initialize);
    if (message_arena != submessage_arena) {
      initialize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initialize, submessage_arena);
    }
    
  } else {
    
  }
  initialize_ = initialize;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhases.initialize)
}

// .onos.config.v2.TransactionValidatePhase validate = 2;
inline bool TransactionPhases::_internal_has_validate() const {
  return this != internal_default_instance() && validate_ != nullptr;
}
inline bool TransactionPhases::has_validate() const {
  return _internal_has_validate();
}
inline void TransactionPhases::clear_validate() {
  if (GetArenaForAllocation() == nullptr && validate_ != nullptr) {
    delete validate_;
  }
  validate_ = nullptr;
}
inline const ::onos::config::v2::TransactionValidatePhase& TransactionPhases::_internal_validate() const {
  const ::onos::config::v2::TransactionValidatePhase* p = validate_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionValidatePhase&>(
      ::onos::config::v2::_TransactionValidatePhase_default_instance_);
}
inline const ::onos::config::v2::TransactionValidatePhase& TransactionPhases::validate() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhases.validate)
  return _internal_validate();
}
inline void TransactionPhases::unsafe_arena_set_allocated_validate(
    ::onos::config::v2::TransactionValidatePhase* validate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(validate_);
  }
  validate_ = validate;
  if (validate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhases.validate)
}
inline ::onos::config::v2::TransactionValidatePhase* TransactionPhases::release_validate() {
  
  ::onos::config::v2::TransactionValidatePhase* temp = validate_;
  validate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionValidatePhase* TransactionPhases::unsafe_arena_release_validate() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhases.validate)
  
  ::onos::config::v2::TransactionValidatePhase* temp = validate_;
  validate_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionValidatePhase* TransactionPhases::_internal_mutable_validate() {
  
  if (validate_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionValidatePhase>(GetArenaForAllocation());
    validate_ = p;
  }
  return validate_;
}
inline ::onos::config::v2::TransactionValidatePhase* TransactionPhases::mutable_validate() {
  ::onos::config::v2::TransactionValidatePhase* _msg = _internal_mutable_validate();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhases.validate)
  return _msg;
}
inline void TransactionPhases::set_allocated_validate(::onos::config::v2::TransactionValidatePhase* validate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete validate_;
  }
  if (validate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionValidatePhase>::GetOwningArena(validate);
    if (message_arena != submessage_arena) {
      validate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validate, submessage_arena);
    }
    
  } else {
    
  }
  validate_ = validate;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhases.validate)
}

// .onos.config.v2.TransactionCommitPhase commit = 3;
inline bool TransactionPhases::_internal_has_commit() const {
  return this != internal_default_instance() && commit_ != nullptr;
}
inline bool TransactionPhases::has_commit() const {
  return _internal_has_commit();
}
inline void TransactionPhases::clear_commit() {
  if (GetArenaForAllocation() == nullptr && commit_ != nullptr) {
    delete commit_;
  }
  commit_ = nullptr;
}
inline const ::onos::config::v2::TransactionCommitPhase& TransactionPhases::_internal_commit() const {
  const ::onos::config::v2::TransactionCommitPhase* p = commit_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionCommitPhase&>(
      ::onos::config::v2::_TransactionCommitPhase_default_instance_);
}
inline const ::onos::config::v2::TransactionCommitPhase& TransactionPhases::commit() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhases.commit)
  return _internal_commit();
}
inline void TransactionPhases::unsafe_arena_set_allocated_commit(
    ::onos::config::v2::TransactionCommitPhase* commit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_);
  }
  commit_ = commit;
  if (commit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhases.commit)
}
inline ::onos::config::v2::TransactionCommitPhase* TransactionPhases::release_commit() {
  
  ::onos::config::v2::TransactionCommitPhase* temp = commit_;
  commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionCommitPhase* TransactionPhases::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhases.commit)
  
  ::onos::config::v2::TransactionCommitPhase* temp = commit_;
  commit_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionCommitPhase* TransactionPhases::_internal_mutable_commit() {
  
  if (commit_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionCommitPhase>(GetArenaForAllocation());
    commit_ = p;
  }
  return commit_;
}
inline ::onos::config::v2::TransactionCommitPhase* TransactionPhases::mutable_commit() {
  ::onos::config::v2::TransactionCommitPhase* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhases.commit)
  return _msg;
}
inline void TransactionPhases::set_allocated_commit(::onos::config::v2::TransactionCommitPhase* commit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commit_;
  }
  if (commit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionCommitPhase>::GetOwningArena(commit);
    if (message_arena != submessage_arena) {
      commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commit, submessage_arena);
    }
    
  } else {
    
  }
  commit_ = commit;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhases.commit)
}

// .onos.config.v2.TransactionApplyPhase apply = 4;
inline bool TransactionPhases::_internal_has_apply() const {
  return this != internal_default_instance() && apply_ != nullptr;
}
inline bool TransactionPhases::has_apply() const {
  return _internal_has_apply();
}
inline void TransactionPhases::clear_apply() {
  if (GetArenaForAllocation() == nullptr && apply_ != nullptr) {
    delete apply_;
  }
  apply_ = nullptr;
}
inline const ::onos::config::v2::TransactionApplyPhase& TransactionPhases::_internal_apply() const {
  const ::onos::config::v2::TransactionApplyPhase* p = apply_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionApplyPhase&>(
      ::onos::config::v2::_TransactionApplyPhase_default_instance_);
}
inline const ::onos::config::v2::TransactionApplyPhase& TransactionPhases::apply() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhases.apply)
  return _internal_apply();
}
inline void TransactionPhases::unsafe_arena_set_allocated_apply(
    ::onos::config::v2::TransactionApplyPhase* apply) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(apply_);
  }
  apply_ = apply;
  if (apply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhases.apply)
}
inline ::onos::config::v2::TransactionApplyPhase* TransactionPhases::release_apply() {
  
  ::onos::config::v2::TransactionApplyPhase* temp = apply_;
  apply_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionApplyPhase* TransactionPhases::unsafe_arena_release_apply() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhases.apply)
  
  ::onos::config::v2::TransactionApplyPhase* temp = apply_;
  apply_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionApplyPhase* TransactionPhases::_internal_mutable_apply() {
  
  if (apply_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionApplyPhase>(GetArenaForAllocation());
    apply_ = p;
  }
  return apply_;
}
inline ::onos::config::v2::TransactionApplyPhase* TransactionPhases::mutable_apply() {
  ::onos::config::v2::TransactionApplyPhase* _msg = _internal_mutable_apply();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhases.apply)
  return _msg;
}
inline void TransactionPhases::set_allocated_apply(::onos::config::v2::TransactionApplyPhase* apply) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete apply_;
  }
  if (apply) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionApplyPhase>::GetOwningArena(apply);
    if (message_arena != submessage_arena) {
      apply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apply, submessage_arena);
    }
    
  } else {
    
  }
  apply_ = apply;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhases.apply)
}

// .onos.config.v2.TransactionAbortPhase abort = 5;
inline bool TransactionPhases::_internal_has_abort() const {
  return this != internal_default_instance() && abort_ != nullptr;
}
inline bool TransactionPhases::has_abort() const {
  return _internal_has_abort();
}
inline void TransactionPhases::clear_abort() {
  if (GetArenaForAllocation() == nullptr && abort_ != nullptr) {
    delete abort_;
  }
  abort_ = nullptr;
}
inline const ::onos::config::v2::TransactionAbortPhase& TransactionPhases::_internal_abort() const {
  const ::onos::config::v2::TransactionAbortPhase* p = abort_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionAbortPhase&>(
      ::onos::config::v2::_TransactionAbortPhase_default_instance_);
}
inline const ::onos::config::v2::TransactionAbortPhase& TransactionPhases::abort() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhases.abort)
  return _internal_abort();
}
inline void TransactionPhases::unsafe_arena_set_allocated_abort(
    ::onos::config::v2::TransactionAbortPhase* abort) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abort_);
  }
  abort_ = abort;
  if (abort) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhases.abort)
}
inline ::onos::config::v2::TransactionAbortPhase* TransactionPhases::release_abort() {
  
  ::onos::config::v2::TransactionAbortPhase* temp = abort_;
  abort_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionAbortPhase* TransactionPhases::unsafe_arena_release_abort() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhases.abort)
  
  ::onos::config::v2::TransactionAbortPhase* temp = abort_;
  abort_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionAbortPhase* TransactionPhases::_internal_mutable_abort() {
  
  if (abort_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionAbortPhase>(GetArenaForAllocation());
    abort_ = p;
  }
  return abort_;
}
inline ::onos::config::v2::TransactionAbortPhase* TransactionPhases::mutable_abort() {
  ::onos::config::v2::TransactionAbortPhase* _msg = _internal_mutable_abort();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhases.abort)
  return _msg;
}
inline void TransactionPhases::set_allocated_abort(::onos::config::v2::TransactionAbortPhase* abort) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete abort_;
  }
  if (abort) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionAbortPhase>::GetOwningArena(abort);
    if (message_arena != submessage_arena) {
      abort = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abort, submessage_arena);
    }
    
  } else {
    
  }
  abort_ = abort;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhases.abort)
}

// -------------------------------------------------------------------

// TransactionPhaseStatus

// .google.protobuf.Timestamp start = 1 [(.gogoproto.stdtime) = true];
inline bool TransactionPhaseStatus::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool TransactionPhaseStatus::has_start() const {
  return _internal_has_start();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TransactionPhaseStatus::_internal_start() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TransactionPhaseStatus::start() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhaseStatus.start)
  return _internal_start();
}
inline void TransactionPhaseStatus::unsafe_arena_set_allocated_start(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhaseStatus.start)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::release_start() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhaseStatus.start)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::mutable_start() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhaseStatus.start)
  return _msg;
}
inline void TransactionPhaseStatus::set_allocated_start(::PROTOBUF_NAMESPACE_ID::Timestamp* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhaseStatus.start)
}

// .google.protobuf.Timestamp end = 2 [(.gogoproto.stdtime) = true];
inline bool TransactionPhaseStatus::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool TransactionPhaseStatus::has_end() const {
  return _internal_has_end();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TransactionPhaseStatus::_internal_end() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TransactionPhaseStatus::end() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionPhaseStatus.end)
  return _internal_end();
}
inline void TransactionPhaseStatus::unsafe_arena_set_allocated_end(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionPhaseStatus.end)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::release_end() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionPhaseStatus.end)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TransactionPhaseStatus::mutable_end() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionPhaseStatus.end)
  return _msg;
}
inline void TransactionPhaseStatus::set_allocated_end(::PROTOBUF_NAMESPACE_ID::Timestamp* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionPhaseStatus.end)
}

// -------------------------------------------------------------------

// TransactionInitializePhase

// .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool TransactionInitializePhase::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool TransactionInitializePhase::has_status() const {
  return _internal_has_status();
}
inline void TransactionInitializePhase::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionInitializePhase::_internal_status() const {
  const ::onos::config::v2::TransactionPhaseStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionPhaseStatus&>(
      ::onos::config::v2::_TransactionPhaseStatus_default_instance_);
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionInitializePhase::status() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionInitializePhase.status)
  return _internal_status();
}
inline void TransactionInitializePhase::unsafe_arena_set_allocated_status(
    ::onos::config::v2::TransactionPhaseStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionInitializePhase.status)
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionInitializePhase::release_status() {
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionInitializePhase::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionInitializePhase.status)
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionInitializePhase::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionPhaseStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionInitializePhase::mutable_status() {
  ::onos::config::v2::TransactionPhaseStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionInitializePhase.status)
  return _msg;
}
inline void TransactionInitializePhase::set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionPhaseStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionInitializePhase.status)
}

// .onos.config.v2.TransactionInitializePhase.State state = 2;
inline void TransactionInitializePhase::clear_state() {
  state_ = 0;
}
inline ::onos::config::v2::TransactionInitializePhase_State TransactionInitializePhase::_internal_state() const {
  return static_cast< ::onos::config::v2::TransactionInitializePhase_State >(state_);
}
inline ::onos::config::v2::TransactionInitializePhase_State TransactionInitializePhase::state() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionInitializePhase.state)
  return _internal_state();
}
inline void TransactionInitializePhase::_internal_set_state(::onos::config::v2::TransactionInitializePhase_State value) {
  
  state_ = value;
}
inline void TransactionInitializePhase::set_state(::onos::config::v2::TransactionInitializePhase_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionInitializePhase.state)
}

// .onos.config.v2.Failure failure = 3;
inline bool TransactionInitializePhase::_internal_has_failure() const {
  return this != internal_default_instance() && failure_ != nullptr;
}
inline bool TransactionInitializePhase::has_failure() const {
  return _internal_has_failure();
}
inline const ::onos::config::v2::Failure& TransactionInitializePhase::_internal_failure() const {
  const ::onos::config::v2::Failure* p = failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::Failure&>(
      ::onos::config::v2::_Failure_default_instance_);
}
inline const ::onos::config::v2::Failure& TransactionInitializePhase::failure() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionInitializePhase.failure)
  return _internal_failure();
}
inline void TransactionInitializePhase::unsafe_arena_set_allocated_failure(
    ::onos::config::v2::Failure* failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  failure_ = failure;
  if (failure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionInitializePhase.failure)
}
inline ::onos::config::v2::Failure* TransactionInitializePhase::release_failure() {
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::Failure* TransactionInitializePhase::unsafe_arena_release_failure() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionInitializePhase.failure)
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
  return temp;
}
inline ::onos::config::v2::Failure* TransactionInitializePhase::_internal_mutable_failure() {
  
  if (failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::Failure>(GetArenaForAllocation());
    failure_ = p;
  }
  return failure_;
}
inline ::onos::config::v2::Failure* TransactionInitializePhase::mutable_failure() {
  ::onos::config::v2::Failure* _msg = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionInitializePhase.failure)
  return _msg;
}
inline void TransactionInitializePhase::set_allocated_failure(::onos::config::v2::Failure* failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  if (failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure));
    if (message_arena != submessage_arena) {
      failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure, submessage_arena);
    }
    
  } else {
    
  }
  failure_ = failure;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionInitializePhase.failure)
}

// -------------------------------------------------------------------

// TransactionValidatePhase

// .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool TransactionValidatePhase::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool TransactionValidatePhase::has_status() const {
  return _internal_has_status();
}
inline void TransactionValidatePhase::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionValidatePhase::_internal_status() const {
  const ::onos::config::v2::TransactionPhaseStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionPhaseStatus&>(
      ::onos::config::v2::_TransactionPhaseStatus_default_instance_);
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionValidatePhase::status() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionValidatePhase.status)
  return _internal_status();
}
inline void TransactionValidatePhase::unsafe_arena_set_allocated_status(
    ::onos::config::v2::TransactionPhaseStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionValidatePhase.status)
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionValidatePhase::release_status() {
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionValidatePhase::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionValidatePhase.status)
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionValidatePhase::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionPhaseStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionValidatePhase::mutable_status() {
  ::onos::config::v2::TransactionPhaseStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionValidatePhase.status)
  return _msg;
}
inline void TransactionValidatePhase::set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionPhaseStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionValidatePhase.status)
}

// .onos.config.v2.TransactionValidatePhase.State state = 2;
inline void TransactionValidatePhase::clear_state() {
  state_ = 0;
}
inline ::onos::config::v2::TransactionValidatePhase_State TransactionValidatePhase::_internal_state() const {
  return static_cast< ::onos::config::v2::TransactionValidatePhase_State >(state_);
}
inline ::onos::config::v2::TransactionValidatePhase_State TransactionValidatePhase::state() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionValidatePhase.state)
  return _internal_state();
}
inline void TransactionValidatePhase::_internal_set_state(::onos::config::v2::TransactionValidatePhase_State value) {
  
  state_ = value;
}
inline void TransactionValidatePhase::set_state(::onos::config::v2::TransactionValidatePhase_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionValidatePhase.state)
}

// .onos.config.v2.Failure failure = 3;
inline bool TransactionValidatePhase::_internal_has_failure() const {
  return this != internal_default_instance() && failure_ != nullptr;
}
inline bool TransactionValidatePhase::has_failure() const {
  return _internal_has_failure();
}
inline const ::onos::config::v2::Failure& TransactionValidatePhase::_internal_failure() const {
  const ::onos::config::v2::Failure* p = failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::Failure&>(
      ::onos::config::v2::_Failure_default_instance_);
}
inline const ::onos::config::v2::Failure& TransactionValidatePhase::failure() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionValidatePhase.failure)
  return _internal_failure();
}
inline void TransactionValidatePhase::unsafe_arena_set_allocated_failure(
    ::onos::config::v2::Failure* failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  failure_ = failure;
  if (failure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionValidatePhase.failure)
}
inline ::onos::config::v2::Failure* TransactionValidatePhase::release_failure() {
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::Failure* TransactionValidatePhase::unsafe_arena_release_failure() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionValidatePhase.failure)
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
  return temp;
}
inline ::onos::config::v2::Failure* TransactionValidatePhase::_internal_mutable_failure() {
  
  if (failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::Failure>(GetArenaForAllocation());
    failure_ = p;
  }
  return failure_;
}
inline ::onos::config::v2::Failure* TransactionValidatePhase::mutable_failure() {
  ::onos::config::v2::Failure* _msg = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionValidatePhase.failure)
  return _msg;
}
inline void TransactionValidatePhase::set_allocated_failure(::onos::config::v2::Failure* failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  if (failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure));
    if (message_arena != submessage_arena) {
      failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure, submessage_arena);
    }
    
  } else {
    
  }
  failure_ = failure;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionValidatePhase.failure)
}

// -------------------------------------------------------------------

// TransactionCommitPhase

// .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool TransactionCommitPhase::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool TransactionCommitPhase::has_status() const {
  return _internal_has_status();
}
inline void TransactionCommitPhase::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionCommitPhase::_internal_status() const {
  const ::onos::config::v2::TransactionPhaseStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionPhaseStatus&>(
      ::onos::config::v2::_TransactionPhaseStatus_default_instance_);
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionCommitPhase::status() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionCommitPhase.status)
  return _internal_status();
}
inline void TransactionCommitPhase::unsafe_arena_set_allocated_status(
    ::onos::config::v2::TransactionPhaseStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionCommitPhase.status)
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionCommitPhase::release_status() {
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionCommitPhase::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionCommitPhase.status)
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionCommitPhase::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionPhaseStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionCommitPhase::mutable_status() {
  ::onos::config::v2::TransactionPhaseStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionCommitPhase.status)
  return _msg;
}
inline void TransactionCommitPhase::set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionPhaseStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionCommitPhase.status)
}

// .onos.config.v2.TransactionCommitPhase.State state = 2;
inline void TransactionCommitPhase::clear_state() {
  state_ = 0;
}
inline ::onos::config::v2::TransactionCommitPhase_State TransactionCommitPhase::_internal_state() const {
  return static_cast< ::onos::config::v2::TransactionCommitPhase_State >(state_);
}
inline ::onos::config::v2::TransactionCommitPhase_State TransactionCommitPhase::state() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionCommitPhase.state)
  return _internal_state();
}
inline void TransactionCommitPhase::_internal_set_state(::onos::config::v2::TransactionCommitPhase_State value) {
  
  state_ = value;
}
inline void TransactionCommitPhase::set_state(::onos::config::v2::TransactionCommitPhase_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionCommitPhase.state)
}

// -------------------------------------------------------------------

// TransactionApplyPhase

// .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool TransactionApplyPhase::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool TransactionApplyPhase::has_status() const {
  return _internal_has_status();
}
inline void TransactionApplyPhase::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionApplyPhase::_internal_status() const {
  const ::onos::config::v2::TransactionPhaseStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionPhaseStatus&>(
      ::onos::config::v2::_TransactionPhaseStatus_default_instance_);
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionApplyPhase::status() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionApplyPhase.status)
  return _internal_status();
}
inline void TransactionApplyPhase::unsafe_arena_set_allocated_status(
    ::onos::config::v2::TransactionPhaseStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionApplyPhase.status)
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionApplyPhase::release_status() {
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionApplyPhase::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionApplyPhase.status)
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionApplyPhase::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionPhaseStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionApplyPhase::mutable_status() {
  ::onos::config::v2::TransactionPhaseStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionApplyPhase.status)
  return _msg;
}
inline void TransactionApplyPhase::set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionPhaseStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionApplyPhase.status)
}

// .onos.config.v2.TransactionApplyPhase.State state = 2;
inline void TransactionApplyPhase::clear_state() {
  state_ = 0;
}
inline ::onos::config::v2::TransactionApplyPhase_State TransactionApplyPhase::_internal_state() const {
  return static_cast< ::onos::config::v2::TransactionApplyPhase_State >(state_);
}
inline ::onos::config::v2::TransactionApplyPhase_State TransactionApplyPhase::state() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionApplyPhase.state)
  return _internal_state();
}
inline void TransactionApplyPhase::_internal_set_state(::onos::config::v2::TransactionApplyPhase_State value) {
  
  state_ = value;
}
inline void TransactionApplyPhase::set_state(::onos::config::v2::TransactionApplyPhase_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionApplyPhase.state)
}

// .onos.config.v2.Failure failure = 3;
inline bool TransactionApplyPhase::_internal_has_failure() const {
  return this != internal_default_instance() && failure_ != nullptr;
}
inline bool TransactionApplyPhase::has_failure() const {
  return _internal_has_failure();
}
inline const ::onos::config::v2::Failure& TransactionApplyPhase::_internal_failure() const {
  const ::onos::config::v2::Failure* p = failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::Failure&>(
      ::onos::config::v2::_Failure_default_instance_);
}
inline const ::onos::config::v2::Failure& TransactionApplyPhase::failure() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionApplyPhase.failure)
  return _internal_failure();
}
inline void TransactionApplyPhase::unsafe_arena_set_allocated_failure(
    ::onos::config::v2::Failure* failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  failure_ = failure;
  if (failure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionApplyPhase.failure)
}
inline ::onos::config::v2::Failure* TransactionApplyPhase::release_failure() {
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::Failure* TransactionApplyPhase::unsafe_arena_release_failure() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionApplyPhase.failure)
  
  ::onos::config::v2::Failure* temp = failure_;
  failure_ = nullptr;
  return temp;
}
inline ::onos::config::v2::Failure* TransactionApplyPhase::_internal_mutable_failure() {
  
  if (failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::Failure>(GetArenaForAllocation());
    failure_ = p;
  }
  return failure_;
}
inline ::onos::config::v2::Failure* TransactionApplyPhase::mutable_failure() {
  ::onos::config::v2::Failure* _msg = _internal_mutable_failure();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionApplyPhase.failure)
  return _msg;
}
inline void TransactionApplyPhase::set_allocated_failure(::onos::config::v2::Failure* failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure_);
  }
  if (failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failure));
    if (message_arena != submessage_arena) {
      failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failure, submessage_arena);
    }
    
  } else {
    
  }
  failure_ = failure;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionApplyPhase.failure)
}

// -------------------------------------------------------------------

// TransactionAbortPhase

// .onos.config.v2.TransactionPhaseStatus status = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool TransactionAbortPhase::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool TransactionAbortPhase::has_status() const {
  return _internal_has_status();
}
inline void TransactionAbortPhase::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionAbortPhase::_internal_status() const {
  const ::onos::config::v2::TransactionPhaseStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::TransactionPhaseStatus&>(
      ::onos::config::v2::_TransactionPhaseStatus_default_instance_);
}
inline const ::onos::config::v2::TransactionPhaseStatus& TransactionAbortPhase::status() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionAbortPhase.status)
  return _internal_status();
}
inline void TransactionAbortPhase::unsafe_arena_set_allocated_status(
    ::onos::config::v2::TransactionPhaseStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionAbortPhase.status)
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionAbortPhase::release_status() {
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionAbortPhase::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionAbortPhase.status)
  
  ::onos::config::v2::TransactionPhaseStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionAbortPhase::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::TransactionPhaseStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::config::v2::TransactionPhaseStatus* TransactionAbortPhase::mutable_status() {
  ::onos::config::v2::TransactionPhaseStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionAbortPhase.status)
  return _msg;
}
inline void TransactionAbortPhase::set_allocated_status(::onos::config::v2::TransactionPhaseStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::TransactionPhaseStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionAbortPhase.status)
}

// .onos.config.v2.TransactionAbortPhase.State state = 2;
inline void TransactionAbortPhase::clear_state() {
  state_ = 0;
}
inline ::onos::config::v2::TransactionAbortPhase_State TransactionAbortPhase::_internal_state() const {
  return static_cast< ::onos::config::v2::TransactionAbortPhase_State >(state_);
}
inline ::onos::config::v2::TransactionAbortPhase_State TransactionAbortPhase::state() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionAbortPhase.state)
  return _internal_state();
}
inline void TransactionAbortPhase::_internal_set_state(::onos::config::v2::TransactionAbortPhase_State value) {
  
  state_ = value;
}
inline void TransactionAbortPhase::set_state(::onos::config::v2::TransactionAbortPhase_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionAbortPhase.state)
}

// -------------------------------------------------------------------

// TransactionEvent

// .onos.config.v2.TransactionEvent.EventType type = 1;
inline void TransactionEvent::clear_type() {
  type_ = 0;
}
inline ::onos::config::v2::TransactionEvent_EventType TransactionEvent::_internal_type() const {
  return static_cast< ::onos::config::v2::TransactionEvent_EventType >(type_);
}
inline ::onos::config::v2::TransactionEvent_EventType TransactionEvent::type() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionEvent.type)
  return _internal_type();
}
inline void TransactionEvent::_internal_set_type(::onos::config::v2::TransactionEvent_EventType value) {
  
  type_ = value;
}
inline void TransactionEvent::set_type(::onos::config::v2::TransactionEvent_EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.config.v2.TransactionEvent.type)
}

// .onos.config.v2.Transaction transaction = 2 [(.gogoproto.nullable) = false];
inline bool TransactionEvent::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionEvent::has_transaction() const {
  return _internal_has_transaction();
}
inline void TransactionEvent::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::onos::config::v2::Transaction& TransactionEvent::_internal_transaction() const {
  const ::onos::config::v2::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::config::v2::Transaction&>(
      ::onos::config::v2::_Transaction_default_instance_);
}
inline const ::onos::config::v2::Transaction& TransactionEvent::transaction() const {
  // @@protoc_insertion_point(field_get:onos.config.v2.TransactionEvent.transaction)
  return _internal_transaction();
}
inline void TransactionEvent::unsafe_arena_set_allocated_transaction(
    ::onos::config::v2::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.config.v2.TransactionEvent.transaction)
}
inline ::onos::config::v2::Transaction* TransactionEvent::release_transaction() {
  
  ::onos::config::v2::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::config::v2::Transaction* TransactionEvent::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:onos.config.v2.TransactionEvent.transaction)
  
  ::onos::config::v2::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::onos::config::v2::Transaction* TransactionEvent::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::config::v2::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::onos::config::v2::Transaction* TransactionEvent::mutable_transaction() {
  ::onos::config::v2::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:onos.config.v2.TransactionEvent.transaction)
  return _msg;
}
inline void TransactionEvent::set_allocated_transaction(::onos::config::v2::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::config::v2::Transaction>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:onos.config.v2.TransactionEvent.transaction)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TargetVersionOverrides

// map<string, .onos.config.v2.TargetTypeVersion> overrides = 1;
inline int TargetVersionOverrides::_internal_overrides_size() const {
  return overrides_.size();
}
inline int TargetVersionOverrides::overrides_size() const {
  return _internal_overrides_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >&
TargetVersionOverrides::_internal_overrides() const {
  return overrides_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >&
TargetVersionOverrides::overrides() const {
  // @@protoc_insertion_point(field_map:onos.config.v2.TargetVersionOverrides.overrides)
  return _internal_overrides();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >*
TargetVersionOverrides::_internal_mutable_overrides() {
  return overrides_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::onos::config::v2::TargetTypeVersion >*
TargetVersionOverrides::mutable_overrides() {
  // @@protoc_insertion_point(field_mutable_map:onos.config.v2.TargetVersionOverrides.overrides)
  return _internal_mutable_overrides();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace config
}  // namespace onos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::onos::config::v2::TransactionStrategy_Synchronicity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionStrategy_Synchronicity>() {
  return ::onos::config::v2::TransactionStrategy_Synchronicity_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionStrategy_Isolation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionStrategy_Isolation>() {
  return ::onos::config::v2::TransactionStrategy_Isolation_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionStatus_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionStatus_State>() {
  return ::onos::config::v2::TransactionStatus_State_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionInitializePhase_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionInitializePhase_State>() {
  return ::onos::config::v2::TransactionInitializePhase_State_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionValidatePhase_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionValidatePhase_State>() {
  return ::onos::config::v2::TransactionValidatePhase_State_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionCommitPhase_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionCommitPhase_State>() {
  return ::onos::config::v2::TransactionCommitPhase_State_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionApplyPhase_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionApplyPhase_State>() {
  return ::onos::config::v2::TransactionApplyPhase_State_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionAbortPhase_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionAbortPhase_State>() {
  return ::onos::config::v2::TransactionAbortPhase_State_descriptor();
}
template <> struct is_proto_enum< ::onos::config::v2::TransactionEvent_EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::config::v2::TransactionEvent_EventType>() {
  return ::onos::config::v2::TransactionEvent_EventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onos_2fconfig_2fv2_2ftransaction_2eproto
