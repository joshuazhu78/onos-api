// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onos/e2t/e2/v1beta1/subscription.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
#include "onos/e2t/e2/v1beta1/e2.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[31]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
namespace onos {
namespace e2t {
namespace e2 {
namespace v1beta1 {
class Acknowledgement;
struct AcknowledgementDefaultTypeInternal;
extern AcknowledgementDefaultTypeInternal _Acknowledgement_default_instance_;
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Channel;
struct ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class ChannelEvent;
struct ChannelEventDefaultTypeInternal;
extern ChannelEventDefaultTypeInternal _ChannelEvent_default_instance_;
class ChannelMeta;
struct ChannelMetaDefaultTypeInternal;
extern ChannelMetaDefaultTypeInternal _ChannelMeta_default_instance_;
class ChannelSpec;
struct ChannelSpecDefaultTypeInternal;
extern ChannelSpecDefaultTypeInternal _ChannelSpec_default_instance_;
class ChannelStatus;
struct ChannelStatusDefaultTypeInternal;
extern ChannelStatusDefaultTypeInternal _ChannelStatus_default_instance_;
class EventTrigger;
struct EventTriggerDefaultTypeInternal;
extern EventTriggerDefaultTypeInternal _EventTrigger_default_instance_;
class GetChannelRequest;
struct GetChannelRequestDefaultTypeInternal;
extern GetChannelRequestDefaultTypeInternal _GetChannelRequest_default_instance_;
class GetChannelResponse;
struct GetChannelResponseDefaultTypeInternal;
extern GetChannelResponseDefaultTypeInternal _GetChannelResponse_default_instance_;
class GetSubscriptionRequest;
struct GetSubscriptionRequestDefaultTypeInternal;
extern GetSubscriptionRequestDefaultTypeInternal _GetSubscriptionRequest_default_instance_;
class GetSubscriptionResponse;
struct GetSubscriptionResponseDefaultTypeInternal;
extern GetSubscriptionResponseDefaultTypeInternal _GetSubscriptionResponse_default_instance_;
class Indication;
struct IndicationDefaultTypeInternal;
extern IndicationDefaultTypeInternal _Indication_default_instance_;
class ListChannelsRequest;
struct ListChannelsRequestDefaultTypeInternal;
extern ListChannelsRequestDefaultTypeInternal _ListChannelsRequest_default_instance_;
class ListChannelsResponse;
struct ListChannelsResponseDefaultTypeInternal;
extern ListChannelsResponseDefaultTypeInternal _ListChannelsResponse_default_instance_;
class ListSubscriptionsRequest;
struct ListSubscriptionsRequestDefaultTypeInternal;
extern ListSubscriptionsRequestDefaultTypeInternal _ListSubscriptionsRequest_default_instance_;
class ListSubscriptionsResponse;
struct ListSubscriptionsResponseDefaultTypeInternal;
extern ListSubscriptionsResponseDefaultTypeInternal _ListSubscriptionsResponse_default_instance_;
class SubscribeRequest;
struct SubscribeRequestDefaultTypeInternal;
extern SubscribeRequestDefaultTypeInternal _SubscribeRequest_default_instance_;
class SubscribeResponse;
struct SubscribeResponseDefaultTypeInternal;
extern SubscribeResponseDefaultTypeInternal _SubscribeResponse_default_instance_;
class Subscription;
struct SubscriptionDefaultTypeInternal;
extern SubscriptionDefaultTypeInternal _Subscription_default_instance_;
class SubscriptionEvent;
struct SubscriptionEventDefaultTypeInternal;
extern SubscriptionEventDefaultTypeInternal _SubscriptionEvent_default_instance_;
class SubscriptionMeta;
struct SubscriptionMetaDefaultTypeInternal;
extern SubscriptionMetaDefaultTypeInternal _SubscriptionMeta_default_instance_;
class SubscriptionSpec;
struct SubscriptionSpecDefaultTypeInternal;
extern SubscriptionSpecDefaultTypeInternal _SubscriptionSpec_default_instance_;
class SubscriptionStatus;
struct SubscriptionStatusDefaultTypeInternal;
extern SubscriptionStatusDefaultTypeInternal _SubscriptionStatus_default_instance_;
class SubsequentAction;
struct SubsequentActionDefaultTypeInternal;
extern SubsequentActionDefaultTypeInternal _SubsequentAction_default_instance_;
class UnsubscribeRequest;
struct UnsubscribeRequestDefaultTypeInternal;
extern UnsubscribeRequestDefaultTypeInternal _UnsubscribeRequest_default_instance_;
class UnsubscribeResponse;
struct UnsubscribeResponseDefaultTypeInternal;
extern UnsubscribeResponseDefaultTypeInternal _UnsubscribeResponse_default_instance_;
class WatchChannelsRequest;
struct WatchChannelsRequestDefaultTypeInternal;
extern WatchChannelsRequestDefaultTypeInternal _WatchChannelsRequest_default_instance_;
class WatchChannelsResponse;
struct WatchChannelsResponseDefaultTypeInternal;
extern WatchChannelsResponseDefaultTypeInternal _WatchChannelsResponse_default_instance_;
class WatchSubscriptionsRequest;
struct WatchSubscriptionsRequestDefaultTypeInternal;
extern WatchSubscriptionsRequestDefaultTypeInternal _WatchSubscriptionsRequest_default_instance_;
class WatchSubscriptionsResponse;
struct WatchSubscriptionsResponseDefaultTypeInternal;
extern WatchSubscriptionsResponseDefaultTypeInternal _WatchSubscriptionsResponse_default_instance_;
}  // namespace v1beta1
}  // namespace e2
}  // namespace e2t
}  // namespace onos
PROTOBUF_NAMESPACE_OPEN
template<> ::onos::e2t::e2::v1beta1::Acknowledgement* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::Acknowledgement>(Arena*);
template<> ::onos::e2t::e2::v1beta1::Action* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::Action>(Arena*);
template<> ::onos::e2t::e2::v1beta1::Channel* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::Channel>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ChannelEvent* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelEvent>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ChannelMeta* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelMeta>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ChannelSpec* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelSpec>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ChannelStatus* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelStatus>(Arena*);
template<> ::onos::e2t::e2::v1beta1::EventTrigger* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::EventTrigger>(Arena*);
template<> ::onos::e2t::e2::v1beta1::GetChannelRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::GetChannelRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::GetChannelResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::GetChannelResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::GetSubscriptionRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::GetSubscriptionRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::GetSubscriptionResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::GetSubscriptionResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::Indication* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::Indication>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ListChannelsRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ListChannelsRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ListChannelsResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ListChannelsResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ListSubscriptionsRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ListSubscriptionsRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::ListSubscriptionsResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::ListSubscriptionsResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubscribeRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscribeRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubscribeResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscribeResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::Subscription* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::Subscription>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubscriptionEvent* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionEvent>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubscriptionMeta* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionMeta>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubscriptionSpec* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionSpec>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubscriptionStatus* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionStatus>(Arena*);
template<> ::onos::e2t::e2::v1beta1::SubsequentAction* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubsequentAction>(Arena*);
template<> ::onos::e2t::e2::v1beta1::UnsubscribeRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::UnsubscribeRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::UnsubscribeResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::UnsubscribeResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::WatchChannelsRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::WatchChannelsRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::WatchChannelsResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::WatchChannelsResponse>(Arena*);
template<> ::onos::e2t::e2::v1beta1::WatchSubscriptionsRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::WatchSubscriptionsRequest>(Arena*);
template<> ::onos::e2t::e2::v1beta1::WatchSubscriptionsResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::v1beta1::WatchSubscriptionsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace onos {
namespace e2t {
namespace e2 {
namespace v1beta1 {

enum ActionType : int {
  ACTION_TYPE_REPORT = 0,
  ACTION_TYPE_INSERT = 1,
  ACTION_TYPE_POLICY = 2,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = ACTION_TYPE_REPORT;
constexpr ActionType ActionType_MAX = ACTION_TYPE_POLICY;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
enum SubsequentActionType : int {
  SUBSEQUENT_ACTION_TYPE_CONTINUE = 0,
  SUBSEQUENT_ACTION_TYPE_WAIT = 1,
  SubsequentActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubsequentActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubsequentActionType_IsValid(int value);
constexpr SubsequentActionType SubsequentActionType_MIN = SUBSEQUENT_ACTION_TYPE_CONTINUE;
constexpr SubsequentActionType SubsequentActionType_MAX = SUBSEQUENT_ACTION_TYPE_WAIT;
constexpr int SubsequentActionType_ARRAYSIZE = SubsequentActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubsequentActionType_descriptor();
template<typename T>
inline const std::string& SubsequentActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubsequentActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubsequentActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubsequentActionType_descriptor(), enum_t_value);
}
inline bool SubsequentActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubsequentActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubsequentActionType>(
    SubsequentActionType_descriptor(), name, value);
}
enum TimeToWait : int {
  TIME_TO_WAIT_ZERO = 0,
  TIME_TO_WAIT_W1MS = 1,
  TIME_TO_WAIT_W2MS = 2,
  TIME_TO_WAIT_W5MS = 3,
  TIME_TO_WAIT_W10MS = 4,
  TIME_TO_WAIT_W20MS = 5,
  TIME_TO_WAIT_W30MS = 6,
  TIME_TO_WAIT_W40MS = 7,
  TIME_TO_WAIT_W50MS = 8,
  TIME_TO_WAIT_W100MS = 9,
  TIME_TO_WAIT_W200MS = 10,
  TIME_TO_WAIT_W500MS = 11,
  TIME_TO_WAIT_W1S = 12,
  TIME_TO_WAIT_W2S = 13,
  TIME_TO_WAIT_W5S = 14,
  TIME_TO_WAIT_W10S = 15,
  TIME_TO_WAIT_W20S = 16,
  TIME_TO_WAIT_W60S = 17,
  TimeToWait_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TimeToWait_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TimeToWait_IsValid(int value);
constexpr TimeToWait TimeToWait_MIN = TIME_TO_WAIT_ZERO;
constexpr TimeToWait TimeToWait_MAX = TIME_TO_WAIT_W60S;
constexpr int TimeToWait_ARRAYSIZE = TimeToWait_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeToWait_descriptor();
template<typename T>
inline const std::string& TimeToWait_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeToWait>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeToWait_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeToWait_descriptor(), enum_t_value);
}
inline bool TimeToWait_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeToWait* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeToWait>(
    TimeToWait_descriptor(), name, value);
}
enum ChannelEventType : int {
  CHANNEL_EVENT_UNKNOWN = 0,
  CHANNEL_CREATED = 1,
  CHANNEL_UPDATED = 2,
  CHANNEL_DELETED = 3,
  CHANNEL_REPLAYED = 4,
  ChannelEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChannelEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChannelEventType_IsValid(int value);
constexpr ChannelEventType ChannelEventType_MIN = CHANNEL_EVENT_UNKNOWN;
constexpr ChannelEventType ChannelEventType_MAX = CHANNEL_REPLAYED;
constexpr int ChannelEventType_ARRAYSIZE = ChannelEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelEventType_descriptor();
template<typename T>
inline const std::string& ChannelEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelEventType_descriptor(), enum_t_value);
}
inline bool ChannelEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelEventType>(
    ChannelEventType_descriptor(), name, value);
}
enum SubscriptionEventType : int {
  SUBSCRIPTION_EVENT_UNKNOWN = 0,
  SUBSCRIPTION_CREATED = 1,
  SUBSCRIPTION_UPDATED = 2,
  SUBSCRIPTION_DELETED = 3,
  SUBSCRIPTION_REPLAYED = 4,
  SubscriptionEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubscriptionEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubscriptionEventType_IsValid(int value);
constexpr SubscriptionEventType SubscriptionEventType_MIN = SUBSCRIPTION_EVENT_UNKNOWN;
constexpr SubscriptionEventType SubscriptionEventType_MAX = SUBSCRIPTION_REPLAYED;
constexpr int SubscriptionEventType_ARRAYSIZE = SubscriptionEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubscriptionEventType_descriptor();
template<typename T>
inline const std::string& SubscriptionEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscriptionEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscriptionEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubscriptionEventType_descriptor(), enum_t_value);
}
inline bool SubscriptionEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubscriptionEventType>(
    SubscriptionEventType_descriptor(), name, value);
}
enum ChannelPhase : int {
  CHANNEL_CLOSED = 0,
  CHANNEL_OPEN = 1,
  ChannelPhase_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChannelPhase_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChannelPhase_IsValid(int value);
constexpr ChannelPhase ChannelPhase_MIN = CHANNEL_CLOSED;
constexpr ChannelPhase ChannelPhase_MAX = CHANNEL_OPEN;
constexpr int ChannelPhase_ARRAYSIZE = ChannelPhase_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelPhase_descriptor();
template<typename T>
inline const std::string& ChannelPhase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelPhase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelPhase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelPhase_descriptor(), enum_t_value);
}
inline bool ChannelPhase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelPhase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelPhase>(
    ChannelPhase_descriptor(), name, value);
}
enum ChannelState : int {
  CHANNEL_PENDING = 0,
  CHANNEL_COMPLETE = 1,
  CHANNEL_FAILED = 2,
  ChannelState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChannelState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChannelState_IsValid(int value);
constexpr ChannelState ChannelState_MIN = CHANNEL_PENDING;
constexpr ChannelState ChannelState_MAX = CHANNEL_FAILED;
constexpr int ChannelState_ARRAYSIZE = ChannelState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelState_descriptor();
template<typename T>
inline const std::string& ChannelState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelState_descriptor(), enum_t_value);
}
inline bool ChannelState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelState>(
    ChannelState_descriptor(), name, value);
}
enum SubscriptionPhase : int {
  SUBSCRIPTION_CLOSED = 0,
  SUBSCRIPTION_OPEN = 1,
  SubscriptionPhase_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubscriptionPhase_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubscriptionPhase_IsValid(int value);
constexpr SubscriptionPhase SubscriptionPhase_MIN = SUBSCRIPTION_CLOSED;
constexpr SubscriptionPhase SubscriptionPhase_MAX = SUBSCRIPTION_OPEN;
constexpr int SubscriptionPhase_ARRAYSIZE = SubscriptionPhase_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubscriptionPhase_descriptor();
template<typename T>
inline const std::string& SubscriptionPhase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscriptionPhase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscriptionPhase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubscriptionPhase_descriptor(), enum_t_value);
}
inline bool SubscriptionPhase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionPhase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubscriptionPhase>(
    SubscriptionPhase_descriptor(), name, value);
}
enum SubscriptionState : int {
  SUBSCRIPTION_PENDING = 0,
  SUBSCRIPTION_COMPLETE = 1,
  SUBSCRIPTION_FAILED = 2,
  SubscriptionState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubscriptionState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubscriptionState_IsValid(int value);
constexpr SubscriptionState SubscriptionState_MIN = SUBSCRIPTION_PENDING;
constexpr SubscriptionState SubscriptionState_MAX = SUBSCRIPTION_FAILED;
constexpr int SubscriptionState_ARRAYSIZE = SubscriptionState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubscriptionState_descriptor();
template<typename T>
inline const std::string& SubscriptionState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscriptionState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscriptionState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubscriptionState_descriptor(), enum_t_value);
}
inline bool SubscriptionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscriptionState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubscriptionState>(
    SubscriptionState_descriptor(), name, value);
}
// ===================================================================

class SubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubscribeRequest) */ {
 public:
  inline SubscribeRequest() : SubscribeRequest(nullptr) {}
  ~SubscribeRequest() override;
  explicit constexpr SubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeRequest(const SubscribeRequest& from);
  SubscribeRequest(SubscribeRequest&& from) noexcept
    : SubscribeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeRequest& operator=(const SubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeRequest& operator=(SubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeRequest*>(
               &_SubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SubscribeRequest& a, SubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubscribeRequest";
  }
  protected:
  explicit SubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 2,
    kHeadersFieldNumber = 1,
    kSubscriptionFieldNumber = 3,
    kTransactionTimeoutFieldNumber = 4,
  };
  // string transaction_id = 2 [(.gogoproto.customname) = "TransactionID", (.gogoproto.casttype) = "TransactionID"];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // .onos.e2t.e2.v1beta1.RequestHeaders headers = 1 [(.gogoproto.nullable) = false];
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::onos::e2t::e2::v1beta1::RequestHeaders& headers() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::RequestHeaders* release_headers();
  ::onos::e2t::e2::v1beta1::RequestHeaders* mutable_headers();
  void set_allocated_headers(::onos::e2t::e2::v1beta1::RequestHeaders* headers);
  private:
  const ::onos::e2t::e2::v1beta1::RequestHeaders& _internal_headers() const;
  ::onos::e2t::e2::v1beta1::RequestHeaders* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::onos::e2t::e2::v1beta1::RequestHeaders* headers);
  ::onos::e2t::e2::v1beta1::RequestHeaders* unsafe_arena_release_headers();

  // .onos.e2t.e2.v1beta1.SubscriptionSpec subscription = 3 [(.gogoproto.nullable) = false];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec& subscription() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubscriptionSpec* release_subscription();
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* mutable_subscription();
  void set_allocated_subscription(::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription);
  private:
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec& _internal_subscription() const;
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription);
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* unsafe_arena_release_subscription();

  // .google.protobuf.Duration transaction_timeout = 4 [(.gogoproto.stdduration) = true];
  bool has_transaction_timeout() const;
  private:
  bool _internal_has_transaction_timeout() const;
  public:
  void clear_transaction_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& transaction_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_transaction_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_transaction_timeout();
  void set_allocated_transaction_timeout(::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_transaction_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_transaction_timeout();
  public:
  void unsafe_arena_set_allocated_transaction_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_transaction_timeout();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::onos::e2t::e2::v1beta1::RequestHeaders* headers_;
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription_;
  ::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscribeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubscribeResponse) */ {
 public:
  inline SubscribeResponse() : SubscribeResponse(nullptr) {}
  ~SubscribeResponse() override;
  explicit constexpr SubscribeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeResponse(const SubscribeResponse& from);
  SubscribeResponse(SubscribeResponse&& from) noexcept
    : SubscribeResponse() {
    *this = ::std::move(from);
  }

  inline SubscribeResponse& operator=(const SubscribeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeResponse& operator=(SubscribeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeResponse& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kAck = 2,
    kIndication = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const SubscribeResponse* internal_default_instance() {
    return reinterpret_cast<const SubscribeResponse*>(
               &_SubscribeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubscribeResponse& a, SubscribeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubscribeResponse";
  }
  protected:
  explicit SubscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 1,
    kAckFieldNumber = 2,
    kIndicationFieldNumber = 3,
  };
  // .onos.e2t.e2.v1beta1.ResponseHeaders headers = 1 [(.gogoproto.nullable) = false];
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::onos::e2t::e2::v1beta1::ResponseHeaders& headers() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ResponseHeaders* release_headers();
  ::onos::e2t::e2::v1beta1::ResponseHeaders* mutable_headers();
  void set_allocated_headers(::onos::e2t::e2::v1beta1::ResponseHeaders* headers);
  private:
  const ::onos::e2t::e2::v1beta1::ResponseHeaders& _internal_headers() const;
  ::onos::e2t::e2::v1beta1::ResponseHeaders* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::onos::e2t::e2::v1beta1::ResponseHeaders* headers);
  ::onos::e2t::e2::v1beta1::ResponseHeaders* unsafe_arena_release_headers();

  // .onos.e2t.e2.v1beta1.Acknowledgement ack = 2;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::onos::e2t::e2::v1beta1::Acknowledgement& ack() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Acknowledgement* release_ack();
  ::onos::e2t::e2::v1beta1::Acknowledgement* mutable_ack();
  void set_allocated_ack(::onos::e2t::e2::v1beta1::Acknowledgement* ack);
  private:
  const ::onos::e2t::e2::v1beta1::Acknowledgement& _internal_ack() const;
  ::onos::e2t::e2::v1beta1::Acknowledgement* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::onos::e2t::e2::v1beta1::Acknowledgement* ack);
  ::onos::e2t::e2::v1beta1::Acknowledgement* unsafe_arena_release_ack();

  // .onos.e2t.e2.v1beta1.Indication indication = 3;
  bool has_indication() const;
  private:
  bool _internal_has_indication() const;
  public:
  void clear_indication();
  const ::onos::e2t::e2::v1beta1::Indication& indication() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Indication* release_indication();
  ::onos::e2t::e2::v1beta1::Indication* mutable_indication();
  void set_allocated_indication(::onos::e2t::e2::v1beta1::Indication* indication);
  private:
  const ::onos::e2t::e2::v1beta1::Indication& _internal_indication() const;
  ::onos::e2t::e2::v1beta1::Indication* _internal_mutable_indication();
  public:
  void unsafe_arena_set_allocated_indication(
      ::onos::e2t::e2::v1beta1::Indication* indication);
  ::onos::e2t::e2::v1beta1::Indication* unsafe_arena_release_indication();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubscribeResponse)
 private:
  class _Internal;
  void set_has_ack();
  void set_has_indication();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::ResponseHeaders* headers_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::onos::e2t::e2::v1beta1::Acknowledgement* ack_;
    ::onos::e2t::e2::v1beta1::Indication* indication_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.UnsubscribeRequest) */ {
 public:
  inline UnsubscribeRequest() : UnsubscribeRequest(nullptr) {}
  ~UnsubscribeRequest() override;
  explicit constexpr UnsubscribeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeRequest(const UnsubscribeRequest& from);
  UnsubscribeRequest(UnsubscribeRequest&& from) noexcept
    : UnsubscribeRequest() {
    *this = ::std::move(from);
  }

  inline UnsubscribeRequest& operator=(const UnsubscribeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeRequest& operator=(UnsubscribeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeRequest* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeRequest*>(
               &_UnsubscribeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnsubscribeRequest& a, UnsubscribeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnsubscribeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.UnsubscribeRequest";
  }
  protected:
  explicit UnsubscribeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 2,
    kHeadersFieldNumber = 1,
  };
  // string transaction_id = 2 [(.gogoproto.customname) = "TransactionID", (.gogoproto.casttype) = "TransactionID"];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // .onos.e2t.e2.v1beta1.RequestHeaders headers = 1 [(.gogoproto.nullable) = false];
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::onos::e2t::e2::v1beta1::RequestHeaders& headers() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::RequestHeaders* release_headers();
  ::onos::e2t::e2::v1beta1::RequestHeaders* mutable_headers();
  void set_allocated_headers(::onos::e2t::e2::v1beta1::RequestHeaders* headers);
  private:
  const ::onos::e2t::e2::v1beta1::RequestHeaders& _internal_headers() const;
  ::onos::e2t::e2::v1beta1::RequestHeaders* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::onos::e2t::e2::v1beta1::RequestHeaders* headers);
  ::onos::e2t::e2::v1beta1::RequestHeaders* unsafe_arena_release_headers();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.UnsubscribeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::onos::e2t::e2::v1beta1::RequestHeaders* headers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.UnsubscribeResponse) */ {
 public:
  inline UnsubscribeResponse() : UnsubscribeResponse(nullptr) {}
  ~UnsubscribeResponse() override;
  explicit constexpr UnsubscribeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeResponse(const UnsubscribeResponse& from);
  UnsubscribeResponse(UnsubscribeResponse&& from) noexcept
    : UnsubscribeResponse() {
    *this = ::std::move(from);
  }

  inline UnsubscribeResponse& operator=(const UnsubscribeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeResponse& operator=(UnsubscribeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeResponse* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeResponse*>(
               &_UnsubscribeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UnsubscribeResponse& a, UnsubscribeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnsubscribeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.UnsubscribeResponse";
  }
  protected:
  explicit UnsubscribeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.ResponseHeaders headers = 1 [(.gogoproto.nullable) = false];
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;
  public:
  void clear_headers();
  const ::onos::e2t::e2::v1beta1::ResponseHeaders& headers() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ResponseHeaders* release_headers();
  ::onos::e2t::e2::v1beta1::ResponseHeaders* mutable_headers();
  void set_allocated_headers(::onos::e2t::e2::v1beta1::ResponseHeaders* headers);
  private:
  const ::onos::e2t::e2::v1beta1::ResponseHeaders& _internal_headers() const;
  ::onos::e2t::e2::v1beta1::ResponseHeaders* _internal_mutable_headers();
  public:
  void unsafe_arena_set_allocated_headers(
      ::onos::e2t::e2::v1beta1::ResponseHeaders* headers);
  ::onos::e2t::e2::v1beta1::ResponseHeaders* unsafe_arena_release_headers();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.UnsubscribeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::ResponseHeaders* headers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubscriptionSpec) */ {
 public:
  inline SubscriptionSpec() : SubscriptionSpec(nullptr) {}
  ~SubscriptionSpec() override;
  explicit constexpr SubscriptionSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionSpec(const SubscriptionSpec& from);
  SubscriptionSpec(SubscriptionSpec&& from) noexcept
    : SubscriptionSpec() {
    *this = ::std::move(from);
  }

  inline SubscriptionSpec& operator=(const SubscriptionSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionSpec& operator=(SubscriptionSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionSpec* internal_default_instance() {
    return reinterpret_cast<const SubscriptionSpec*>(
               &_SubscriptionSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SubscriptionSpec& a, SubscriptionSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubscriptionSpec";
  }
  protected:
  explicit SubscriptionSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 2,
    kEventTriggerFieldNumber = 1,
  };
  // repeated .onos.e2t.e2.v1beta1.Action actions = 2 [(.gogoproto.nullable) = false];
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::onos::e2t::e2::v1beta1::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Action >*
      mutable_actions();
  private:
  const ::onos::e2t::e2::v1beta1::Action& _internal_actions(int index) const;
  ::onos::e2t::e2::v1beta1::Action* _internal_add_actions();
  public:
  const ::onos::e2t::e2::v1beta1::Action& actions(int index) const;
  ::onos::e2t::e2::v1beta1::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Action >&
      actions() const;

  // .onos.e2t.e2.v1beta1.EventTrigger event_trigger = 1 [(.gogoproto.nullable) = false];
  bool has_event_trigger() const;
  private:
  bool _internal_has_event_trigger() const;
  public:
  void clear_event_trigger();
  const ::onos::e2t::e2::v1beta1::EventTrigger& event_trigger() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::EventTrigger* release_event_trigger();
  ::onos::e2t::e2::v1beta1::EventTrigger* mutable_event_trigger();
  void set_allocated_event_trigger(::onos::e2t::e2::v1beta1::EventTrigger* event_trigger);
  private:
  const ::onos::e2t::e2::v1beta1::EventTrigger& _internal_event_trigger() const;
  ::onos::e2t::e2::v1beta1::EventTrigger* _internal_mutable_event_trigger();
  public:
  void unsafe_arena_set_allocated_event_trigger(
      ::onos::e2t::e2::v1beta1::EventTrigger* event_trigger);
  ::onos::e2t::e2::v1beta1::EventTrigger* unsafe_arena_release_event_trigger();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubscriptionSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Action > actions_;
  ::onos::e2t::e2::v1beta1::EventTrigger* event_trigger_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class EventTrigger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.EventTrigger) */ {
 public:
  inline EventTrigger() : EventTrigger(nullptr) {}
  ~EventTrigger() override;
  explicit constexpr EventTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventTrigger(const EventTrigger& from);
  EventTrigger(EventTrigger&& from) noexcept
    : EventTrigger() {
    *this = ::std::move(from);
  }

  inline EventTrigger& operator=(const EventTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventTrigger& operator=(EventTrigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventTrigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventTrigger* internal_default_instance() {
    return reinterpret_cast<const EventTrigger*>(
               &_EventTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EventTrigger& a, EventTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(EventTrigger* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventTrigger>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventTrigger& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventTrigger& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventTrigger* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.EventTrigger";
  }
  protected:
  explicit EventTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 1,
  };
  // bytes payload = 1;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.EventTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit constexpr Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Action& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kSubsequentActionFieldNumber = 4,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .onos.e2t.e2.v1beta1.SubsequentAction subsequent_action = 4;
  bool has_subsequent_action() const;
  private:
  bool _internal_has_subsequent_action() const;
  public:
  void clear_subsequent_action();
  const ::onos::e2t::e2::v1beta1::SubsequentAction& subsequent_action() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubsequentAction* release_subsequent_action();
  ::onos::e2t::e2::v1beta1::SubsequentAction* mutable_subsequent_action();
  void set_allocated_subsequent_action(::onos::e2t::e2::v1beta1::SubsequentAction* subsequent_action);
  private:
  const ::onos::e2t::e2::v1beta1::SubsequentAction& _internal_subsequent_action() const;
  ::onos::e2t::e2::v1beta1::SubsequentAction* _internal_mutable_subsequent_action();
  public:
  void unsafe_arena_set_allocated_subsequent_action(
      ::onos::e2t::e2::v1beta1::SubsequentAction* subsequent_action);
  ::onos::e2t::e2::v1beta1::SubsequentAction* unsafe_arena_release_subsequent_action();

  // int32 id = 1 [(.gogoproto.customname) = "ID"];
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .onos.e2t.e2.v1beta1.ActionType type = 2;
  void clear_type();
  ::onos::e2t::e2::v1beta1::ActionType type() const;
  void set_type(::onos::e2t::e2::v1beta1::ActionType value);
  private:
  ::onos::e2t::e2::v1beta1::ActionType _internal_type() const;
  void _internal_set_type(::onos::e2t::e2::v1beta1::ActionType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::onos::e2t::e2::v1beta1::SubsequentAction* subsequent_action_;
  int32_t id_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class SubsequentAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubsequentAction) */ {
 public:
  inline SubsequentAction() : SubsequentAction(nullptr) {}
  ~SubsequentAction() override;
  explicit constexpr SubsequentAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubsequentAction(const SubsequentAction& from);
  SubsequentAction(SubsequentAction&& from) noexcept
    : SubsequentAction() {
    *this = ::std::move(from);
  }

  inline SubsequentAction& operator=(const SubsequentAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubsequentAction& operator=(SubsequentAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubsequentAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubsequentAction* internal_default_instance() {
    return reinterpret_cast<const SubsequentAction*>(
               &_SubsequentAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SubsequentAction& a, SubsequentAction& b) {
    a.Swap(&b);
  }
  inline void Swap(SubsequentAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubsequentAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubsequentAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubsequentAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubsequentAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubsequentAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubsequentAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubsequentAction";
  }
  protected:
  explicit SubsequentAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTimeToWaitFieldNumber = 2,
  };
  // .onos.e2t.e2.v1beta1.SubsequentActionType type = 1;
  void clear_type();
  ::onos::e2t::e2::v1beta1::SubsequentActionType type() const;
  void set_type(::onos::e2t::e2::v1beta1::SubsequentActionType value);
  private:
  ::onos::e2t::e2::v1beta1::SubsequentActionType _internal_type() const;
  void _internal_set_type(::onos::e2t::e2::v1beta1::SubsequentActionType value);
  public:

  // .onos.e2t.e2.v1beta1.TimeToWait time_to_wait = 2;
  void clear_time_to_wait();
  ::onos::e2t::e2::v1beta1::TimeToWait time_to_wait() const;
  void set_time_to_wait(::onos::e2t::e2::v1beta1::TimeToWait value);
  private:
  ::onos::e2t::e2::v1beta1::TimeToWait _internal_time_to_wait() const;
  void _internal_set_time_to_wait(::onos::e2t::e2::v1beta1::TimeToWait value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubsequentAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  int time_to_wait_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class Acknowledgement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.Acknowledgement) */ {
 public:
  inline Acknowledgement() : Acknowledgement(nullptr) {}
  ~Acknowledgement() override;
  explicit constexpr Acknowledgement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Acknowledgement(const Acknowledgement& from);
  Acknowledgement(Acknowledgement&& from) noexcept
    : Acknowledgement() {
    *this = ::std::move(from);
  }

  inline Acknowledgement& operator=(const Acknowledgement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Acknowledgement& operator=(Acknowledgement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Acknowledgement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Acknowledgement* internal_default_instance() {
    return reinterpret_cast<const Acknowledgement*>(
               &_Acknowledgement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Acknowledgement& a, Acknowledgement& b) {
    a.Swap(&b);
  }
  inline void Swap(Acknowledgement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Acknowledgement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Acknowledgement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Acknowledgement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Acknowledgement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Acknowledgement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Acknowledgement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.Acknowledgement";
  }
  protected:
  explicit Acknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
  };
  // string channel_id = 1 [(.gogoproto.customname) = "ChannelID", (.gogoproto.casttype) = "ChannelID"];
  void clear_channel_id();
  const std::string& channel_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.Acknowledgement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class Indication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.Indication) */ {
 public:
  inline Indication() : Indication(nullptr) {}
  ~Indication() override;
  explicit constexpr Indication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Indication(const Indication& from);
  Indication(Indication&& from) noexcept
    : Indication() {
    *this = ::std::move(from);
  }

  inline Indication& operator=(const Indication& from) {
    CopyFrom(from);
    return *this;
  }
  inline Indication& operator=(Indication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Indication& default_instance() {
    return *internal_default_instance();
  }
  static inline const Indication* internal_default_instance() {
    return reinterpret_cast<const Indication*>(
               &_Indication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Indication& a, Indication& b) {
    a.Swap(&b);
  }
  inline void Swap(Indication* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Indication* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Indication* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Indication>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Indication& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Indication& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Indication* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.Indication";
  }
  protected:
  explicit Indication(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // bytes header = 1;
  void clear_header();
  const std::string& header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header();
  PROTOBUF_NODISCARD std::string* release_header();
  void set_allocated_header(std::string* header);
  private:
  const std::string& _internal_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
  std::string* _internal_mutable_header();
  public:

  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.Indication)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class GetChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.GetChannelRequest) */ {
 public:
  inline GetChannelRequest() : GetChannelRequest(nullptr) {}
  ~GetChannelRequest() override;
  explicit constexpr GetChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChannelRequest(const GetChannelRequest& from);
  GetChannelRequest(GetChannelRequest&& from) noexcept
    : GetChannelRequest() {
    *this = ::std::move(from);
  }

  inline GetChannelRequest& operator=(const GetChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChannelRequest& operator=(GetChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChannelRequest* internal_default_instance() {
    return reinterpret_cast<const GetChannelRequest*>(
               &_GetChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetChannelRequest& a, GetChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.GetChannelRequest";
  }
  protected:
  explicit GetChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
  };
  // string channel_id = 1 [(.gogoproto.customname) = "ChannelID", (.gogoproto.casttype) = "ChannelID"];
  void clear_channel_id();
  const std::string& channel_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_channel_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* channel_id);
  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(const std::string& value);
  std::string* _internal_mutable_channel_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.GetChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr channel_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class GetChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.GetChannelResponse) */ {
 public:
  inline GetChannelResponse() : GetChannelResponse(nullptr) {}
  ~GetChannelResponse() override;
  explicit constexpr GetChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetChannelResponse(const GetChannelResponse& from);
  GetChannelResponse(GetChannelResponse&& from) noexcept
    : GetChannelResponse() {
    *this = ::std::move(from);
  }

  inline GetChannelResponse& operator=(const GetChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetChannelResponse& operator=(GetChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetChannelResponse* internal_default_instance() {
    return reinterpret_cast<const GetChannelResponse*>(
               &_GetChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetChannelResponse& a, GetChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetChannelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.GetChannelResponse";
  }
  protected:
  explicit GetChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.Channel channel = 1 [(.gogoproto.nullable) = false];
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const ::onos::e2t::e2::v1beta1::Channel& channel() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Channel* release_channel();
  ::onos::e2t::e2::v1beta1::Channel* mutable_channel();
  void set_allocated_channel(::onos::e2t::e2::v1beta1::Channel* channel);
  private:
  const ::onos::e2t::e2::v1beta1::Channel& _internal_channel() const;
  ::onos::e2t::e2::v1beta1::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::onos::e2t::e2::v1beta1::Channel* channel);
  ::onos::e2t::e2::v1beta1::Channel* unsafe_arena_release_channel();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.GetChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::Channel* channel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ListChannelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ListChannelsRequest) */ {
 public:
  inline ListChannelsRequest() : ListChannelsRequest(nullptr) {}
  explicit constexpr ListChannelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListChannelsRequest(const ListChannelsRequest& from);
  ListChannelsRequest(ListChannelsRequest&& from) noexcept
    : ListChannelsRequest() {
    *this = ::std::move(from);
  }

  inline ListChannelsRequest& operator=(const ListChannelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListChannelsRequest& operator=(ListChannelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListChannelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListChannelsRequest* internal_default_instance() {
    return reinterpret_cast<const ListChannelsRequest*>(
               &_ListChannelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ListChannelsRequest& a, ListChannelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListChannelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListChannelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListChannelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListChannelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListChannelsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListChannelsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ListChannelsRequest";
  }
  protected:
  explicit ListChannelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ListChannelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ListChannelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ListChannelsResponse) */ {
 public:
  inline ListChannelsResponse() : ListChannelsResponse(nullptr) {}
  ~ListChannelsResponse() override;
  explicit constexpr ListChannelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListChannelsResponse(const ListChannelsResponse& from);
  ListChannelsResponse(ListChannelsResponse&& from) noexcept
    : ListChannelsResponse() {
    *this = ::std::move(from);
  }

  inline ListChannelsResponse& operator=(const ListChannelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListChannelsResponse& operator=(ListChannelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListChannelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListChannelsResponse* internal_default_instance() {
    return reinterpret_cast<const ListChannelsResponse*>(
               &_ListChannelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ListChannelsResponse& a, ListChannelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListChannelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListChannelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListChannelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListChannelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListChannelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListChannelsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListChannelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ListChannelsResponse";
  }
  protected:
  explicit ListChannelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated .onos.e2t.e2.v1beta1.Channel channels = 1 [(.gogoproto.nullable) = false];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  ::onos::e2t::e2::v1beta1::Channel* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Channel >*
      mutable_channels();
  private:
  const ::onos::e2t::e2::v1beta1::Channel& _internal_channels(int index) const;
  ::onos::e2t::e2::v1beta1::Channel* _internal_add_channels();
  public:
  const ::onos::e2t::e2::v1beta1::Channel& channels(int index) const;
  ::onos::e2t::e2::v1beta1::Channel* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Channel >&
      channels() const;

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ListChannelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Channel > channels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class WatchChannelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.WatchChannelsRequest) */ {
 public:
  inline WatchChannelsRequest() : WatchChannelsRequest(nullptr) {}
  ~WatchChannelsRequest() override;
  explicit constexpr WatchChannelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchChannelsRequest(const WatchChannelsRequest& from);
  WatchChannelsRequest(WatchChannelsRequest&& from) noexcept
    : WatchChannelsRequest() {
    *this = ::std::move(from);
  }

  inline WatchChannelsRequest& operator=(const WatchChannelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchChannelsRequest& operator=(WatchChannelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchChannelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchChannelsRequest* internal_default_instance() {
    return reinterpret_cast<const WatchChannelsRequest*>(
               &_WatchChannelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WatchChannelsRequest& a, WatchChannelsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchChannelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchChannelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchChannelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchChannelsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchChannelsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchChannelsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchChannelsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.WatchChannelsRequest";
  }
  protected:
  explicit WatchChannelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoReplayFieldNumber = 1,
  };
  // bool no_replay = 1;
  void clear_no_replay();
  bool no_replay() const;
  void set_no_replay(bool value);
  private:
  bool _internal_no_replay() const;
  void _internal_set_no_replay(bool value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.WatchChannelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool no_replay_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class WatchChannelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.WatchChannelsResponse) */ {
 public:
  inline WatchChannelsResponse() : WatchChannelsResponse(nullptr) {}
  ~WatchChannelsResponse() override;
  explicit constexpr WatchChannelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchChannelsResponse(const WatchChannelsResponse& from);
  WatchChannelsResponse(WatchChannelsResponse&& from) noexcept
    : WatchChannelsResponse() {
    *this = ::std::move(from);
  }

  inline WatchChannelsResponse& operator=(const WatchChannelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchChannelsResponse& operator=(WatchChannelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchChannelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchChannelsResponse* internal_default_instance() {
    return reinterpret_cast<const WatchChannelsResponse*>(
               &_WatchChannelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WatchChannelsResponse& a, WatchChannelsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchChannelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchChannelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchChannelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchChannelsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchChannelsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchChannelsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchChannelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.WatchChannelsResponse";
  }
  protected:
  explicit WatchChannelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.ChannelEvent event = 1 [(.gogoproto.nullable) = false];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::onos::e2t::e2::v1beta1::ChannelEvent& event() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ChannelEvent* release_event();
  ::onos::e2t::e2::v1beta1::ChannelEvent* mutable_event();
  void set_allocated_event(::onos::e2t::e2::v1beta1::ChannelEvent* event);
  private:
  const ::onos::e2t::e2::v1beta1::ChannelEvent& _internal_event() const;
  ::onos::e2t::e2::v1beta1::ChannelEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::onos::e2t::e2::v1beta1::ChannelEvent* event);
  ::onos::e2t::e2::v1beta1::ChannelEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.WatchChannelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::ChannelEvent* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ChannelEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ChannelEvent) */ {
 public:
  inline ChannelEvent() : ChannelEvent(nullptr) {}
  ~ChannelEvent() override;
  explicit constexpr ChannelEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelEvent(const ChannelEvent& from);
  ChannelEvent(ChannelEvent&& from) noexcept
    : ChannelEvent() {
    *this = ::std::move(from);
  }

  inline ChannelEvent& operator=(const ChannelEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelEvent& operator=(ChannelEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelEvent* internal_default_instance() {
    return reinterpret_cast<const ChannelEvent*>(
               &_ChannelEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChannelEvent& a, ChannelEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChannelEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ChannelEvent";
  }
  protected:
  explicit ChannelEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.Channel channel = 2 [(.gogoproto.nullable) = false];
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const ::onos::e2t::e2::v1beta1::Channel& channel() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Channel* release_channel();
  ::onos::e2t::e2::v1beta1::Channel* mutable_channel();
  void set_allocated_channel(::onos::e2t::e2::v1beta1::Channel* channel);
  private:
  const ::onos::e2t::e2::v1beta1::Channel& _internal_channel() const;
  ::onos::e2t::e2::v1beta1::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::onos::e2t::e2::v1beta1::Channel* channel);
  ::onos::e2t::e2::v1beta1::Channel* unsafe_arena_release_channel();

  // .onos.e2t.e2.v1beta1.ChannelEventType type = 1;
  void clear_type();
  ::onos::e2t::e2::v1beta1::ChannelEventType type() const;
  void set_type(::onos::e2t::e2::v1beta1::ChannelEventType value);
  private:
  ::onos::e2t::e2::v1beta1::ChannelEventType _internal_type() const;
  void _internal_set_type(::onos::e2t::e2::v1beta1::ChannelEventType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ChannelEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::Channel* channel_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class GetSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.GetSubscriptionRequest) */ {
 public:
  inline GetSubscriptionRequest() : GetSubscriptionRequest(nullptr) {}
  ~GetSubscriptionRequest() override;
  explicit constexpr GetSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubscriptionRequest(const GetSubscriptionRequest& from);
  GetSubscriptionRequest(GetSubscriptionRequest&& from) noexcept
    : GetSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline GetSubscriptionRequest& operator=(const GetSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubscriptionRequest& operator=(GetSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubscriptionRequest*>(
               &_GetSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetSubscriptionRequest& a, GetSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.GetSubscriptionRequest";
  }
  protected:
  explicit GetSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionIdFieldNumber = 1,
  };
  // string subscription_id = 1 [(.gogoproto.customname) = "SubscriptionID", (.gogoproto.casttype) = "SubscriptionID"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_NODISCARD std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.GetSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class GetSubscriptionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.GetSubscriptionResponse) */ {
 public:
  inline GetSubscriptionResponse() : GetSubscriptionResponse(nullptr) {}
  ~GetSubscriptionResponse() override;
  explicit constexpr GetSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubscriptionResponse(const GetSubscriptionResponse& from);
  GetSubscriptionResponse(GetSubscriptionResponse&& from) noexcept
    : GetSubscriptionResponse() {
    *this = ::std::move(from);
  }

  inline GetSubscriptionResponse& operator=(const GetSubscriptionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubscriptionResponse& operator=(GetSubscriptionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubscriptionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubscriptionResponse* internal_default_instance() {
    return reinterpret_cast<const GetSubscriptionResponse*>(
               &_GetSubscriptionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetSubscriptionResponse& a, GetSubscriptionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubscriptionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubscriptionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubscriptionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubscriptionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubscriptionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSubscriptionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubscriptionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.GetSubscriptionResponse";
  }
  protected:
  explicit GetSubscriptionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.Subscription subscription = 1 [(.gogoproto.nullable) = false];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::onos::e2t::e2::v1beta1::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Subscription* release_subscription();
  ::onos::e2t::e2::v1beta1::Subscription* mutable_subscription();
  void set_allocated_subscription(::onos::e2t::e2::v1beta1::Subscription* subscription);
  private:
  const ::onos::e2t::e2::v1beta1::Subscription& _internal_subscription() const;
  ::onos::e2t::e2::v1beta1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::onos::e2t::e2::v1beta1::Subscription* subscription);
  ::onos::e2t::e2::v1beta1::Subscription* unsafe_arena_release_subscription();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.GetSubscriptionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::Subscription* subscription_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ListSubscriptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ListSubscriptionsRequest) */ {
 public:
  inline ListSubscriptionsRequest() : ListSubscriptionsRequest(nullptr) {}
  explicit constexpr ListSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSubscriptionsRequest(const ListSubscriptionsRequest& from);
  ListSubscriptionsRequest(ListSubscriptionsRequest&& from) noexcept
    : ListSubscriptionsRequest() {
    *this = ::std::move(from);
  }

  inline ListSubscriptionsRequest& operator=(const ListSubscriptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSubscriptionsRequest& operator=(ListSubscriptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSubscriptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSubscriptionsRequest* internal_default_instance() {
    return reinterpret_cast<const ListSubscriptionsRequest*>(
               &_ListSubscriptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListSubscriptionsRequest& a, ListSubscriptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSubscriptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSubscriptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSubscriptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSubscriptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListSubscriptionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListSubscriptionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ListSubscriptionsRequest";
  }
  protected:
  explicit ListSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ListSubscriptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ListSubscriptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ListSubscriptionsResponse) */ {
 public:
  inline ListSubscriptionsResponse() : ListSubscriptionsResponse(nullptr) {}
  ~ListSubscriptionsResponse() override;
  explicit constexpr ListSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSubscriptionsResponse(const ListSubscriptionsResponse& from);
  ListSubscriptionsResponse(ListSubscriptionsResponse&& from) noexcept
    : ListSubscriptionsResponse() {
    *this = ::std::move(from);
  }

  inline ListSubscriptionsResponse& operator=(const ListSubscriptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSubscriptionsResponse& operator=(ListSubscriptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSubscriptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSubscriptionsResponse* internal_default_instance() {
    return reinterpret_cast<const ListSubscriptionsResponse*>(
               &_ListSubscriptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ListSubscriptionsResponse& a, ListSubscriptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSubscriptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSubscriptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSubscriptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSubscriptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSubscriptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListSubscriptionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSubscriptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ListSubscriptionsResponse";
  }
  protected:
  explicit ListSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionsFieldNumber = 1,
  };
  // repeated .onos.e2t.e2.v1beta1.Subscription subscriptions = 1 [(.gogoproto.nullable) = false];
  int subscriptions_size() const;
  private:
  int _internal_subscriptions_size() const;
  public:
  void clear_subscriptions();
  ::onos::e2t::e2::v1beta1::Subscription* mutable_subscriptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Subscription >*
      mutable_subscriptions();
  private:
  const ::onos::e2t::e2::v1beta1::Subscription& _internal_subscriptions(int index) const;
  ::onos::e2t::e2::v1beta1::Subscription* _internal_add_subscriptions();
  public:
  const ::onos::e2t::e2::v1beta1::Subscription& subscriptions(int index) const;
  ::onos::e2t::e2::v1beta1::Subscription* add_subscriptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Subscription >&
      subscriptions() const;

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ListSubscriptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Subscription > subscriptions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class WatchSubscriptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.WatchSubscriptionsRequest) */ {
 public:
  inline WatchSubscriptionsRequest() : WatchSubscriptionsRequest(nullptr) {}
  ~WatchSubscriptionsRequest() override;
  explicit constexpr WatchSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchSubscriptionsRequest(const WatchSubscriptionsRequest& from);
  WatchSubscriptionsRequest(WatchSubscriptionsRequest&& from) noexcept
    : WatchSubscriptionsRequest() {
    *this = ::std::move(from);
  }

  inline WatchSubscriptionsRequest& operator=(const WatchSubscriptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchSubscriptionsRequest& operator=(WatchSubscriptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchSubscriptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchSubscriptionsRequest* internal_default_instance() {
    return reinterpret_cast<const WatchSubscriptionsRequest*>(
               &_WatchSubscriptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(WatchSubscriptionsRequest& a, WatchSubscriptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchSubscriptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchSubscriptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchSubscriptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchSubscriptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchSubscriptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchSubscriptionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchSubscriptionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.WatchSubscriptionsRequest";
  }
  protected:
  explicit WatchSubscriptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoReplayFieldNumber = 1,
  };
  // bool no_replay = 1;
  void clear_no_replay();
  bool no_replay() const;
  void set_no_replay(bool value);
  private:
  bool _internal_no_replay() const;
  void _internal_set_no_replay(bool value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.WatchSubscriptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool no_replay_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class WatchSubscriptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse) */ {
 public:
  inline WatchSubscriptionsResponse() : WatchSubscriptionsResponse(nullptr) {}
  ~WatchSubscriptionsResponse() override;
  explicit constexpr WatchSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchSubscriptionsResponse(const WatchSubscriptionsResponse& from);
  WatchSubscriptionsResponse(WatchSubscriptionsResponse&& from) noexcept
    : WatchSubscriptionsResponse() {
    *this = ::std::move(from);
  }

  inline WatchSubscriptionsResponse& operator=(const WatchSubscriptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchSubscriptionsResponse& operator=(WatchSubscriptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchSubscriptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchSubscriptionsResponse* internal_default_instance() {
    return reinterpret_cast<const WatchSubscriptionsResponse*>(
               &_WatchSubscriptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(WatchSubscriptionsResponse& a, WatchSubscriptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchSubscriptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchSubscriptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchSubscriptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchSubscriptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchSubscriptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchSubscriptionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchSubscriptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.WatchSubscriptionsResponse";
  }
  protected:
  explicit WatchSubscriptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.SubscriptionEvent event = 1 [(.gogoproto.nullable) = false];
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::onos::e2t::e2::v1beta1::SubscriptionEvent& event() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubscriptionEvent* release_event();
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* mutable_event();
  void set_allocated_event(::onos::e2t::e2::v1beta1::SubscriptionEvent* event);
  private:
  const ::onos::e2t::e2::v1beta1::SubscriptionEvent& _internal_event() const;
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::onos::e2t::e2::v1beta1::SubscriptionEvent* event);
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubscriptionEvent) */ {
 public:
  inline SubscriptionEvent() : SubscriptionEvent(nullptr) {}
  ~SubscriptionEvent() override;
  explicit constexpr SubscriptionEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionEvent(const SubscriptionEvent& from);
  SubscriptionEvent(SubscriptionEvent&& from) noexcept
    : SubscriptionEvent() {
    *this = ::std::move(from);
  }

  inline SubscriptionEvent& operator=(const SubscriptionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionEvent& operator=(SubscriptionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionEvent* internal_default_instance() {
    return reinterpret_cast<const SubscriptionEvent*>(
               &_SubscriptionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SubscriptionEvent& a, SubscriptionEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubscriptionEvent";
  }
  protected:
  explicit SubscriptionEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .onos.e2t.e2.v1beta1.Subscription subscription = 2 [(.gogoproto.nullable) = false];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::onos::e2t::e2::v1beta1::Subscription& subscription() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Subscription* release_subscription();
  ::onos::e2t::e2::v1beta1::Subscription* mutable_subscription();
  void set_allocated_subscription(::onos::e2t::e2::v1beta1::Subscription* subscription);
  private:
  const ::onos::e2t::e2::v1beta1::Subscription& _internal_subscription() const;
  ::onos::e2t::e2::v1beta1::Subscription* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::onos::e2t::e2::v1beta1::Subscription* subscription);
  ::onos::e2t::e2::v1beta1::Subscription* unsafe_arena_release_subscription();

  // .onos.e2t.e2.v1beta1.SubscriptionEventType type = 1;
  void clear_type();
  ::onos::e2t::e2::v1beta1::SubscriptionEventType type() const;
  void set_type(::onos::e2t::e2::v1beta1::SubscriptionEventType value);
  private:
  ::onos::e2t::e2::v1beta1::SubscriptionEventType _internal_type() const;
  void _internal_set_type(::onos::e2t::e2::v1beta1::SubscriptionEventType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubscriptionEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::Subscription* subscription_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ChannelMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ChannelMeta) */ {
 public:
  inline ChannelMeta() : ChannelMeta(nullptr) {}
  ~ChannelMeta() override;
  explicit constexpr ChannelMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelMeta(const ChannelMeta& from);
  ChannelMeta(ChannelMeta&& from) noexcept
    : ChannelMeta() {
    *this = ::std::move(from);
  }

  inline ChannelMeta& operator=(const ChannelMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelMeta& operator=(ChannelMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelMeta* internal_default_instance() {
    return reinterpret_cast<const ChannelMeta*>(
               &_ChannelMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ChannelMeta& a, ChannelMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChannelMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ChannelMeta";
  }
  protected:
  explicit ChannelMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalizersFieldNumber = 9,
    kAppIdFieldNumber = 1,
    kAppInstanceIdFieldNumber = 2,
    kE2NodeIdFieldNumber = 3,
    kTransactionIdFieldNumber = 4,
    kSubscriptionIdFieldNumber = 5,
    kServiceModelFieldNumber = 6,
    kRevisionFieldNumber = 8,
    kEncodingFieldNumber = 7,
  };
  // repeated string finalizers = 9;
  int finalizers_size() const;
  private:
  int _internal_finalizers_size() const;
  public:
  void clear_finalizers();
  const std::string& finalizers(int index) const;
  std::string* mutable_finalizers(int index);
  void set_finalizers(int index, const std::string& value);
  void set_finalizers(int index, std::string&& value);
  void set_finalizers(int index, const char* value);
  void set_finalizers(int index, const char* value, size_t size);
  std::string* add_finalizers();
  void add_finalizers(const std::string& value);
  void add_finalizers(std::string&& value);
  void add_finalizers(const char* value);
  void add_finalizers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& finalizers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_finalizers();
  private:
  const std::string& _internal_finalizers(int index) const;
  std::string* _internal_add_finalizers();
  public:

  // string app_id = 1 [(.gogoproto.customname) = "AppID", (.gogoproto.casttype) = "AppID"];
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string app_instance_id = 2 [(.gogoproto.customname) = "AppInstanceID", (.gogoproto.casttype) = "AppInstanceID"];
  void clear_app_instance_id();
  const std::string& app_instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_instance_id();
  PROTOBUF_NODISCARD std::string* release_app_instance_id();
  void set_allocated_app_instance_id(std::string* app_instance_id);
  private:
  const std::string& _internal_app_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_instance_id(const std::string& value);
  std::string* _internal_mutable_app_instance_id();
  public:

  // string e2_node_id = 3 [(.gogoproto.customname) = "E2NodeID", (.gogoproto.casttype) = "E2NodeID"];
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // string transaction_id = 4 [(.gogoproto.customname) = "TransactionID", (.gogoproto.casttype) = "TransactionID"];
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_NODISCARD std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // string subscription_id = 5 [(.gogoproto.customname) = "SubscriptionID", (.gogoproto.casttype) = "SubscriptionID"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_NODISCARD std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // .onos.e2t.e2.v1beta1.ServiceModel service_model = 6 [(.gogoproto.nullable) = false];
  bool has_service_model() const;
  private:
  bool _internal_has_service_model() const;
  public:
  void clear_service_model();
  const ::onos::e2t::e2::v1beta1::ServiceModel& service_model() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ServiceModel* release_service_model();
  ::onos::e2t::e2::v1beta1::ServiceModel* mutable_service_model();
  void set_allocated_service_model(::onos::e2t::e2::v1beta1::ServiceModel* service_model);
  private:
  const ::onos::e2t::e2::v1beta1::ServiceModel& _internal_service_model() const;
  ::onos::e2t::e2::v1beta1::ServiceModel* _internal_mutable_service_model();
  public:
  void unsafe_arena_set_allocated_service_model(
      ::onos::e2t::e2::v1beta1::ServiceModel* service_model);
  ::onos::e2t::e2::v1beta1::ServiceModel* unsafe_arena_release_service_model();

  // uint64 revision = 8 [(.gogoproto.casttype) = "Revision"];
  void clear_revision();
  uint64_t revision() const;
  void set_revision(uint64_t value);
  private:
  uint64_t _internal_revision() const;
  void _internal_set_revision(uint64_t value);
  public:

  // .onos.e2t.e2.v1beta1.Encoding encoding = 7;
  void clear_encoding();
  ::onos::e2t::e2::v1beta1::Encoding encoding() const;
  void set_encoding(::onos::e2t::e2::v1beta1::Encoding value);
  private:
  ::onos::e2t::e2::v1beta1::Encoding _internal_encoding() const;
  void _internal_set_encoding(::onos::e2t::e2::v1beta1::Encoding value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ChannelMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> finalizers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_instance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::onos::e2t::e2::v1beta1::ServiceModel* service_model_;
  uint64_t revision_;
  int encoding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class Channel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.Channel) */ {
 public:
  inline Channel() : Channel(nullptr) {}
  ~Channel() override;
  explicit constexpr Channel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Channel(const Channel& from);
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Channel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(Channel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Channel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Channel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Channel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.Channel";
  }
  protected:
  explicit Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetaFieldNumber = 2,
    kSpecFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ChannelID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .onos.e2t.e2.v1beta1.ChannelMeta meta = 2 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::onos::e2t::e2::v1beta1::ChannelMeta& meta() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ChannelMeta* release_meta();
  ::onos::e2t::e2::v1beta1::ChannelMeta* mutable_meta();
  void set_allocated_meta(::onos::e2t::e2::v1beta1::ChannelMeta* meta);
  private:
  const ::onos::e2t::e2::v1beta1::ChannelMeta& _internal_meta() const;
  ::onos::e2t::e2::v1beta1::ChannelMeta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::onos::e2t::e2::v1beta1::ChannelMeta* meta);
  ::onos::e2t::e2::v1beta1::ChannelMeta* unsafe_arena_release_meta();

  // .onos.e2t.e2.v1beta1.ChannelSpec spec = 3 [(.gogoproto.nullable) = false];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::onos::e2t::e2::v1beta1::ChannelSpec& spec() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ChannelSpec* release_spec();
  ::onos::e2t::e2::v1beta1::ChannelSpec* mutable_spec();
  void set_allocated_spec(::onos::e2t::e2::v1beta1::ChannelSpec* spec);
  private:
  const ::onos::e2t::e2::v1beta1::ChannelSpec& _internal_spec() const;
  ::onos::e2t::e2::v1beta1::ChannelSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::onos::e2t::e2::v1beta1::ChannelSpec* spec);
  ::onos::e2t::e2::v1beta1::ChannelSpec* unsafe_arena_release_spec();

  // .onos.e2t.e2.v1beta1.ChannelStatus status = 4 [(.gogoproto.nullable) = false];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::e2t::e2::v1beta1::ChannelStatus& status() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ChannelStatus* release_status();
  ::onos::e2t::e2::v1beta1::ChannelStatus* mutable_status();
  void set_allocated_status(::onos::e2t::e2::v1beta1::ChannelStatus* status);
  private:
  const ::onos::e2t::e2::v1beta1::ChannelStatus& _internal_status() const;
  ::onos::e2t::e2::v1beta1::ChannelStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::e2t::e2::v1beta1::ChannelStatus* status);
  ::onos::e2t::e2::v1beta1::ChannelStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.Channel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::onos::e2t::e2::v1beta1::ChannelMeta* meta_;
  ::onos::e2t::e2::v1beta1::ChannelSpec* spec_;
  ::onos::e2t::e2::v1beta1::ChannelStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ChannelSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ChannelSpec) */ {
 public:
  inline ChannelSpec() : ChannelSpec(nullptr) {}
  ~ChannelSpec() override;
  explicit constexpr ChannelSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelSpec(const ChannelSpec& from);
  ChannelSpec(ChannelSpec&& from) noexcept
    : ChannelSpec() {
    *this = ::std::move(from);
  }

  inline ChannelSpec& operator=(const ChannelSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelSpec& operator=(ChannelSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelSpec* internal_default_instance() {
    return reinterpret_cast<const ChannelSpec*>(
               &_ChannelSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ChannelSpec& a, ChannelSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChannelSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ChannelSpec";
  }
  protected:
  explicit ChannelSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 1,
    kTransactionTimeoutFieldNumber = 2,
  };
  // .onos.e2t.e2.v1beta1.SubscriptionSpec subscription = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_subscription() const;
  private:
  bool _internal_has_subscription() const;
  public:
  void clear_subscription();
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec& subscription() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubscriptionSpec* release_subscription();
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* mutable_subscription();
  void set_allocated_subscription(::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription);
  private:
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec& _internal_subscription() const;
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* _internal_mutable_subscription();
  public:
  void unsafe_arena_set_allocated_subscription(
      ::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription);
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* unsafe_arena_release_subscription();

  // .google.protobuf.Duration transaction_timeout = 2 [(.gogoproto.stdduration) = true];
  bool has_transaction_timeout() const;
  private:
  bool _internal_has_transaction_timeout() const;
  public:
  void clear_transaction_timeout();
  const ::PROTOBUF_NAMESPACE_ID::Duration& transaction_timeout() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_transaction_timeout();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_transaction_timeout();
  void set_allocated_transaction_timeout(::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_transaction_timeout() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_transaction_timeout();
  public:
  void unsafe_arena_set_allocated_transaction_timeout(
      ::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_transaction_timeout();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ChannelSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription_;
  ::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class ChannelStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.ChannelStatus) */ {
 public:
  inline ChannelStatus() : ChannelStatus(nullptr) {}
  ~ChannelStatus() override;
  explicit constexpr ChannelStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelStatus(const ChannelStatus& from);
  ChannelStatus(ChannelStatus&& from) noexcept
    : ChannelStatus() {
    *this = ::std::move(from);
  }

  inline ChannelStatus& operator=(const ChannelStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelStatus& operator=(ChannelStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelStatus* internal_default_instance() {
    return reinterpret_cast<const ChannelStatus*>(
               &_ChannelStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ChannelStatus& a, ChannelStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChannelStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.ChannelStatus";
  }
  protected:
  explicit ChannelStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterFieldNumber = 6,
    kErrorFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kPhaseFieldNumber = 1,
    kStateFieldNumber = 2,
    kTermFieldNumber = 5,
  };
  // string master = 6 [(.gogoproto.casttype) = "MasterID"];
  void clear_master();
  const std::string& master() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_master(ArgT0&& arg0, ArgT... args);
  std::string* mutable_master();
  PROTOBUF_NODISCARD std::string* release_master();
  void set_allocated_master(std::string* master);
  private:
  const std::string& _internal_master() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master(const std::string& value);
  std::string* _internal_mutable_master();
  public:

  // .onos.e2t.e2.v1beta1.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::onos::e2t::e2::v1beta1::Error& error() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Error* release_error();
  ::onos::e2t::e2::v1beta1::Error* mutable_error();
  void set_allocated_error(::onos::e2t::e2::v1beta1::Error* error);
  private:
  const ::onos::e2t::e2::v1beta1::Error& _internal_error() const;
  ::onos::e2t::e2::v1beta1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::onos::e2t::e2::v1beta1::Error* error);
  ::onos::e2t::e2::v1beta1::Error* unsafe_arena_release_error();

  // .google.protobuf.Timestamp timestamp = 4 [(.gogoproto.stdtime) = true];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .onos.e2t.e2.v1beta1.ChannelPhase phase = 1;
  void clear_phase();
  ::onos::e2t::e2::v1beta1::ChannelPhase phase() const;
  void set_phase(::onos::e2t::e2::v1beta1::ChannelPhase value);
  private:
  ::onos::e2t::e2::v1beta1::ChannelPhase _internal_phase() const;
  void _internal_set_phase(::onos::e2t::e2::v1beta1::ChannelPhase value);
  public:

  // .onos.e2t.e2.v1beta1.ChannelState state = 2;
  void clear_state();
  ::onos::e2t::e2::v1beta1::ChannelState state() const;
  void set_state(::onos::e2t::e2::v1beta1::ChannelState value);
  private:
  ::onos::e2t::e2::v1beta1::ChannelState _internal_state() const;
  void _internal_set_state(::onos::e2t::e2::v1beta1::ChannelState value);
  public:

  // uint64 term = 5 [(.gogoproto.casttype) = "TermID"];
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.ChannelStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr master_;
  ::onos::e2t::e2::v1beta1::Error* error_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  int phase_;
  int state_;
  uint64_t term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubscriptionMeta) */ {
 public:
  inline SubscriptionMeta() : SubscriptionMeta(nullptr) {}
  ~SubscriptionMeta() override;
  explicit constexpr SubscriptionMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionMeta(const SubscriptionMeta& from);
  SubscriptionMeta(SubscriptionMeta&& from) noexcept
    : SubscriptionMeta() {
    *this = ::std::move(from);
  }

  inline SubscriptionMeta& operator=(const SubscriptionMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionMeta& operator=(SubscriptionMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionMeta* internal_default_instance() {
    return reinterpret_cast<const SubscriptionMeta*>(
               &_SubscriptionMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SubscriptionMeta& a, SubscriptionMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubscriptionMeta";
  }
  protected:
  explicit SubscriptionMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinalizersFieldNumber = 5,
    kE2NodeIdFieldNumber = 1,
    kServiceModelFieldNumber = 2,
    kRevisionFieldNumber = 4,
    kEncodingFieldNumber = 3,
  };
  // repeated string finalizers = 5;
  int finalizers_size() const;
  private:
  int _internal_finalizers_size() const;
  public:
  void clear_finalizers();
  const std::string& finalizers(int index) const;
  std::string* mutable_finalizers(int index);
  void set_finalizers(int index, const std::string& value);
  void set_finalizers(int index, std::string&& value);
  void set_finalizers(int index, const char* value);
  void set_finalizers(int index, const char* value, size_t size);
  std::string* add_finalizers();
  void add_finalizers(const std::string& value);
  void add_finalizers(std::string&& value);
  void add_finalizers(const char* value);
  void add_finalizers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& finalizers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_finalizers();
  private:
  const std::string& _internal_finalizers(int index) const;
  std::string* _internal_add_finalizers();
  public:

  // string e2_node_id = 1 [(.gogoproto.customname) = "E2NodeID", (.gogoproto.casttype) = "E2NodeID"];
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // .onos.e2t.e2.v1beta1.ServiceModel service_model = 2 [(.gogoproto.nullable) = false];
  bool has_service_model() const;
  private:
  bool _internal_has_service_model() const;
  public:
  void clear_service_model();
  const ::onos::e2t::e2::v1beta1::ServiceModel& service_model() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::ServiceModel* release_service_model();
  ::onos::e2t::e2::v1beta1::ServiceModel* mutable_service_model();
  void set_allocated_service_model(::onos::e2t::e2::v1beta1::ServiceModel* service_model);
  private:
  const ::onos::e2t::e2::v1beta1::ServiceModel& _internal_service_model() const;
  ::onos::e2t::e2::v1beta1::ServiceModel* _internal_mutable_service_model();
  public:
  void unsafe_arena_set_allocated_service_model(
      ::onos::e2t::e2::v1beta1::ServiceModel* service_model);
  ::onos::e2t::e2::v1beta1::ServiceModel* unsafe_arena_release_service_model();

  // uint64 revision = 4 [(.gogoproto.casttype) = "Revision"];
  void clear_revision();
  uint64_t revision() const;
  void set_revision(uint64_t value);
  private:
  uint64_t _internal_revision() const;
  void _internal_set_revision(uint64_t value);
  public:

  // .onos.e2t.e2.v1beta1.Encoding encoding = 3;
  void clear_encoding();
  ::onos::e2t::e2::v1beta1::Encoding encoding() const;
  void set_encoding(::onos::e2t::e2::v1beta1::Encoding value);
  private:
  ::onos::e2t::e2::v1beta1::Encoding _internal_encoding() const;
  void _internal_set_encoding(::onos::e2t::e2::v1beta1::Encoding value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubscriptionMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> finalizers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::onos::e2t::e2::v1beta1::ServiceModel* service_model_;
  uint64_t revision_;
  int encoding_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class Subscription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.Subscription) */ {
 public:
  inline Subscription() : Subscription(nullptr) {}
  ~Subscription() override;
  explicit constexpr Subscription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subscription(const Subscription& from);
  Subscription(Subscription&& from) noexcept
    : Subscription() {
    *this = ::std::move(from);
  }

  inline Subscription& operator=(const Subscription& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subscription& operator=(Subscription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subscription& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subscription* internal_default_instance() {
    return reinterpret_cast<const Subscription*>(
               &_Subscription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Subscription& a, Subscription& b) {
    a.Swap(&b);
  }
  inline void Swap(Subscription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subscription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subscription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subscription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subscription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Subscription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.Subscription";
  }
  protected:
  explicit Subscription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetaFieldNumber = 2,
    kSpecFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "SubscriptionID"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .onos.e2t.e2.v1beta1.SubscriptionMeta meta = 2 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::onos::e2t::e2::v1beta1::SubscriptionMeta& meta() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubscriptionMeta* release_meta();
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* mutable_meta();
  void set_allocated_meta(::onos::e2t::e2::v1beta1::SubscriptionMeta* meta);
  private:
  const ::onos::e2t::e2::v1beta1::SubscriptionMeta& _internal_meta() const;
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::onos::e2t::e2::v1beta1::SubscriptionMeta* meta);
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* unsafe_arena_release_meta();

  // .onos.e2t.e2.v1beta1.SubscriptionSpec spec = 3 [(.gogoproto.nullable) = false];
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec& spec() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubscriptionSpec* release_spec();
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* mutable_spec();
  void set_allocated_spec(::onos::e2t::e2::v1beta1::SubscriptionSpec* spec);
  private:
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec& _internal_spec() const;
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::onos::e2t::e2::v1beta1::SubscriptionSpec* spec);
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* unsafe_arena_release_spec();

  // .onos.e2t.e2.v1beta1.SubscriptionStatus status = 4 [(.gogoproto.nullable) = false];
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::onos::e2t::e2::v1beta1::SubscriptionStatus& status() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::SubscriptionStatus* release_status();
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* mutable_status();
  void set_allocated_status(::onos::e2t::e2::v1beta1::SubscriptionStatus* status);
  private:
  const ::onos::e2t::e2::v1beta1::SubscriptionStatus& _internal_status() const;
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::onos::e2t::e2::v1beta1::SubscriptionStatus* status);
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.Subscription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* meta_;
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* spec_;
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.v1beta1.SubscriptionStatus) */ {
 public:
  inline SubscriptionStatus() : SubscriptionStatus(nullptr) {}
  ~SubscriptionStatus() override;
  explicit constexpr SubscriptionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionStatus(const SubscriptionStatus& from);
  SubscriptionStatus(SubscriptionStatus&& from) noexcept
    : SubscriptionStatus() {
    *this = ::std::move(from);
  }

  inline SubscriptionStatus& operator=(const SubscriptionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionStatus& operator=(SubscriptionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionStatus* internal_default_instance() {
    return reinterpret_cast<const SubscriptionStatus*>(
               &_SubscriptionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SubscriptionStatus& a, SubscriptionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscriptionStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.v1beta1.SubscriptionStatus";
  }
  protected:
  explicit SubscriptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 4,
    kMasterFieldNumber = 6,
    kErrorFieldNumber = 3,
    kPhaseFieldNumber = 1,
    kStateFieldNumber = 2,
    kTermFieldNumber = 5,
  };
  // repeated string channels = 4 [(.gogoproto.casttype) = "ChannelID"];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  const std::string& channels(int index) const;
  std::string* mutable_channels(int index);
  void set_channels(int index, const std::string& value);
  void set_channels(int index, std::string&& value);
  void set_channels(int index, const char* value);
  void set_channels(int index, const char* value, size_t size);
  std::string* add_channels();
  void add_channels(const std::string& value);
  void add_channels(std::string&& value);
  void add_channels(const char* value);
  void add_channels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& channels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_channels();
  private:
  const std::string& _internal_channels(int index) const;
  std::string* _internal_add_channels();
  public:

  // string master = 6 [(.gogoproto.casttype) = "MasterID"];
  void clear_master();
  const std::string& master() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_master(ArgT0&& arg0, ArgT... args);
  std::string* mutable_master();
  PROTOBUF_NODISCARD std::string* release_master();
  void set_allocated_master(std::string* master);
  private:
  const std::string& _internal_master() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master(const std::string& value);
  std::string* _internal_mutable_master();
  public:

  // .onos.e2t.e2.v1beta1.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::onos::e2t::e2::v1beta1::Error& error() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::v1beta1::Error* release_error();
  ::onos::e2t::e2::v1beta1::Error* mutable_error();
  void set_allocated_error(::onos::e2t::e2::v1beta1::Error* error);
  private:
  const ::onos::e2t::e2::v1beta1::Error& _internal_error() const;
  ::onos::e2t::e2::v1beta1::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::onos::e2t::e2::v1beta1::Error* error);
  ::onos::e2t::e2::v1beta1::Error* unsafe_arena_release_error();

  // .onos.e2t.e2.v1beta1.SubscriptionPhase phase = 1;
  void clear_phase();
  ::onos::e2t::e2::v1beta1::SubscriptionPhase phase() const;
  void set_phase(::onos::e2t::e2::v1beta1::SubscriptionPhase value);
  private:
  ::onos::e2t::e2::v1beta1::SubscriptionPhase _internal_phase() const;
  void _internal_set_phase(::onos::e2t::e2::v1beta1::SubscriptionPhase value);
  public:

  // .onos.e2t.e2.v1beta1.SubscriptionState state = 2;
  void clear_state();
  ::onos::e2t::e2::v1beta1::SubscriptionState state() const;
  void set_state(::onos::e2t::e2::v1beta1::SubscriptionState value);
  private:
  ::onos::e2t::e2::v1beta1::SubscriptionState _internal_state() const;
  void _internal_set_state(::onos::e2t::e2::v1beta1::SubscriptionState value);
  public:

  // uint64 term = 5 [(.gogoproto.casttype) = "TermID"];
  void clear_term();
  uint64_t term() const;
  void set_term(uint64_t value);
  private:
  uint64_t _internal_term() const;
  void _internal_set_term(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.v1beta1.SubscriptionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> channels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr master_;
  ::onos::e2t::e2::v1beta1::Error* error_;
  int phase_;
  int state_;
  uint64_t term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubscribeRequest

// .onos.e2t.e2.v1beta1.RequestHeaders headers = 1 [(.gogoproto.nullable) = false];
inline bool SubscribeRequest::_internal_has_headers() const {
  return this != internal_default_instance() && headers_ != nullptr;
}
inline bool SubscribeRequest::has_headers() const {
  return _internal_has_headers();
}
inline const ::onos::e2t::e2::v1beta1::RequestHeaders& SubscribeRequest::_internal_headers() const {
  const ::onos::e2t::e2::v1beta1::RequestHeaders* p = headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::RequestHeaders&>(
      ::onos::e2t::e2::v1beta1::_RequestHeaders_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::RequestHeaders& SubscribeRequest::headers() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeRequest.headers)
  return _internal_headers();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_headers(
    ::onos::e2t::e2::v1beta1::RequestHeaders* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.headers)
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* SubscribeRequest::release_headers() {
  
  ::onos::e2t::e2::v1beta1::RequestHeaders* temp = headers_;
  headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* SubscribeRequest::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeRequest.headers)
  
  ::onos::e2t::e2::v1beta1::RequestHeaders* temp = headers_;
  headers_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* SubscribeRequest::_internal_mutable_headers() {
  
  if (headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::RequestHeaders>(GetArenaForAllocation());
    headers_ = p;
  }
  return headers_;
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* SubscribeRequest::mutable_headers() {
  ::onos::e2t::e2::v1beta1::RequestHeaders* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeRequest.headers)
  return _msg;
}
inline void SubscribeRequest::set_allocated_headers(::onos::e2t::e2::v1beta1::RequestHeaders* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers));
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.headers)
}

// string transaction_id = 2 [(.gogoproto.customname) = "TransactionID", (.gogoproto.casttype) = "TransactionID"];
inline void SubscribeRequest::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& SubscribeRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_id)
}
inline std::string* SubscribeRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_id)
  return _s;
}
inline const std::string& SubscribeRequest::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void SubscribeRequest::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_id)
  return transaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_id)
}

// .onos.e2t.e2.v1beta1.SubscriptionSpec subscription = 3 [(.gogoproto.nullable) = false];
inline bool SubscribeRequest::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool SubscribeRequest::has_subscription() const {
  return _internal_has_subscription();
}
inline void SubscribeRequest::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionSpec& SubscribeRequest::_internal_subscription() const {
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubscriptionSpec&>(
      ::onos::e2t::e2::v1beta1::_SubscriptionSpec_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionSpec& SubscribeRequest::subscription() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeRequest.subscription)
  return _internal_subscription();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_subscription(
    ::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.subscription)
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* SubscribeRequest::release_subscription() {
  
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* SubscribeRequest::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeRequest.subscription)
  
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* SubscribeRequest::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionSpec>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* SubscribeRequest::mutable_subscription() {
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeRequest.subscription)
  return _msg;
}
inline void SubscribeRequest::set_allocated_subscription(::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubscriptionSpec>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.subscription)
}

// .google.protobuf.Duration transaction_timeout = 4 [(.gogoproto.stdduration) = true];
inline bool SubscribeRequest::_internal_has_transaction_timeout() const {
  return this != internal_default_instance() && transaction_timeout_ != nullptr;
}
inline bool SubscribeRequest::has_transaction_timeout() const {
  return _internal_has_transaction_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SubscribeRequest::_internal_transaction_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = transaction_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& SubscribeRequest::transaction_timeout() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_timeout)
  return _internal_transaction_timeout();
}
inline void SubscribeRequest::unsafe_arena_set_allocated_transaction_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_timeout_);
  }
  transaction_timeout_ = transaction_timeout;
  if (transaction_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SubscribeRequest::release_transaction_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = transaction_timeout_;
  transaction_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SubscribeRequest::unsafe_arena_release_transaction_timeout() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = transaction_timeout_;
  transaction_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SubscribeRequest::_internal_mutable_transaction_timeout() {
  
  if (transaction_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    transaction_timeout_ = p;
  }
  return transaction_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* SubscribeRequest::mutable_transaction_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_transaction_timeout();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_timeout)
  return _msg;
}
inline void SubscribeRequest::set_allocated_transaction_timeout(::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_timeout_);
  }
  if (transaction_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_timeout));
    if (message_arena != submessage_arena) {
      transaction_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction_timeout, submessage_arena);
    }
    
  } else {
    
  }
  transaction_timeout_ = transaction_timeout;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscribeRequest.transaction_timeout)
}

// -------------------------------------------------------------------

// SubscribeResponse

// .onos.e2t.e2.v1beta1.ResponseHeaders headers = 1 [(.gogoproto.nullable) = false];
inline bool SubscribeResponse::_internal_has_headers() const {
  return this != internal_default_instance() && headers_ != nullptr;
}
inline bool SubscribeResponse::has_headers() const {
  return _internal_has_headers();
}
inline const ::onos::e2t::e2::v1beta1::ResponseHeaders& SubscribeResponse::_internal_headers() const {
  const ::onos::e2t::e2::v1beta1::ResponseHeaders* p = headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ResponseHeaders&>(
      ::onos::e2t::e2::v1beta1::_ResponseHeaders_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ResponseHeaders& SubscribeResponse::headers() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeResponse.headers)
  return _internal_headers();
}
inline void SubscribeResponse::unsafe_arena_set_allocated_headers(
    ::onos::e2t::e2::v1beta1::ResponseHeaders* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscribeResponse.headers)
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* SubscribeResponse::release_headers() {
  
  ::onos::e2t::e2::v1beta1::ResponseHeaders* temp = headers_;
  headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* SubscribeResponse::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeResponse.headers)
  
  ::onos::e2t::e2::v1beta1::ResponseHeaders* temp = headers_;
  headers_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* SubscribeResponse::_internal_mutable_headers() {
  
  if (headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ResponseHeaders>(GetArenaForAllocation());
    headers_ = p;
  }
  return headers_;
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* SubscribeResponse::mutable_headers() {
  ::onos::e2t::e2::v1beta1::ResponseHeaders* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeResponse.headers)
  return _msg;
}
inline void SubscribeResponse::set_allocated_headers(::onos::e2t::e2::v1beta1::ResponseHeaders* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers));
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscribeResponse.headers)
}

// .onos.e2t.e2.v1beta1.Acknowledgement ack = 2;
inline bool SubscribeResponse::_internal_has_ack() const {
  return message_case() == kAck;
}
inline bool SubscribeResponse::has_ack() const {
  return _internal_has_ack();
}
inline void SubscribeResponse::set_has_ack() {
  _oneof_case_[0] = kAck;
}
inline void SubscribeResponse::clear_ack() {
  if (_internal_has_ack()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.ack_;
    }
    clear_has_message();
  }
}
inline ::onos::e2t::e2::v1beta1::Acknowledgement* SubscribeResponse::release_ack() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeResponse.ack)
  if (_internal_has_ack()) {
    clear_has_message();
      ::onos::e2t::e2::v1beta1::Acknowledgement* temp = message_.ack_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::e2t::e2::v1beta1::Acknowledgement& SubscribeResponse::_internal_ack() const {
  return _internal_has_ack()
      ? *message_.ack_
      : reinterpret_cast< ::onos::e2t::e2::v1beta1::Acknowledgement&>(::onos::e2t::e2::v1beta1::_Acknowledgement_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Acknowledgement& SubscribeResponse::ack() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeResponse.ack)
  return _internal_ack();
}
inline ::onos::e2t::e2::v1beta1::Acknowledgement* SubscribeResponse::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.e2t.e2.v1beta1.SubscribeResponse.ack)
  if (_internal_has_ack()) {
    clear_has_message();
    ::onos::e2t::e2::v1beta1::Acknowledgement* temp = message_.ack_;
    message_.ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeResponse::unsafe_arena_set_allocated_ack(::onos::e2t::e2::v1beta1::Acknowledgement* ack) {
  clear_message();
  if (ack) {
    set_has_ack();
    message_.ack_ = ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscribeResponse.ack)
}
inline ::onos::e2t::e2::v1beta1::Acknowledgement* SubscribeResponse::_internal_mutable_ack() {
  if (!_internal_has_ack()) {
    clear_message();
    set_has_ack();
    message_.ack_ = CreateMaybeMessage< ::onos::e2t::e2::v1beta1::Acknowledgement >(GetArenaForAllocation());
  }
  return message_.ack_;
}
inline ::onos::e2t::e2::v1beta1::Acknowledgement* SubscribeResponse::mutable_ack() {
  ::onos::e2t::e2::v1beta1::Acknowledgement* _msg = _internal_mutable_ack();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeResponse.ack)
  return _msg;
}

// .onos.e2t.e2.v1beta1.Indication indication = 3;
inline bool SubscribeResponse::_internal_has_indication() const {
  return message_case() == kIndication;
}
inline bool SubscribeResponse::has_indication() const {
  return _internal_has_indication();
}
inline void SubscribeResponse::set_has_indication() {
  _oneof_case_[0] = kIndication;
}
inline void SubscribeResponse::clear_indication() {
  if (_internal_has_indication()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.indication_;
    }
    clear_has_message();
  }
}
inline ::onos::e2t::e2::v1beta1::Indication* SubscribeResponse::release_indication() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscribeResponse.indication)
  if (_internal_has_indication()) {
    clear_has_message();
      ::onos::e2t::e2::v1beta1::Indication* temp = message_.indication_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.indication_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::e2t::e2::v1beta1::Indication& SubscribeResponse::_internal_indication() const {
  return _internal_has_indication()
      ? *message_.indication_
      : reinterpret_cast< ::onos::e2t::e2::v1beta1::Indication&>(::onos::e2t::e2::v1beta1::_Indication_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Indication& SubscribeResponse::indication() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscribeResponse.indication)
  return _internal_indication();
}
inline ::onos::e2t::e2::v1beta1::Indication* SubscribeResponse::unsafe_arena_release_indication() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.e2t.e2.v1beta1.SubscribeResponse.indication)
  if (_internal_has_indication()) {
    clear_has_message();
    ::onos::e2t::e2::v1beta1::Indication* temp = message_.indication_;
    message_.indication_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeResponse::unsafe_arena_set_allocated_indication(::onos::e2t::e2::v1beta1::Indication* indication) {
  clear_message();
  if (indication) {
    set_has_indication();
    message_.indication_ = indication;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscribeResponse.indication)
}
inline ::onos::e2t::e2::v1beta1::Indication* SubscribeResponse::_internal_mutable_indication() {
  if (!_internal_has_indication()) {
    clear_message();
    set_has_indication();
    message_.indication_ = CreateMaybeMessage< ::onos::e2t::e2::v1beta1::Indication >(GetArenaForAllocation());
  }
  return message_.indication_;
}
inline ::onos::e2t::e2::v1beta1::Indication* SubscribeResponse::mutable_indication() {
  ::onos::e2t::e2::v1beta1::Indication* _msg = _internal_mutable_indication();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscribeResponse.indication)
  return _msg;
}

inline bool SubscribeResponse::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void SubscribeResponse::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline SubscribeResponse::MessageCase SubscribeResponse::message_case() const {
  return SubscribeResponse::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UnsubscribeRequest

// .onos.e2t.e2.v1beta1.RequestHeaders headers = 1 [(.gogoproto.nullable) = false];
inline bool UnsubscribeRequest::_internal_has_headers() const {
  return this != internal_default_instance() && headers_ != nullptr;
}
inline bool UnsubscribeRequest::has_headers() const {
  return _internal_has_headers();
}
inline const ::onos::e2t::e2::v1beta1::RequestHeaders& UnsubscribeRequest::_internal_headers() const {
  const ::onos::e2t::e2::v1beta1::RequestHeaders* p = headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::RequestHeaders&>(
      ::onos::e2t::e2::v1beta1::_RequestHeaders_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::RequestHeaders& UnsubscribeRequest::headers() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.UnsubscribeRequest.headers)
  return _internal_headers();
}
inline void UnsubscribeRequest::unsafe_arena_set_allocated_headers(
    ::onos::e2t::e2::v1beta1::RequestHeaders* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.UnsubscribeRequest.headers)
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* UnsubscribeRequest::release_headers() {
  
  ::onos::e2t::e2::v1beta1::RequestHeaders* temp = headers_;
  headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* UnsubscribeRequest::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.UnsubscribeRequest.headers)
  
  ::onos::e2t::e2::v1beta1::RequestHeaders* temp = headers_;
  headers_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* UnsubscribeRequest::_internal_mutable_headers() {
  
  if (headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::RequestHeaders>(GetArenaForAllocation());
    headers_ = p;
  }
  return headers_;
}
inline ::onos::e2t::e2::v1beta1::RequestHeaders* UnsubscribeRequest::mutable_headers() {
  ::onos::e2t::e2::v1beta1::RequestHeaders* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.UnsubscribeRequest.headers)
  return _msg;
}
inline void UnsubscribeRequest::set_allocated_headers(::onos::e2t::e2::v1beta1::RequestHeaders* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers));
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.UnsubscribeRequest.headers)
}

// string transaction_id = 2 [(.gogoproto.customname) = "TransactionID", (.gogoproto.casttype) = "TransactionID"];
inline void UnsubscribeRequest::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& UnsubscribeRequest::transaction_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.UnsubscribeRequest.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsubscribeRequest::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.UnsubscribeRequest.transaction_id)
}
inline std::string* UnsubscribeRequest::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.UnsubscribeRequest.transaction_id)
  return _s;
}
inline const std::string& UnsubscribeRequest::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void UnsubscribeRequest::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnsubscribeRequest::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnsubscribeRequest::release_transaction_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.UnsubscribeRequest.transaction_id)
  return transaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnsubscribeRequest::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.UnsubscribeRequest.transaction_id)
}

// -------------------------------------------------------------------

// UnsubscribeResponse

// .onos.e2t.e2.v1beta1.ResponseHeaders headers = 1 [(.gogoproto.nullable) = false];
inline bool UnsubscribeResponse::_internal_has_headers() const {
  return this != internal_default_instance() && headers_ != nullptr;
}
inline bool UnsubscribeResponse::has_headers() const {
  return _internal_has_headers();
}
inline const ::onos::e2t::e2::v1beta1::ResponseHeaders& UnsubscribeResponse::_internal_headers() const {
  const ::onos::e2t::e2::v1beta1::ResponseHeaders* p = headers_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ResponseHeaders&>(
      ::onos::e2t::e2::v1beta1::_ResponseHeaders_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ResponseHeaders& UnsubscribeResponse::headers() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.UnsubscribeResponse.headers)
  return _internal_headers();
}
inline void UnsubscribeResponse::unsafe_arena_set_allocated_headers(
    ::onos::e2t::e2::v1beta1::ResponseHeaders* headers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  headers_ = headers;
  if (headers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.UnsubscribeResponse.headers)
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* UnsubscribeResponse::release_headers() {
  
  ::onos::e2t::e2::v1beta1::ResponseHeaders* temp = headers_;
  headers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* UnsubscribeResponse::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.UnsubscribeResponse.headers)
  
  ::onos::e2t::e2::v1beta1::ResponseHeaders* temp = headers_;
  headers_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* UnsubscribeResponse::_internal_mutable_headers() {
  
  if (headers_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ResponseHeaders>(GetArenaForAllocation());
    headers_ = p;
  }
  return headers_;
}
inline ::onos::e2t::e2::v1beta1::ResponseHeaders* UnsubscribeResponse::mutable_headers() {
  ::onos::e2t::e2::v1beta1::ResponseHeaders* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.UnsubscribeResponse.headers)
  return _msg;
}
inline void UnsubscribeResponse::set_allocated_headers(::onos::e2t::e2::v1beta1::ResponseHeaders* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers_);
  }
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(headers));
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    
  } else {
    
  }
  headers_ = headers;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.UnsubscribeResponse.headers)
}

// -------------------------------------------------------------------

// SubscriptionSpec

// .onos.e2t.e2.v1beta1.EventTrigger event_trigger = 1 [(.gogoproto.nullable) = false];
inline bool SubscriptionSpec::_internal_has_event_trigger() const {
  return this != internal_default_instance() && event_trigger_ != nullptr;
}
inline bool SubscriptionSpec::has_event_trigger() const {
  return _internal_has_event_trigger();
}
inline void SubscriptionSpec::clear_event_trigger() {
  if (GetArenaForAllocation() == nullptr && event_trigger_ != nullptr) {
    delete event_trigger_;
  }
  event_trigger_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::EventTrigger& SubscriptionSpec::_internal_event_trigger() const {
  const ::onos::e2t::e2::v1beta1::EventTrigger* p = event_trigger_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::EventTrigger&>(
      ::onos::e2t::e2::v1beta1::_EventTrigger_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::EventTrigger& SubscriptionSpec::event_trigger() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionSpec.event_trigger)
  return _internal_event_trigger();
}
inline void SubscriptionSpec::unsafe_arena_set_allocated_event_trigger(
    ::onos::e2t::e2::v1beta1::EventTrigger* event_trigger) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_trigger_);
  }
  event_trigger_ = event_trigger;
  if (event_trigger) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscriptionSpec.event_trigger)
}
inline ::onos::e2t::e2::v1beta1::EventTrigger* SubscriptionSpec::release_event_trigger() {
  
  ::onos::e2t::e2::v1beta1::EventTrigger* temp = event_trigger_;
  event_trigger_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::EventTrigger* SubscriptionSpec::unsafe_arena_release_event_trigger() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscriptionSpec.event_trigger)
  
  ::onos::e2t::e2::v1beta1::EventTrigger* temp = event_trigger_;
  event_trigger_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::EventTrigger* SubscriptionSpec::_internal_mutable_event_trigger() {
  
  if (event_trigger_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::EventTrigger>(GetArenaForAllocation());
    event_trigger_ = p;
  }
  return event_trigger_;
}
inline ::onos::e2t::e2::v1beta1::EventTrigger* SubscriptionSpec::mutable_event_trigger() {
  ::onos::e2t::e2::v1beta1::EventTrigger* _msg = _internal_mutable_event_trigger();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionSpec.event_trigger)
  return _msg;
}
inline void SubscriptionSpec::set_allocated_event_trigger(::onos::e2t::e2::v1beta1::EventTrigger* event_trigger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete event_trigger_;
  }
  if (event_trigger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::EventTrigger>::GetOwningArena(event_trigger);
    if (message_arena != submessage_arena) {
      event_trigger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event_trigger, submessage_arena);
    }
    
  } else {
    
  }
  event_trigger_ = event_trigger;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscriptionSpec.event_trigger)
}

// repeated .onos.e2t.e2.v1beta1.Action actions = 2 [(.gogoproto.nullable) = false];
inline int SubscriptionSpec::_internal_actions_size() const {
  return actions_.size();
}
inline int SubscriptionSpec::actions_size() const {
  return _internal_actions_size();
}
inline void SubscriptionSpec::clear_actions() {
  actions_.Clear();
}
inline ::onos::e2t::e2::v1beta1::Action* SubscriptionSpec::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionSpec.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Action >*
SubscriptionSpec::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:onos.e2t.e2.v1beta1.SubscriptionSpec.actions)
  return &actions_;
}
inline const ::onos::e2t::e2::v1beta1::Action& SubscriptionSpec::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::onos::e2t::e2::v1beta1::Action& SubscriptionSpec::actions(int index) const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionSpec.actions)
  return _internal_actions(index);
}
inline ::onos::e2t::e2::v1beta1::Action* SubscriptionSpec::_internal_add_actions() {
  return actions_.Add();
}
inline ::onos::e2t::e2::v1beta1::Action* SubscriptionSpec::add_actions() {
  ::onos::e2t::e2::v1beta1::Action* _add = _internal_add_actions();
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.SubscriptionSpec.actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Action >&
SubscriptionSpec::actions() const {
  // @@protoc_insertion_point(field_list:onos.e2t.e2.v1beta1.SubscriptionSpec.actions)
  return actions_;
}

// -------------------------------------------------------------------

// EventTrigger

// bytes payload = 1;
inline void EventTrigger::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& EventTrigger::payload() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.EventTrigger.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventTrigger::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.EventTrigger.payload)
}
inline std::string* EventTrigger::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.EventTrigger.payload)
  return _s;
}
inline const std::string& EventTrigger::_internal_payload() const {
  return payload_.Get();
}
inline void EventTrigger::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventTrigger::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventTrigger::release_payload() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.EventTrigger.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventTrigger::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.EventTrigger.payload)
}

// -------------------------------------------------------------------

// Action

// int32 id = 1 [(.gogoproto.customname) = "ID"];
inline void Action::clear_id() {
  id_ = 0;
}
inline int32_t Action::_internal_id() const {
  return id_;
}
inline int32_t Action::id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Action.id)
  return _internal_id();
}
inline void Action::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void Action::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Action.id)
}

// .onos.e2t.e2.v1beta1.ActionType type = 2;
inline void Action::clear_type() {
  type_ = 0;
}
inline ::onos::e2t::e2::v1beta1::ActionType Action::_internal_type() const {
  return static_cast< ::onos::e2t::e2::v1beta1::ActionType >(type_);
}
inline ::onos::e2t::e2::v1beta1::ActionType Action::type() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Action.type)
  return _internal_type();
}
inline void Action::_internal_set_type(::onos::e2t::e2::v1beta1::ActionType value) {
  
  type_ = value;
}
inline void Action::set_type(::onos::e2t::e2::v1beta1::ActionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Action.type)
}

// bytes payload = 3;
inline void Action::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& Action::payload() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Action.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Action::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Action.payload)
}
inline std::string* Action::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Action.payload)
  return _s;
}
inline const std::string& Action::_internal_payload() const {
  return payload_.Get();
}
inline void Action::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Action::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Action::release_payload() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Action.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Action::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Action.payload)
}

// .onos.e2t.e2.v1beta1.SubsequentAction subsequent_action = 4;
inline bool Action::_internal_has_subsequent_action() const {
  return this != internal_default_instance() && subsequent_action_ != nullptr;
}
inline bool Action::has_subsequent_action() const {
  return _internal_has_subsequent_action();
}
inline void Action::clear_subsequent_action() {
  if (GetArenaForAllocation() == nullptr && subsequent_action_ != nullptr) {
    delete subsequent_action_;
  }
  subsequent_action_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubsequentAction& Action::_internal_subsequent_action() const {
  const ::onos::e2t::e2::v1beta1::SubsequentAction* p = subsequent_action_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubsequentAction&>(
      ::onos::e2t::e2::v1beta1::_SubsequentAction_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubsequentAction& Action::subsequent_action() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Action.subsequent_action)
  return _internal_subsequent_action();
}
inline void Action::unsafe_arena_set_allocated_subsequent_action(
    ::onos::e2t::e2::v1beta1::SubsequentAction* subsequent_action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subsequent_action_);
  }
  subsequent_action_ = subsequent_action;
  if (subsequent_action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Action.subsequent_action)
}
inline ::onos::e2t::e2::v1beta1::SubsequentAction* Action::release_subsequent_action() {
  
  ::onos::e2t::e2::v1beta1::SubsequentAction* temp = subsequent_action_;
  subsequent_action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubsequentAction* Action::unsafe_arena_release_subsequent_action() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Action.subsequent_action)
  
  ::onos::e2t::e2::v1beta1::SubsequentAction* temp = subsequent_action_;
  subsequent_action_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubsequentAction* Action::_internal_mutable_subsequent_action() {
  
  if (subsequent_action_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubsequentAction>(GetArenaForAllocation());
    subsequent_action_ = p;
  }
  return subsequent_action_;
}
inline ::onos::e2t::e2::v1beta1::SubsequentAction* Action::mutable_subsequent_action() {
  ::onos::e2t::e2::v1beta1::SubsequentAction* _msg = _internal_mutable_subsequent_action();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Action.subsequent_action)
  return _msg;
}
inline void Action::set_allocated_subsequent_action(::onos::e2t::e2::v1beta1::SubsequentAction* subsequent_action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subsequent_action_;
  }
  if (subsequent_action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubsequentAction>::GetOwningArena(subsequent_action);
    if (message_arena != submessage_arena) {
      subsequent_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subsequent_action, submessage_arena);
    }
    
  } else {
    
  }
  subsequent_action_ = subsequent_action;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Action.subsequent_action)
}

// -------------------------------------------------------------------

// SubsequentAction

// .onos.e2t.e2.v1beta1.SubsequentActionType type = 1;
inline void SubsequentAction::clear_type() {
  type_ = 0;
}
inline ::onos::e2t::e2::v1beta1::SubsequentActionType SubsequentAction::_internal_type() const {
  return static_cast< ::onos::e2t::e2::v1beta1::SubsequentActionType >(type_);
}
inline ::onos::e2t::e2::v1beta1::SubsequentActionType SubsequentAction::type() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubsequentAction.type)
  return _internal_type();
}
inline void SubsequentAction::_internal_set_type(::onos::e2t::e2::v1beta1::SubsequentActionType value) {
  
  type_ = value;
}
inline void SubsequentAction::set_type(::onos::e2t::e2::v1beta1::SubsequentActionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubsequentAction.type)
}

// .onos.e2t.e2.v1beta1.TimeToWait time_to_wait = 2;
inline void SubsequentAction::clear_time_to_wait() {
  time_to_wait_ = 0;
}
inline ::onos::e2t::e2::v1beta1::TimeToWait SubsequentAction::_internal_time_to_wait() const {
  return static_cast< ::onos::e2t::e2::v1beta1::TimeToWait >(time_to_wait_);
}
inline ::onos::e2t::e2::v1beta1::TimeToWait SubsequentAction::time_to_wait() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubsequentAction.time_to_wait)
  return _internal_time_to_wait();
}
inline void SubsequentAction::_internal_set_time_to_wait(::onos::e2t::e2::v1beta1::TimeToWait value) {
  
  time_to_wait_ = value;
}
inline void SubsequentAction::set_time_to_wait(::onos::e2t::e2::v1beta1::TimeToWait value) {
  _internal_set_time_to_wait(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubsequentAction.time_to_wait)
}

// -------------------------------------------------------------------

// Acknowledgement

// string channel_id = 1 [(.gogoproto.customname) = "ChannelID", (.gogoproto.casttype) = "ChannelID"];
inline void Acknowledgement::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& Acknowledgement::channel_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Acknowledgement.channel_id)
  return _internal_channel_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Acknowledgement::set_channel_id(ArgT0&& arg0, ArgT... args) {
 
 channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Acknowledgement.channel_id)
}
inline std::string* Acknowledgement::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Acknowledgement.channel_id)
  return _s;
}
inline const std::string& Acknowledgement::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void Acknowledgement::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Acknowledgement::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Acknowledgement::release_channel_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Acknowledgement.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Acknowledgement::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (channel_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    channel_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Acknowledgement.channel_id)
}

// -------------------------------------------------------------------

// Indication

// bytes header = 1;
inline void Indication::clear_header() {
  header_.ClearToEmpty();
}
inline const std::string& Indication::header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Indication.header)
  return _internal_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Indication::set_header(ArgT0&& arg0, ArgT... args) {
 
 header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Indication.header)
}
inline std::string* Indication::mutable_header() {
  std::string* _s = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Indication.header)
  return _s;
}
inline const std::string& Indication::_internal_header() const {
  return header_.Get();
}
inline void Indication::_internal_set_header(const std::string& value) {
  
  header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Indication::_internal_mutable_header() {
  
  return header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Indication::release_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Indication.header)
  return header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Indication::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    
  } else {
    
  }
  header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Indication.header)
}

// bytes payload = 2;
inline void Indication::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& Indication::payload() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Indication.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Indication::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Indication.payload)
}
inline std::string* Indication::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Indication.payload)
  return _s;
}
inline const std::string& Indication::_internal_payload() const {
  return payload_.Get();
}
inline void Indication::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Indication::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Indication::release_payload() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Indication.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Indication::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Indication.payload)
}

// -------------------------------------------------------------------

// GetChannelRequest

// string channel_id = 1 [(.gogoproto.customname) = "ChannelID", (.gogoproto.casttype) = "ChannelID"];
inline void GetChannelRequest::clear_channel_id() {
  channel_id_.ClearToEmpty();
}
inline const std::string& GetChannelRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.GetChannelRequest.channel_id)
  return _internal_channel_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetChannelRequest::set_channel_id(ArgT0&& arg0, ArgT... args) {
 
 channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.GetChannelRequest.channel_id)
}
inline std::string* GetChannelRequest::mutable_channel_id() {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.GetChannelRequest.channel_id)
  return _s;
}
inline const std::string& GetChannelRequest::_internal_channel_id() const {
  return channel_id_.Get();
}
inline void GetChannelRequest::_internal_set_channel_id(const std::string& value) {
  
  channel_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetChannelRequest::_internal_mutable_channel_id() {
  
  return channel_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetChannelRequest::release_channel_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.GetChannelRequest.channel_id)
  return channel_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetChannelRequest::set_allocated_channel_id(std::string* channel_id) {
  if (channel_id != nullptr) {
    
  } else {
    
  }
  channel_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), channel_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (channel_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    channel_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.GetChannelRequest.channel_id)
}

// -------------------------------------------------------------------

// GetChannelResponse

// .onos.e2t.e2.v1beta1.Channel channel = 1 [(.gogoproto.nullable) = false];
inline bool GetChannelResponse::_internal_has_channel() const {
  return this != internal_default_instance() && channel_ != nullptr;
}
inline bool GetChannelResponse::has_channel() const {
  return _internal_has_channel();
}
inline void GetChannelResponse::clear_channel() {
  if (GetArenaForAllocation() == nullptr && channel_ != nullptr) {
    delete channel_;
  }
  channel_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::Channel& GetChannelResponse::_internal_channel() const {
  const ::onos::e2t::e2::v1beta1::Channel* p = channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::Channel&>(
      ::onos::e2t::e2::v1beta1::_Channel_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Channel& GetChannelResponse::channel() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.GetChannelResponse.channel)
  return _internal_channel();
}
inline void GetChannelResponse::unsafe_arena_set_allocated_channel(
    ::onos::e2t::e2::v1beta1::Channel* channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(channel_);
  }
  channel_ = channel;
  if (channel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.GetChannelResponse.channel)
}
inline ::onos::e2t::e2::v1beta1::Channel* GetChannelResponse::release_channel() {
  
  ::onos::e2t::e2::v1beta1::Channel* temp = channel_;
  channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Channel* GetChannelResponse::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.GetChannelResponse.channel)
  
  ::onos::e2t::e2::v1beta1::Channel* temp = channel_;
  channel_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Channel* GetChannelResponse::_internal_mutable_channel() {
  
  if (channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::Channel>(GetArenaForAllocation());
    channel_ = p;
  }
  return channel_;
}
inline ::onos::e2t::e2::v1beta1::Channel* GetChannelResponse::mutable_channel() {
  ::onos::e2t::e2::v1beta1::Channel* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.GetChannelResponse.channel)
  return _msg;
}
inline void GetChannelResponse::set_allocated_channel(::onos::e2t::e2::v1beta1::Channel* channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete channel_;
  }
  if (channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::Channel>::GetOwningArena(channel);
    if (message_arena != submessage_arena) {
      channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    
  } else {
    
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.GetChannelResponse.channel)
}

// -------------------------------------------------------------------

// ListChannelsRequest

// -------------------------------------------------------------------

// ListChannelsResponse

// repeated .onos.e2t.e2.v1beta1.Channel channels = 1 [(.gogoproto.nullable) = false];
inline int ListChannelsResponse::_internal_channels_size() const {
  return channels_.size();
}
inline int ListChannelsResponse::channels_size() const {
  return _internal_channels_size();
}
inline void ListChannelsResponse::clear_channels() {
  channels_.Clear();
}
inline ::onos::e2t::e2::v1beta1::Channel* ListChannelsResponse::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ListChannelsResponse.channels)
  return channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Channel >*
ListChannelsResponse::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:onos.e2t.e2.v1beta1.ListChannelsResponse.channels)
  return &channels_;
}
inline const ::onos::e2t::e2::v1beta1::Channel& ListChannelsResponse::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline const ::onos::e2t::e2::v1beta1::Channel& ListChannelsResponse::channels(int index) const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ListChannelsResponse.channels)
  return _internal_channels(index);
}
inline ::onos::e2t::e2::v1beta1::Channel* ListChannelsResponse::_internal_add_channels() {
  return channels_.Add();
}
inline ::onos::e2t::e2::v1beta1::Channel* ListChannelsResponse::add_channels() {
  ::onos::e2t::e2::v1beta1::Channel* _add = _internal_add_channels();
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.ListChannelsResponse.channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Channel >&
ListChannelsResponse::channels() const {
  // @@protoc_insertion_point(field_list:onos.e2t.e2.v1beta1.ListChannelsResponse.channels)
  return channels_;
}

// -------------------------------------------------------------------

// WatchChannelsRequest

// bool no_replay = 1;
inline void WatchChannelsRequest::clear_no_replay() {
  no_replay_ = false;
}
inline bool WatchChannelsRequest::_internal_no_replay() const {
  return no_replay_;
}
inline bool WatchChannelsRequest::no_replay() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.WatchChannelsRequest.no_replay)
  return _internal_no_replay();
}
inline void WatchChannelsRequest::_internal_set_no_replay(bool value) {
  
  no_replay_ = value;
}
inline void WatchChannelsRequest::set_no_replay(bool value) {
  _internal_set_no_replay(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.WatchChannelsRequest.no_replay)
}

// -------------------------------------------------------------------

// WatchChannelsResponse

// .onos.e2t.e2.v1beta1.ChannelEvent event = 1 [(.gogoproto.nullable) = false];
inline bool WatchChannelsResponse::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool WatchChannelsResponse::has_event() const {
  return _internal_has_event();
}
inline void WatchChannelsResponse::clear_event() {
  if (GetArenaForAllocation() == nullptr && event_ != nullptr) {
    delete event_;
  }
  event_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::ChannelEvent& WatchChannelsResponse::_internal_event() const {
  const ::onos::e2t::e2::v1beta1::ChannelEvent* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ChannelEvent&>(
      ::onos::e2t::e2::v1beta1::_ChannelEvent_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ChannelEvent& WatchChannelsResponse::event() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.WatchChannelsResponse.event)
  return _internal_event();
}
inline void WatchChannelsResponse::unsafe_arena_set_allocated_event(
    ::onos::e2t::e2::v1beta1::ChannelEvent* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.WatchChannelsResponse.event)
}
inline ::onos::e2t::e2::v1beta1::ChannelEvent* WatchChannelsResponse::release_event() {
  
  ::onos::e2t::e2::v1beta1::ChannelEvent* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelEvent* WatchChannelsResponse::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.WatchChannelsResponse.event)
  
  ::onos::e2t::e2::v1beta1::ChannelEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelEvent* WatchChannelsResponse::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelEvent>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::onos::e2t::e2::v1beta1::ChannelEvent* WatchChannelsResponse::mutable_event() {
  ::onos::e2t::e2::v1beta1::ChannelEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.WatchChannelsResponse.event)
  return _msg;
}
inline void WatchChannelsResponse::set_allocated_event(::onos::e2t::e2::v1beta1::ChannelEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::ChannelEvent>::GetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.WatchChannelsResponse.event)
}

// -------------------------------------------------------------------

// ChannelEvent

// .onos.e2t.e2.v1beta1.ChannelEventType type = 1;
inline void ChannelEvent::clear_type() {
  type_ = 0;
}
inline ::onos::e2t::e2::v1beta1::ChannelEventType ChannelEvent::_internal_type() const {
  return static_cast< ::onos::e2t::e2::v1beta1::ChannelEventType >(type_);
}
inline ::onos::e2t::e2::v1beta1::ChannelEventType ChannelEvent::type() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelEvent.type)
  return _internal_type();
}
inline void ChannelEvent::_internal_set_type(::onos::e2t::e2::v1beta1::ChannelEventType value) {
  
  type_ = value;
}
inline void ChannelEvent::set_type(::onos::e2t::e2::v1beta1::ChannelEventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelEvent.type)
}

// .onos.e2t.e2.v1beta1.Channel channel = 2 [(.gogoproto.nullable) = false];
inline bool ChannelEvent::_internal_has_channel() const {
  return this != internal_default_instance() && channel_ != nullptr;
}
inline bool ChannelEvent::has_channel() const {
  return _internal_has_channel();
}
inline void ChannelEvent::clear_channel() {
  if (GetArenaForAllocation() == nullptr && channel_ != nullptr) {
    delete channel_;
  }
  channel_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::Channel& ChannelEvent::_internal_channel() const {
  const ::onos::e2t::e2::v1beta1::Channel* p = channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::Channel&>(
      ::onos::e2t::e2::v1beta1::_Channel_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Channel& ChannelEvent::channel() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelEvent.channel)
  return _internal_channel();
}
inline void ChannelEvent::unsafe_arena_set_allocated_channel(
    ::onos::e2t::e2::v1beta1::Channel* channel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(channel_);
  }
  channel_ = channel;
  if (channel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.ChannelEvent.channel)
}
inline ::onos::e2t::e2::v1beta1::Channel* ChannelEvent::release_channel() {
  
  ::onos::e2t::e2::v1beta1::Channel* temp = channel_;
  channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Channel* ChannelEvent::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelEvent.channel)
  
  ::onos::e2t::e2::v1beta1::Channel* temp = channel_;
  channel_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Channel* ChannelEvent::_internal_mutable_channel() {
  
  if (channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::Channel>(GetArenaForAllocation());
    channel_ = p;
  }
  return channel_;
}
inline ::onos::e2t::e2::v1beta1::Channel* ChannelEvent::mutable_channel() {
  ::onos::e2t::e2::v1beta1::Channel* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelEvent.channel)
  return _msg;
}
inline void ChannelEvent::set_allocated_channel(::onos::e2t::e2::v1beta1::Channel* channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete channel_;
  }
  if (channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::Channel>::GetOwningArena(channel);
    if (message_arena != submessage_arena) {
      channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, channel, submessage_arena);
    }
    
  } else {
    
  }
  channel_ = channel;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelEvent.channel)
}

// -------------------------------------------------------------------

// GetSubscriptionRequest

// string subscription_id = 1 [(.gogoproto.customname) = "SubscriptionID", (.gogoproto.casttype) = "SubscriptionID"];
inline void GetSubscriptionRequest::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& GetSubscriptionRequest::subscription_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.GetSubscriptionRequest.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSubscriptionRequest::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.GetSubscriptionRequest.subscription_id)
}
inline std::string* GetSubscriptionRequest::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.GetSubscriptionRequest.subscription_id)
  return _s;
}
inline const std::string& GetSubscriptionRequest::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void GetSubscriptionRequest::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSubscriptionRequest::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSubscriptionRequest::release_subscription_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.GetSubscriptionRequest.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSubscriptionRequest::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subscription_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subscription_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.GetSubscriptionRequest.subscription_id)
}

// -------------------------------------------------------------------

// GetSubscriptionResponse

// .onos.e2t.e2.v1beta1.Subscription subscription = 1 [(.gogoproto.nullable) = false];
inline bool GetSubscriptionResponse::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool GetSubscriptionResponse::has_subscription() const {
  return _internal_has_subscription();
}
inline void GetSubscriptionResponse::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::Subscription& GetSubscriptionResponse::_internal_subscription() const {
  const ::onos::e2t::e2::v1beta1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::Subscription&>(
      ::onos::e2t::e2::v1beta1::_Subscription_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Subscription& GetSubscriptionResponse::subscription() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.GetSubscriptionResponse.subscription)
  return _internal_subscription();
}
inline void GetSubscriptionResponse::unsafe_arena_set_allocated_subscription(
    ::onos::e2t::e2::v1beta1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.GetSubscriptionResponse.subscription)
}
inline ::onos::e2t::e2::v1beta1::Subscription* GetSubscriptionResponse::release_subscription() {
  
  ::onos::e2t::e2::v1beta1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Subscription* GetSubscriptionResponse::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.GetSubscriptionResponse.subscription)
  
  ::onos::e2t::e2::v1beta1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Subscription* GetSubscriptionResponse::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::onos::e2t::e2::v1beta1::Subscription* GetSubscriptionResponse::mutable_subscription() {
  ::onos::e2t::e2::v1beta1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.GetSubscriptionResponse.subscription)
  return _msg;
}
inline void GetSubscriptionResponse::set_allocated_subscription(::onos::e2t::e2::v1beta1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::Subscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.GetSubscriptionResponse.subscription)
}

// -------------------------------------------------------------------

// ListSubscriptionsRequest

// -------------------------------------------------------------------

// ListSubscriptionsResponse

// repeated .onos.e2t.e2.v1beta1.Subscription subscriptions = 1 [(.gogoproto.nullable) = false];
inline int ListSubscriptionsResponse::_internal_subscriptions_size() const {
  return subscriptions_.size();
}
inline int ListSubscriptionsResponse::subscriptions_size() const {
  return _internal_subscriptions_size();
}
inline void ListSubscriptionsResponse::clear_subscriptions() {
  subscriptions_.Clear();
}
inline ::onos::e2t::e2::v1beta1::Subscription* ListSubscriptionsResponse::mutable_subscriptions(int index) {
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ListSubscriptionsResponse.subscriptions)
  return subscriptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Subscription >*
ListSubscriptionsResponse::mutable_subscriptions() {
  // @@protoc_insertion_point(field_mutable_list:onos.e2t.e2.v1beta1.ListSubscriptionsResponse.subscriptions)
  return &subscriptions_;
}
inline const ::onos::e2t::e2::v1beta1::Subscription& ListSubscriptionsResponse::_internal_subscriptions(int index) const {
  return subscriptions_.Get(index);
}
inline const ::onos::e2t::e2::v1beta1::Subscription& ListSubscriptionsResponse::subscriptions(int index) const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ListSubscriptionsResponse.subscriptions)
  return _internal_subscriptions(index);
}
inline ::onos::e2t::e2::v1beta1::Subscription* ListSubscriptionsResponse::_internal_add_subscriptions() {
  return subscriptions_.Add();
}
inline ::onos::e2t::e2::v1beta1::Subscription* ListSubscriptionsResponse::add_subscriptions() {
  ::onos::e2t::e2::v1beta1::Subscription* _add = _internal_add_subscriptions();
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.ListSubscriptionsResponse.subscriptions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::onos::e2t::e2::v1beta1::Subscription >&
ListSubscriptionsResponse::subscriptions() const {
  // @@protoc_insertion_point(field_list:onos.e2t.e2.v1beta1.ListSubscriptionsResponse.subscriptions)
  return subscriptions_;
}

// -------------------------------------------------------------------

// WatchSubscriptionsRequest

// bool no_replay = 1;
inline void WatchSubscriptionsRequest::clear_no_replay() {
  no_replay_ = false;
}
inline bool WatchSubscriptionsRequest::_internal_no_replay() const {
  return no_replay_;
}
inline bool WatchSubscriptionsRequest::no_replay() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.WatchSubscriptionsRequest.no_replay)
  return _internal_no_replay();
}
inline void WatchSubscriptionsRequest::_internal_set_no_replay(bool value) {
  
  no_replay_ = value;
}
inline void WatchSubscriptionsRequest::set_no_replay(bool value) {
  _internal_set_no_replay(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.WatchSubscriptionsRequest.no_replay)
}

// -------------------------------------------------------------------

// WatchSubscriptionsResponse

// .onos.e2t.e2.v1beta1.SubscriptionEvent event = 1 [(.gogoproto.nullable) = false];
inline bool WatchSubscriptionsResponse::_internal_has_event() const {
  return this != internal_default_instance() && event_ != nullptr;
}
inline bool WatchSubscriptionsResponse::has_event() const {
  return _internal_has_event();
}
inline void WatchSubscriptionsResponse::clear_event() {
  if (GetArenaForAllocation() == nullptr && event_ != nullptr) {
    delete event_;
  }
  event_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionEvent& WatchSubscriptionsResponse::_internal_event() const {
  const ::onos::e2t::e2::v1beta1::SubscriptionEvent* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubscriptionEvent&>(
      ::onos::e2t::e2::v1beta1::_SubscriptionEvent_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionEvent& WatchSubscriptionsResponse::event() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse.event)
  return _internal_event();
}
inline void WatchSubscriptionsResponse::unsafe_arena_set_allocated_event(
    ::onos::e2t::e2::v1beta1::SubscriptionEvent* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse.event)
}
inline ::onos::e2t::e2::v1beta1::SubscriptionEvent* WatchSubscriptionsResponse::release_event() {
  
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionEvent* WatchSubscriptionsResponse::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse.event)
  
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionEvent* WatchSubscriptionsResponse::_internal_mutable_event() {
  
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionEvent>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionEvent* WatchSubscriptionsResponse::mutable_event() {
  ::onos::e2t::e2::v1beta1::SubscriptionEvent* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse.event)
  return _msg;
}
inline void WatchSubscriptionsResponse::set_allocated_event(::onos::e2t::e2::v1beta1::SubscriptionEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubscriptionEvent>::GetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    
  } else {
    
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.WatchSubscriptionsResponse.event)
}

// -------------------------------------------------------------------

// SubscriptionEvent

// .onos.e2t.e2.v1beta1.SubscriptionEventType type = 1;
inline void SubscriptionEvent::clear_type() {
  type_ = 0;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionEventType SubscriptionEvent::_internal_type() const {
  return static_cast< ::onos::e2t::e2::v1beta1::SubscriptionEventType >(type_);
}
inline ::onos::e2t::e2::v1beta1::SubscriptionEventType SubscriptionEvent::type() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionEvent.type)
  return _internal_type();
}
inline void SubscriptionEvent::_internal_set_type(::onos::e2t::e2::v1beta1::SubscriptionEventType value) {
  
  type_ = value;
}
inline void SubscriptionEvent::set_type(::onos::e2t::e2::v1beta1::SubscriptionEventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionEvent.type)
}

// .onos.e2t.e2.v1beta1.Subscription subscription = 2 [(.gogoproto.nullable) = false];
inline bool SubscriptionEvent::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool SubscriptionEvent::has_subscription() const {
  return _internal_has_subscription();
}
inline void SubscriptionEvent::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::Subscription& SubscriptionEvent::_internal_subscription() const {
  const ::onos::e2t::e2::v1beta1::Subscription* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::Subscription&>(
      ::onos::e2t::e2::v1beta1::_Subscription_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Subscription& SubscriptionEvent::subscription() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionEvent.subscription)
  return _internal_subscription();
}
inline void SubscriptionEvent::unsafe_arena_set_allocated_subscription(
    ::onos::e2t::e2::v1beta1::Subscription* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscriptionEvent.subscription)
}
inline ::onos::e2t::e2::v1beta1::Subscription* SubscriptionEvent::release_subscription() {
  
  ::onos::e2t::e2::v1beta1::Subscription* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Subscription* SubscriptionEvent::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscriptionEvent.subscription)
  
  ::onos::e2t::e2::v1beta1::Subscription* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Subscription* SubscriptionEvent::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::Subscription>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::onos::e2t::e2::v1beta1::Subscription* SubscriptionEvent::mutable_subscription() {
  ::onos::e2t::e2::v1beta1::Subscription* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionEvent.subscription)
  return _msg;
}
inline void SubscriptionEvent::set_allocated_subscription(::onos::e2t::e2::v1beta1::Subscription* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::Subscription>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscriptionEvent.subscription)
}

// -------------------------------------------------------------------

// ChannelMeta

// string app_id = 1 [(.gogoproto.customname) = "AppID", (.gogoproto.casttype) = "AppID"];
inline void ChannelMeta::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& ChannelMeta::app_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelMeta::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.app_id)
}
inline std::string* ChannelMeta::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.app_id)
  return _s;
}
inline const std::string& ChannelMeta::_internal_app_id() const {
  return app_id_.Get();
}
inline void ChannelMeta::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChannelMeta::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChannelMeta::release_app_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelMeta.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChannelMeta::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.app_id)
}

// string app_instance_id = 2 [(.gogoproto.customname) = "AppInstanceID", (.gogoproto.casttype) = "AppInstanceID"];
inline void ChannelMeta::clear_app_instance_id() {
  app_instance_id_.ClearToEmpty();
}
inline const std::string& ChannelMeta::app_instance_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.app_instance_id)
  return _internal_app_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelMeta::set_app_instance_id(ArgT0&& arg0, ArgT... args) {
 
 app_instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.app_instance_id)
}
inline std::string* ChannelMeta::mutable_app_instance_id() {
  std::string* _s = _internal_mutable_app_instance_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.app_instance_id)
  return _s;
}
inline const std::string& ChannelMeta::_internal_app_instance_id() const {
  return app_instance_id_.Get();
}
inline void ChannelMeta::_internal_set_app_instance_id(const std::string& value) {
  
  app_instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChannelMeta::_internal_mutable_app_instance_id() {
  
  return app_instance_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChannelMeta::release_app_instance_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelMeta.app_instance_id)
  return app_instance_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChannelMeta::set_allocated_app_instance_id(std::string* app_instance_id) {
  if (app_instance_id != nullptr) {
    
  } else {
    
  }
  app_instance_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_instance_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_instance_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_instance_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.app_instance_id)
}

// string e2_node_id = 3 [(.gogoproto.customname) = "E2NodeID", (.gogoproto.casttype) = "E2NodeID"];
inline void ChannelMeta::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& ChannelMeta::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelMeta::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.e2_node_id)
}
inline std::string* ChannelMeta::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.e2_node_id)
  return _s;
}
inline const std::string& ChannelMeta::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void ChannelMeta::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChannelMeta::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChannelMeta::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelMeta.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChannelMeta::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.e2_node_id)
}

// string transaction_id = 4 [(.gogoproto.customname) = "TransactionID", (.gogoproto.casttype) = "TransactionID"];
inline void ChannelMeta::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& ChannelMeta::transaction_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelMeta::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.transaction_id)
}
inline std::string* ChannelMeta::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.transaction_id)
  return _s;
}
inline const std::string& ChannelMeta::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void ChannelMeta::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChannelMeta::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChannelMeta::release_transaction_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelMeta.transaction_id)
  return transaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChannelMeta::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transaction_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.transaction_id)
}

// string subscription_id = 5 [(.gogoproto.customname) = "SubscriptionID", (.gogoproto.casttype) = "SubscriptionID"];
inline void ChannelMeta::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& ChannelMeta::subscription_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelMeta::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.subscription_id)
}
inline std::string* ChannelMeta::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.subscription_id)
  return _s;
}
inline const std::string& ChannelMeta::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void ChannelMeta::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChannelMeta::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChannelMeta::release_subscription_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelMeta.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChannelMeta::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subscription_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subscription_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.subscription_id)
}

// .onos.e2t.e2.v1beta1.ServiceModel service_model = 6 [(.gogoproto.nullable) = false];
inline bool ChannelMeta::_internal_has_service_model() const {
  return this != internal_default_instance() && service_model_ != nullptr;
}
inline bool ChannelMeta::has_service_model() const {
  return _internal_has_service_model();
}
inline const ::onos::e2t::e2::v1beta1::ServiceModel& ChannelMeta::_internal_service_model() const {
  const ::onos::e2t::e2::v1beta1::ServiceModel* p = service_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ServiceModel&>(
      ::onos::e2t::e2::v1beta1::_ServiceModel_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ServiceModel& ChannelMeta::service_model() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.service_model)
  return _internal_service_model();
}
inline void ChannelMeta::unsafe_arena_set_allocated_service_model(
    ::onos::e2t::e2::v1beta1::ServiceModel* service_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model_);
  }
  service_model_ = service_model;
  if (service_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.service_model)
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* ChannelMeta::release_service_model() {
  
  ::onos::e2t::e2::v1beta1::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* ChannelMeta::unsafe_arena_release_service_model() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelMeta.service_model)
  
  ::onos::e2t::e2::v1beta1::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* ChannelMeta::_internal_mutable_service_model() {
  
  if (service_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ServiceModel>(GetArenaForAllocation());
    service_model_ = p;
  }
  return service_model_;
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* ChannelMeta::mutable_service_model() {
  ::onos::e2t::e2::v1beta1::ServiceModel* _msg = _internal_mutable_service_model();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.service_model)
  return _msg;
}
inline void ChannelMeta::set_allocated_service_model(::onos::e2t::e2::v1beta1::ServiceModel* service_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model_);
  }
  if (service_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model));
    if (message_arena != submessage_arena) {
      service_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_model, submessage_arena);
    }
    
  } else {
    
  }
  service_model_ = service_model;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelMeta.service_model)
}

// .onos.e2t.e2.v1beta1.Encoding encoding = 7;
inline void ChannelMeta::clear_encoding() {
  encoding_ = 0;
}
inline ::onos::e2t::e2::v1beta1::Encoding ChannelMeta::_internal_encoding() const {
  return static_cast< ::onos::e2t::e2::v1beta1::Encoding >(encoding_);
}
inline ::onos::e2t::e2::v1beta1::Encoding ChannelMeta::encoding() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.encoding)
  return _internal_encoding();
}
inline void ChannelMeta::_internal_set_encoding(::onos::e2t::e2::v1beta1::Encoding value) {
  
  encoding_ = value;
}
inline void ChannelMeta::set_encoding(::onos::e2t::e2::v1beta1::Encoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.encoding)
}

// uint64 revision = 8 [(.gogoproto.casttype) = "Revision"];
inline void ChannelMeta::clear_revision() {
  revision_ = uint64_t{0u};
}
inline uint64_t ChannelMeta::_internal_revision() const {
  return revision_;
}
inline uint64_t ChannelMeta::revision() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.revision)
  return _internal_revision();
}
inline void ChannelMeta::_internal_set_revision(uint64_t value) {
  
  revision_ = value;
}
inline void ChannelMeta::set_revision(uint64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.revision)
}

// repeated string finalizers = 9;
inline int ChannelMeta::_internal_finalizers_size() const {
  return finalizers_.size();
}
inline int ChannelMeta::finalizers_size() const {
  return _internal_finalizers_size();
}
inline void ChannelMeta::clear_finalizers() {
  finalizers_.Clear();
}
inline std::string* ChannelMeta::add_finalizers() {
  std::string* _s = _internal_add_finalizers();
  // @@protoc_insertion_point(field_add_mutable:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
  return _s;
}
inline const std::string& ChannelMeta::_internal_finalizers(int index) const {
  return finalizers_.Get(index);
}
inline const std::string& ChannelMeta::finalizers(int index) const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
  return _internal_finalizers(index);
}
inline std::string* ChannelMeta::mutable_finalizers(int index) {
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
  return finalizers_.Mutable(index);
}
inline void ChannelMeta::set_finalizers(int index, const std::string& value) {
  finalizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline void ChannelMeta::set_finalizers(int index, std::string&& value) {
  finalizers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline void ChannelMeta::set_finalizers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  finalizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline void ChannelMeta::set_finalizers(int index, const char* value, size_t size) {
  finalizers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline std::string* ChannelMeta::_internal_add_finalizers() {
  return finalizers_.Add();
}
inline void ChannelMeta::add_finalizers(const std::string& value) {
  finalizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline void ChannelMeta::add_finalizers(std::string&& value) {
  finalizers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline void ChannelMeta::add_finalizers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  finalizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline void ChannelMeta::add_finalizers(const char* value, size_t size) {
  finalizers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ChannelMeta::finalizers() const {
  // @@protoc_insertion_point(field_list:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
  return finalizers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ChannelMeta::mutable_finalizers() {
  // @@protoc_insertion_point(field_mutable_list:onos.e2t.e2.v1beta1.ChannelMeta.finalizers)
  return &finalizers_;
}

// -------------------------------------------------------------------

// Channel

// string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "ChannelID"];
inline void Channel::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Channel::id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Channel.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Channel::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Channel.id)
}
inline std::string* Channel::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Channel.id)
  return _s;
}
inline const std::string& Channel::_internal_id() const {
  return id_.Get();
}
inline void Channel::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Channel::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Channel::release_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Channel.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Channel::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Channel.id)
}

// .onos.e2t.e2.v1beta1.ChannelMeta meta = 2 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool Channel::_internal_has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline bool Channel::has_meta() const {
  return _internal_has_meta();
}
inline void Channel::clear_meta() {
  if (GetArenaForAllocation() == nullptr && meta_ != nullptr) {
    delete meta_;
  }
  meta_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::ChannelMeta& Channel::_internal_meta() const {
  const ::onos::e2t::e2::v1beta1::ChannelMeta* p = meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ChannelMeta&>(
      ::onos::e2t::e2::v1beta1::_ChannelMeta_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ChannelMeta& Channel::meta() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Channel.meta)
  return _internal_meta();
}
inline void Channel::unsafe_arena_set_allocated_meta(
    ::onos::e2t::e2::v1beta1::ChannelMeta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Channel.meta)
}
inline ::onos::e2t::e2::v1beta1::ChannelMeta* Channel::release_meta() {
  
  ::onos::e2t::e2::v1beta1::ChannelMeta* temp = meta_;
  meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelMeta* Channel::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Channel.meta)
  
  ::onos::e2t::e2::v1beta1::ChannelMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelMeta* Channel::_internal_mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelMeta>(GetArenaForAllocation());
    meta_ = p;
  }
  return meta_;
}
inline ::onos::e2t::e2::v1beta1::ChannelMeta* Channel::mutable_meta() {
  ::onos::e2t::e2::v1beta1::ChannelMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Channel.meta)
  return _msg;
}
inline void Channel::set_allocated_meta(::onos::e2t::e2::v1beta1::ChannelMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::ChannelMeta>::GetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Channel.meta)
}

// .onos.e2t.e2.v1beta1.ChannelSpec spec = 3 [(.gogoproto.nullable) = false];
inline bool Channel::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Channel::has_spec() const {
  return _internal_has_spec();
}
inline void Channel::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::ChannelSpec& Channel::_internal_spec() const {
  const ::onos::e2t::e2::v1beta1::ChannelSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ChannelSpec&>(
      ::onos::e2t::e2::v1beta1::_ChannelSpec_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ChannelSpec& Channel::spec() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Channel.spec)
  return _internal_spec();
}
inline void Channel::unsafe_arena_set_allocated_spec(
    ::onos::e2t::e2::v1beta1::ChannelSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Channel.spec)
}
inline ::onos::e2t::e2::v1beta1::ChannelSpec* Channel::release_spec() {
  
  ::onos::e2t::e2::v1beta1::ChannelSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelSpec* Channel::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Channel.spec)
  
  ::onos::e2t::e2::v1beta1::ChannelSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelSpec* Channel::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::onos::e2t::e2::v1beta1::ChannelSpec* Channel::mutable_spec() {
  ::onos::e2t::e2::v1beta1::ChannelSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Channel.spec)
  return _msg;
}
inline void Channel::set_allocated_spec(::onos::e2t::e2::v1beta1::ChannelSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::ChannelSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Channel.spec)
}

// .onos.e2t.e2.v1beta1.ChannelStatus status = 4 [(.gogoproto.nullable) = false];
inline bool Channel::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Channel::has_status() const {
  return _internal_has_status();
}
inline void Channel::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::ChannelStatus& Channel::_internal_status() const {
  const ::onos::e2t::e2::v1beta1::ChannelStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ChannelStatus&>(
      ::onos::e2t::e2::v1beta1::_ChannelStatus_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ChannelStatus& Channel::status() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Channel.status)
  return _internal_status();
}
inline void Channel::unsafe_arena_set_allocated_status(
    ::onos::e2t::e2::v1beta1::ChannelStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Channel.status)
}
inline ::onos::e2t::e2::v1beta1::ChannelStatus* Channel::release_status() {
  
  ::onos::e2t::e2::v1beta1::ChannelStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelStatus* Channel::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Channel.status)
  
  ::onos::e2t::e2::v1beta1::ChannelStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ChannelStatus* Channel::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ChannelStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::e2t::e2::v1beta1::ChannelStatus* Channel::mutable_status() {
  ::onos::e2t::e2::v1beta1::ChannelStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Channel.status)
  return _msg;
}
inline void Channel::set_allocated_status(::onos::e2t::e2::v1beta1::ChannelStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::ChannelStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Channel.status)
}

// -------------------------------------------------------------------

// ChannelSpec

// .onos.e2t.e2.v1beta1.SubscriptionSpec subscription = 1 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool ChannelSpec::_internal_has_subscription() const {
  return this != internal_default_instance() && subscription_ != nullptr;
}
inline bool ChannelSpec::has_subscription() const {
  return _internal_has_subscription();
}
inline void ChannelSpec::clear_subscription() {
  if (GetArenaForAllocation() == nullptr && subscription_ != nullptr) {
    delete subscription_;
  }
  subscription_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionSpec& ChannelSpec::_internal_subscription() const {
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec* p = subscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubscriptionSpec&>(
      ::onos::e2t::e2::v1beta1::_SubscriptionSpec_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionSpec& ChannelSpec::subscription() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelSpec.subscription)
  return _internal_subscription();
}
inline void ChannelSpec::unsafe_arena_set_allocated_subscription(
    ::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subscription_);
  }
  subscription_ = subscription;
  if (subscription) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.ChannelSpec.subscription)
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* ChannelSpec::release_subscription() {
  
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* temp = subscription_;
  subscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* ChannelSpec::unsafe_arena_release_subscription() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelSpec.subscription)
  
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* temp = subscription_;
  subscription_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* ChannelSpec::_internal_mutable_subscription() {
  
  if (subscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionSpec>(GetArenaForAllocation());
    subscription_ = p;
  }
  return subscription_;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* ChannelSpec::mutable_subscription() {
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* _msg = _internal_mutable_subscription();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelSpec.subscription)
  return _msg;
}
inline void ChannelSpec::set_allocated_subscription(::onos::e2t::e2::v1beta1::SubscriptionSpec* subscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subscription_;
  }
  if (subscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubscriptionSpec>::GetOwningArena(subscription);
    if (message_arena != submessage_arena) {
      subscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscription, submessage_arena);
    }
    
  } else {
    
  }
  subscription_ = subscription;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelSpec.subscription)
}

// .google.protobuf.Duration transaction_timeout = 2 [(.gogoproto.stdduration) = true];
inline bool ChannelSpec::_internal_has_transaction_timeout() const {
  return this != internal_default_instance() && transaction_timeout_ != nullptr;
}
inline bool ChannelSpec::has_transaction_timeout() const {
  return _internal_has_transaction_timeout();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ChannelSpec::_internal_transaction_timeout() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = transaction_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& ChannelSpec::transaction_timeout() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelSpec.transaction_timeout)
  return _internal_transaction_timeout();
}
inline void ChannelSpec::unsafe_arena_set_allocated_transaction_timeout(
    ::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_timeout_);
  }
  transaction_timeout_ = transaction_timeout;
  if (transaction_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.ChannelSpec.transaction_timeout)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChannelSpec::release_transaction_timeout() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = transaction_timeout_;
  transaction_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChannelSpec::unsafe_arena_release_transaction_timeout() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelSpec.transaction_timeout)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = transaction_timeout_;
  transaction_timeout_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChannelSpec::_internal_mutable_transaction_timeout() {
  
  if (transaction_timeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    transaction_timeout_ = p;
  }
  return transaction_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* ChannelSpec::mutable_transaction_timeout() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_transaction_timeout();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelSpec.transaction_timeout)
  return _msg;
}
inline void ChannelSpec::set_allocated_transaction_timeout(::PROTOBUF_NAMESPACE_ID::Duration* transaction_timeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_timeout_);
  }
  if (transaction_timeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_timeout));
    if (message_arena != submessage_arena) {
      transaction_timeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction_timeout, submessage_arena);
    }
    
  } else {
    
  }
  transaction_timeout_ = transaction_timeout;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelSpec.transaction_timeout)
}

// -------------------------------------------------------------------

// ChannelStatus

// .onos.e2t.e2.v1beta1.ChannelPhase phase = 1;
inline void ChannelStatus::clear_phase() {
  phase_ = 0;
}
inline ::onos::e2t::e2::v1beta1::ChannelPhase ChannelStatus::_internal_phase() const {
  return static_cast< ::onos::e2t::e2::v1beta1::ChannelPhase >(phase_);
}
inline ::onos::e2t::e2::v1beta1::ChannelPhase ChannelStatus::phase() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelStatus.phase)
  return _internal_phase();
}
inline void ChannelStatus::_internal_set_phase(::onos::e2t::e2::v1beta1::ChannelPhase value) {
  
  phase_ = value;
}
inline void ChannelStatus::set_phase(::onos::e2t::e2::v1beta1::ChannelPhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelStatus.phase)
}

// .onos.e2t.e2.v1beta1.ChannelState state = 2;
inline void ChannelStatus::clear_state() {
  state_ = 0;
}
inline ::onos::e2t::e2::v1beta1::ChannelState ChannelStatus::_internal_state() const {
  return static_cast< ::onos::e2t::e2::v1beta1::ChannelState >(state_);
}
inline ::onos::e2t::e2::v1beta1::ChannelState ChannelStatus::state() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelStatus.state)
  return _internal_state();
}
inline void ChannelStatus::_internal_set_state(::onos::e2t::e2::v1beta1::ChannelState value) {
  
  state_ = value;
}
inline void ChannelStatus::set_state(::onos::e2t::e2::v1beta1::ChannelState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelStatus.state)
}

// .onos.e2t.e2.v1beta1.Error error = 3;
inline bool ChannelStatus::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool ChannelStatus::has_error() const {
  return _internal_has_error();
}
inline const ::onos::e2t::e2::v1beta1::Error& ChannelStatus::_internal_error() const {
  const ::onos::e2t::e2::v1beta1::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::Error&>(
      ::onos::e2t::e2::v1beta1::_Error_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Error& ChannelStatus::error() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelStatus.error)
  return _internal_error();
}
inline void ChannelStatus::unsafe_arena_set_allocated_error(
    ::onos::e2t::e2::v1beta1::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.ChannelStatus.error)
}
inline ::onos::e2t::e2::v1beta1::Error* ChannelStatus::release_error() {
  
  ::onos::e2t::e2::v1beta1::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Error* ChannelStatus::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelStatus.error)
  
  ::onos::e2t::e2::v1beta1::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Error* ChannelStatus::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::onos::e2t::e2::v1beta1::Error* ChannelStatus::mutable_error() {
  ::onos::e2t::e2::v1beta1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelStatus.error)
  return _msg;
}
inline void ChannelStatus::set_allocated_error(::onos::e2t::e2::v1beta1::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelStatus.error)
}

// .google.protobuf.Timestamp timestamp = 4 [(.gogoproto.stdtime) = true];
inline bool ChannelStatus::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool ChannelStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChannelStatus::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ChannelStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelStatus.timestamp)
  return _internal_timestamp();
}
inline void ChannelStatus::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.ChannelStatus.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChannelStatus::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChannelStatus::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelStatus.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChannelStatus::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ChannelStatus::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelStatus.timestamp)
  return _msg;
}
inline void ChannelStatus::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelStatus.timestamp)
}

// uint64 term = 5 [(.gogoproto.casttype) = "TermID"];
inline void ChannelStatus::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t ChannelStatus::_internal_term() const {
  return term_;
}
inline uint64_t ChannelStatus::term() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelStatus.term)
  return _internal_term();
}
inline void ChannelStatus::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void ChannelStatus::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelStatus.term)
}

// string master = 6 [(.gogoproto.casttype) = "MasterID"];
inline void ChannelStatus::clear_master() {
  master_.ClearToEmpty();
}
inline const std::string& ChannelStatus::master() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.ChannelStatus.master)
  return _internal_master();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChannelStatus::set_master(ArgT0&& arg0, ArgT... args) {
 
 master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.ChannelStatus.master)
}
inline std::string* ChannelStatus::mutable_master() {
  std::string* _s = _internal_mutable_master();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.ChannelStatus.master)
  return _s;
}
inline const std::string& ChannelStatus::_internal_master() const {
  return master_.Get();
}
inline void ChannelStatus::_internal_set_master(const std::string& value) {
  
  master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChannelStatus::_internal_mutable_master() {
  
  return master_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChannelStatus::release_master() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.ChannelStatus.master)
  return master_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChannelStatus::set_allocated_master(std::string* master) {
  if (master != nullptr) {
    
  } else {
    
  }
  master_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), master,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (master_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    master_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.ChannelStatus.master)
}

// -------------------------------------------------------------------

// SubscriptionMeta

// string e2_node_id = 1 [(.gogoproto.customname) = "E2NodeID", (.gogoproto.casttype) = "E2NodeID"];
inline void SubscriptionMeta::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& SubscriptionMeta::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionMeta.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionMeta::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionMeta.e2_node_id)
}
inline std::string* SubscriptionMeta::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionMeta.e2_node_id)
  return _s;
}
inline const std::string& SubscriptionMeta::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void SubscriptionMeta::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionMeta::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionMeta::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscriptionMeta.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionMeta::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscriptionMeta.e2_node_id)
}

// .onos.e2t.e2.v1beta1.ServiceModel service_model = 2 [(.gogoproto.nullable) = false];
inline bool SubscriptionMeta::_internal_has_service_model() const {
  return this != internal_default_instance() && service_model_ != nullptr;
}
inline bool SubscriptionMeta::has_service_model() const {
  return _internal_has_service_model();
}
inline const ::onos::e2t::e2::v1beta1::ServiceModel& SubscriptionMeta::_internal_service_model() const {
  const ::onos::e2t::e2::v1beta1::ServiceModel* p = service_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::ServiceModel&>(
      ::onos::e2t::e2::v1beta1::_ServiceModel_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::ServiceModel& SubscriptionMeta::service_model() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionMeta.service_model)
  return _internal_service_model();
}
inline void SubscriptionMeta::unsafe_arena_set_allocated_service_model(
    ::onos::e2t::e2::v1beta1::ServiceModel* service_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model_);
  }
  service_model_ = service_model;
  if (service_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscriptionMeta.service_model)
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* SubscriptionMeta::release_service_model() {
  
  ::onos::e2t::e2::v1beta1::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* SubscriptionMeta::unsafe_arena_release_service_model() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscriptionMeta.service_model)
  
  ::onos::e2t::e2::v1beta1::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* SubscriptionMeta::_internal_mutable_service_model() {
  
  if (service_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::ServiceModel>(GetArenaForAllocation());
    service_model_ = p;
  }
  return service_model_;
}
inline ::onos::e2t::e2::v1beta1::ServiceModel* SubscriptionMeta::mutable_service_model() {
  ::onos::e2t::e2::v1beta1::ServiceModel* _msg = _internal_mutable_service_model();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionMeta.service_model)
  return _msg;
}
inline void SubscriptionMeta::set_allocated_service_model(::onos::e2t::e2::v1beta1::ServiceModel* service_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model_);
  }
  if (service_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model));
    if (message_arena != submessage_arena) {
      service_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_model, submessage_arena);
    }
    
  } else {
    
  }
  service_model_ = service_model;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscriptionMeta.service_model)
}

// .onos.e2t.e2.v1beta1.Encoding encoding = 3;
inline void SubscriptionMeta::clear_encoding() {
  encoding_ = 0;
}
inline ::onos::e2t::e2::v1beta1::Encoding SubscriptionMeta::_internal_encoding() const {
  return static_cast< ::onos::e2t::e2::v1beta1::Encoding >(encoding_);
}
inline ::onos::e2t::e2::v1beta1::Encoding SubscriptionMeta::encoding() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionMeta.encoding)
  return _internal_encoding();
}
inline void SubscriptionMeta::_internal_set_encoding(::onos::e2t::e2::v1beta1::Encoding value) {
  
  encoding_ = value;
}
inline void SubscriptionMeta::set_encoding(::onos::e2t::e2::v1beta1::Encoding value) {
  _internal_set_encoding(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionMeta.encoding)
}

// uint64 revision = 4 [(.gogoproto.casttype) = "Revision"];
inline void SubscriptionMeta::clear_revision() {
  revision_ = uint64_t{0u};
}
inline uint64_t SubscriptionMeta::_internal_revision() const {
  return revision_;
}
inline uint64_t SubscriptionMeta::revision() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionMeta.revision)
  return _internal_revision();
}
inline void SubscriptionMeta::_internal_set_revision(uint64_t value) {
  
  revision_ = value;
}
inline void SubscriptionMeta::set_revision(uint64_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionMeta.revision)
}

// repeated string finalizers = 5;
inline int SubscriptionMeta::_internal_finalizers_size() const {
  return finalizers_.size();
}
inline int SubscriptionMeta::finalizers_size() const {
  return _internal_finalizers_size();
}
inline void SubscriptionMeta::clear_finalizers() {
  finalizers_.Clear();
}
inline std::string* SubscriptionMeta::add_finalizers() {
  std::string* _s = _internal_add_finalizers();
  // @@protoc_insertion_point(field_add_mutable:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
  return _s;
}
inline const std::string& SubscriptionMeta::_internal_finalizers(int index) const {
  return finalizers_.Get(index);
}
inline const std::string& SubscriptionMeta::finalizers(int index) const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
  return _internal_finalizers(index);
}
inline std::string* SubscriptionMeta::mutable_finalizers(int index) {
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
  return finalizers_.Mutable(index);
}
inline void SubscriptionMeta::set_finalizers(int index, const std::string& value) {
  finalizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline void SubscriptionMeta::set_finalizers(int index, std::string&& value) {
  finalizers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline void SubscriptionMeta::set_finalizers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  finalizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline void SubscriptionMeta::set_finalizers(int index, const char* value, size_t size) {
  finalizers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline std::string* SubscriptionMeta::_internal_add_finalizers() {
  return finalizers_.Add();
}
inline void SubscriptionMeta::add_finalizers(const std::string& value) {
  finalizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline void SubscriptionMeta::add_finalizers(std::string&& value) {
  finalizers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline void SubscriptionMeta::add_finalizers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  finalizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline void SubscriptionMeta::add_finalizers(const char* value, size_t size) {
  finalizers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubscriptionMeta::finalizers() const {
  // @@protoc_insertion_point(field_list:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
  return finalizers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubscriptionMeta::mutable_finalizers() {
  // @@protoc_insertion_point(field_mutable_list:onos.e2t.e2.v1beta1.SubscriptionMeta.finalizers)
  return &finalizers_;
}

// -------------------------------------------------------------------

// Subscription

// string id = 1 [(.gogoproto.customname) = "ID", (.gogoproto.casttype) = "SubscriptionID"];
inline void Subscription::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Subscription::id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Subscription.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Subscription::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.Subscription.id)
}
inline std::string* Subscription::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Subscription.id)
  return _s;
}
inline const std::string& Subscription::_internal_id() const {
  return id_.Get();
}
inline void Subscription::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Subscription::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Subscription::release_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Subscription.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Subscription::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Subscription.id)
}

// .onos.e2t.e2.v1beta1.SubscriptionMeta meta = 2 [(.gogoproto.nullable) = false, (.gogoproto.embed) = true];
inline bool Subscription::_internal_has_meta() const {
  return this != internal_default_instance() && meta_ != nullptr;
}
inline bool Subscription::has_meta() const {
  return _internal_has_meta();
}
inline void Subscription::clear_meta() {
  if (GetArenaForAllocation() == nullptr && meta_ != nullptr) {
    delete meta_;
  }
  meta_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionMeta& Subscription::_internal_meta() const {
  const ::onos::e2t::e2::v1beta1::SubscriptionMeta* p = meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubscriptionMeta&>(
      ::onos::e2t::e2::v1beta1::_SubscriptionMeta_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionMeta& Subscription::meta() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Subscription.meta)
  return _internal_meta();
}
inline void Subscription::unsafe_arena_set_allocated_meta(
    ::onos::e2t::e2::v1beta1::SubscriptionMeta* meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meta_);
  }
  meta_ = meta;
  if (meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Subscription.meta)
}
inline ::onos::e2t::e2::v1beta1::SubscriptionMeta* Subscription::release_meta() {
  
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* temp = meta_;
  meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionMeta* Subscription::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Subscription.meta)
  
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionMeta* Subscription::_internal_mutable_meta() {
  
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionMeta>(GetArenaForAllocation());
    meta_ = p;
  }
  return meta_;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionMeta* Subscription::mutable_meta() {
  ::onos::e2t::e2::v1beta1::SubscriptionMeta* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Subscription.meta)
  return _msg;
}
inline void Subscription::set_allocated_meta(::onos::e2t::e2::v1beta1::SubscriptionMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubscriptionMeta>::GetOwningArena(meta);
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    
  } else {
    
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Subscription.meta)
}

// .onos.e2t.e2.v1beta1.SubscriptionSpec spec = 3 [(.gogoproto.nullable) = false];
inline bool Subscription::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Subscription::has_spec() const {
  return _internal_has_spec();
}
inline void Subscription::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionSpec& Subscription::_internal_spec() const {
  const ::onos::e2t::e2::v1beta1::SubscriptionSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubscriptionSpec&>(
      ::onos::e2t::e2::v1beta1::_SubscriptionSpec_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionSpec& Subscription::spec() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Subscription.spec)
  return _internal_spec();
}
inline void Subscription::unsafe_arena_set_allocated_spec(
    ::onos::e2t::e2::v1beta1::SubscriptionSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Subscription.spec)
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* Subscription::release_spec() {
  
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* Subscription::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Subscription.spec)
  
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* Subscription::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionSpec* Subscription::mutable_spec() {
  ::onos::e2t::e2::v1beta1::SubscriptionSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Subscription.spec)
  return _msg;
}
inline void Subscription::set_allocated_spec(::onos::e2t::e2::v1beta1::SubscriptionSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubscriptionSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Subscription.spec)
}

// .onos.e2t.e2.v1beta1.SubscriptionStatus status = 4 [(.gogoproto.nullable) = false];
inline bool Subscription::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Subscription::has_status() const {
  return _internal_has_status();
}
inline void Subscription::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionStatus& Subscription::_internal_status() const {
  const ::onos::e2t::e2::v1beta1::SubscriptionStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::SubscriptionStatus&>(
      ::onos::e2t::e2::v1beta1::_SubscriptionStatus_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::SubscriptionStatus& Subscription::status() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.Subscription.status)
  return _internal_status();
}
inline void Subscription::unsafe_arena_set_allocated_status(
    ::onos::e2t::e2::v1beta1::SubscriptionStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.Subscription.status)
}
inline ::onos::e2t::e2::v1beta1::SubscriptionStatus* Subscription::release_status() {
  
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionStatus* Subscription::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.Subscription.status)
  
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionStatus* Subscription::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::SubscriptionStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionStatus* Subscription::mutable_status() {
  ::onos::e2t::e2::v1beta1::SubscriptionStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.Subscription.status)
  return _msg;
}
inline void Subscription::set_allocated_status(::onos::e2t::e2::v1beta1::SubscriptionStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::v1beta1::SubscriptionStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.Subscription.status)
}

// -------------------------------------------------------------------

// SubscriptionStatus

// .onos.e2t.e2.v1beta1.SubscriptionPhase phase = 1;
inline void SubscriptionStatus::clear_phase() {
  phase_ = 0;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionPhase SubscriptionStatus::_internal_phase() const {
  return static_cast< ::onos::e2t::e2::v1beta1::SubscriptionPhase >(phase_);
}
inline ::onos::e2t::e2::v1beta1::SubscriptionPhase SubscriptionStatus::phase() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionStatus.phase)
  return _internal_phase();
}
inline void SubscriptionStatus::_internal_set_phase(::onos::e2t::e2::v1beta1::SubscriptionPhase value) {
  
  phase_ = value;
}
inline void SubscriptionStatus::set_phase(::onos::e2t::e2::v1beta1::SubscriptionPhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionStatus.phase)
}

// .onos.e2t.e2.v1beta1.SubscriptionState state = 2;
inline void SubscriptionStatus::clear_state() {
  state_ = 0;
}
inline ::onos::e2t::e2::v1beta1::SubscriptionState SubscriptionStatus::_internal_state() const {
  return static_cast< ::onos::e2t::e2::v1beta1::SubscriptionState >(state_);
}
inline ::onos::e2t::e2::v1beta1::SubscriptionState SubscriptionStatus::state() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionStatus.state)
  return _internal_state();
}
inline void SubscriptionStatus::_internal_set_state(::onos::e2t::e2::v1beta1::SubscriptionState value) {
  
  state_ = value;
}
inline void SubscriptionStatus::set_state(::onos::e2t::e2::v1beta1::SubscriptionState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionStatus.state)
}

// .onos.e2t.e2.v1beta1.Error error = 3;
inline bool SubscriptionStatus::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool SubscriptionStatus::has_error() const {
  return _internal_has_error();
}
inline const ::onos::e2t::e2::v1beta1::Error& SubscriptionStatus::_internal_error() const {
  const ::onos::e2t::e2::v1beta1::Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::v1beta1::Error&>(
      ::onos::e2t::e2::v1beta1::_Error_default_instance_);
}
inline const ::onos::e2t::e2::v1beta1::Error& SubscriptionStatus::error() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionStatus.error)
  return _internal_error();
}
inline void SubscriptionStatus::unsafe_arena_set_allocated_error(
    ::onos::e2t::e2::v1beta1::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.v1beta1.SubscriptionStatus.error)
}
inline ::onos::e2t::e2::v1beta1::Error* SubscriptionStatus::release_error() {
  
  ::onos::e2t::e2::v1beta1::Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Error* SubscriptionStatus::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscriptionStatus.error)
  
  ::onos::e2t::e2::v1beta1::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::v1beta1::Error* SubscriptionStatus::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::v1beta1::Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::onos::e2t::e2::v1beta1::Error* SubscriptionStatus::mutable_error() {
  ::onos::e2t::e2::v1beta1::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionStatus.error)
  return _msg;
}
inline void SubscriptionStatus::set_allocated_error(::onos::e2t::e2::v1beta1::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscriptionStatus.error)
}

// repeated string channels = 4 [(.gogoproto.casttype) = "ChannelID"];
inline int SubscriptionStatus::_internal_channels_size() const {
  return channels_.size();
}
inline int SubscriptionStatus::channels_size() const {
  return _internal_channels_size();
}
inline void SubscriptionStatus::clear_channels() {
  channels_.Clear();
}
inline std::string* SubscriptionStatus::add_channels() {
  std::string* _s = _internal_add_channels();
  // @@protoc_insertion_point(field_add_mutable:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
  return _s;
}
inline const std::string& SubscriptionStatus::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline const std::string& SubscriptionStatus::channels(int index) const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
  return _internal_channels(index);
}
inline std::string* SubscriptionStatus::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
  return channels_.Mutable(index);
}
inline void SubscriptionStatus::set_channels(int index, const std::string& value) {
  channels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline void SubscriptionStatus::set_channels(int index, std::string&& value) {
  channels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline void SubscriptionStatus::set_channels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  channels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline void SubscriptionStatus::set_channels(int index, const char* value, size_t size) {
  channels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline std::string* SubscriptionStatus::_internal_add_channels() {
  return channels_.Add();
}
inline void SubscriptionStatus::add_channels(const std::string& value) {
  channels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline void SubscriptionStatus::add_channels(std::string&& value) {
  channels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline void SubscriptionStatus::add_channels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  channels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline void SubscriptionStatus::add_channels(const char* value, size_t size) {
  channels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubscriptionStatus::channels() const {
  // @@protoc_insertion_point(field_list:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
  return channels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubscriptionStatus::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:onos.e2t.e2.v1beta1.SubscriptionStatus.channels)
  return &channels_;
}

// uint64 term = 5 [(.gogoproto.casttype) = "TermID"];
inline void SubscriptionStatus::clear_term() {
  term_ = uint64_t{0u};
}
inline uint64_t SubscriptionStatus::_internal_term() const {
  return term_;
}
inline uint64_t SubscriptionStatus::term() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionStatus.term)
  return _internal_term();
}
inline void SubscriptionStatus::_internal_set_term(uint64_t value) {
  
  term_ = value;
}
inline void SubscriptionStatus::set_term(uint64_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionStatus.term)
}

// string master = 6 [(.gogoproto.casttype) = "MasterID"];
inline void SubscriptionStatus::clear_master() {
  master_.ClearToEmpty();
}
inline const std::string& SubscriptionStatus::master() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.v1beta1.SubscriptionStatus.master)
  return _internal_master();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionStatus::set_master(ArgT0&& arg0, ArgT... args) {
 
 master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.v1beta1.SubscriptionStatus.master)
}
inline std::string* SubscriptionStatus::mutable_master() {
  std::string* _s = _internal_mutable_master();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.v1beta1.SubscriptionStatus.master)
  return _s;
}
inline const std::string& SubscriptionStatus::_internal_master() const {
  return master_.Get();
}
inline void SubscriptionStatus::_internal_set_master(const std::string& value) {
  
  master_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscriptionStatus::_internal_mutable_master() {
  
  return master_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscriptionStatus::release_master() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.v1beta1.SubscriptionStatus.master)
  return master_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscriptionStatus::set_allocated_master(std::string* master) {
  if (master != nullptr) {
    
  } else {
    
  }
  master_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), master,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (master_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    master_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.v1beta1.SubscriptionStatus.master)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1beta1
}  // namespace e2
}  // namespace e2t
}  // namespace onos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::ActionType>() {
  return ::onos::e2t::e2::v1beta1::ActionType_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::SubsequentActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::SubsequentActionType>() {
  return ::onos::e2t::e2::v1beta1::SubsequentActionType_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::TimeToWait> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::TimeToWait>() {
  return ::onos::e2t::e2::v1beta1::TimeToWait_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::ChannelEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::ChannelEventType>() {
  return ::onos::e2t::e2::v1beta1::ChannelEventType_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::SubscriptionEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::SubscriptionEventType>() {
  return ::onos::e2t::e2::v1beta1::SubscriptionEventType_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::ChannelPhase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::ChannelPhase>() {
  return ::onos::e2t::e2::v1beta1::ChannelPhase_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::ChannelState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::ChannelState>() {
  return ::onos::e2t::e2::v1beta1::ChannelState_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::SubscriptionPhase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::SubscriptionPhase>() {
  return ::onos::e2t::e2::v1beta1::SubscriptionPhase_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::v1beta1::SubscriptionState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::v1beta1::SubscriptionState>() {
  return ::onos::e2t::e2::v1beta1::SubscriptionState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onos_2fe2t_2fe2_2fv1beta1_2fsubscription_2eproto
