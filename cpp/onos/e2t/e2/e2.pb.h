// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onos/e2t/e2/e2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_onos_2fe2t_2fe2_2fe2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_onos_2fe2t_2fe2_2fe2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_onos_2fe2t_2fe2_2fe2_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_onos_2fe2t_2fe2_2fe2_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_onos_2fe2t_2fe2_2fe2_2eproto;
namespace onos {
namespace e2t {
namespace e2 {
class ControlAcknowledge;
struct ControlAcknowledgeDefaultTypeInternal;
extern ControlAcknowledgeDefaultTypeInternal _ControlAcknowledge_default_instance_;
class ControlFailure;
struct ControlFailureDefaultTypeInternal;
extern ControlFailureDefaultTypeInternal _ControlFailure_default_instance_;
class ControlRequest;
struct ControlRequestDefaultTypeInternal;
extern ControlRequestDefaultTypeInternal _ControlRequest_default_instance_;
class ControlResponse;
struct ControlResponseDefaultTypeInternal;
extern ControlResponseDefaultTypeInternal _ControlResponse_default_instance_;
class RequestHeader;
struct RequestHeaderDefaultTypeInternal;
extern RequestHeaderDefaultTypeInternal _RequestHeader_default_instance_;
class ResponseHeader;
struct ResponseHeaderDefaultTypeInternal;
extern ResponseHeaderDefaultTypeInternal _ResponseHeader_default_instance_;
class ServiceModel;
struct ServiceModelDefaultTypeInternal;
extern ServiceModelDefaultTypeInternal _ServiceModel_default_instance_;
class StreamRequest;
struct StreamRequestDefaultTypeInternal;
extern StreamRequestDefaultTypeInternal _StreamRequest_default_instance_;
class StreamResponse;
struct StreamResponseDefaultTypeInternal;
extern StreamResponseDefaultTypeInternal _StreamResponse_default_instance_;
}  // namespace e2
}  // namespace e2t
}  // namespace onos
PROTOBUF_NAMESPACE_OPEN
template<> ::onos::e2t::e2::ControlAcknowledge* Arena::CreateMaybeMessage<::onos::e2t::e2::ControlAcknowledge>(Arena*);
template<> ::onos::e2t::e2::ControlFailure* Arena::CreateMaybeMessage<::onos::e2t::e2::ControlFailure>(Arena*);
template<> ::onos::e2t::e2::ControlRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::ControlRequest>(Arena*);
template<> ::onos::e2t::e2::ControlResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::ControlResponse>(Arena*);
template<> ::onos::e2t::e2::RequestHeader* Arena::CreateMaybeMessage<::onos::e2t::e2::RequestHeader>(Arena*);
template<> ::onos::e2t::e2::ResponseHeader* Arena::CreateMaybeMessage<::onos::e2t::e2::ResponseHeader>(Arena*);
template<> ::onos::e2t::e2::ServiceModel* Arena::CreateMaybeMessage<::onos::e2t::e2::ServiceModel>(Arena*);
template<> ::onos::e2t::e2::StreamRequest* Arena::CreateMaybeMessage<::onos::e2t::e2::StreamRequest>(Arena*);
template<> ::onos::e2t::e2::StreamResponse* Arena::CreateMaybeMessage<::onos::e2t::e2::StreamResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace onos {
namespace e2t {
namespace e2 {

enum EncodingType : int {
  PROTO = 0,
  ASN1_PER = 1,
  ASN1_XER = 2,
  EncodingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncodingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncodingType_IsValid(int value);
constexpr EncodingType EncodingType_MIN = PROTO;
constexpr EncodingType EncodingType_MAX = ASN1_XER;
constexpr int EncodingType_ARRAYSIZE = EncodingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncodingType_descriptor();
template<typename T>
inline const std::string& EncodingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncodingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncodingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncodingType_descriptor(), enum_t_value);
}
inline bool EncodingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncodingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncodingType>(
    EncodingType_descriptor(), name, value);
}
enum ResponseStatus : int {
  FAILED = 0,
  SUCCEEDED = 1,
  REJECTED = 2,
  ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResponseStatus_IsValid(int value);
constexpr ResponseStatus ResponseStatus_MIN = FAILED;
constexpr ResponseStatus ResponseStatus_MAX = REJECTED;
constexpr int ResponseStatus_ARRAYSIZE = ResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseStatus_descriptor();
template<typename T>
inline const std::string& ResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseStatus_descriptor(), enum_t_value);
}
inline bool ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseStatus>(
    ResponseStatus_descriptor(), name, value);
}
enum Cause : int {
  CAUSE_UNKNOWN = 0,
  CAUSE_MISC_CONTROL_PROCESSING_OVERLOAD = 1,
  CAUSE_MISC_HARDWARE_FAILURE = 2,
  CAUSE_MISC_OM_INTERVENTION = 3,
  CAUSE_MISC_UNSPECIFIED = 4,
  CAUSE_PROTOCOL_TRANSFER_SYNTAX_ERROR = 5,
  CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_REJECT = 6,
  CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_IGNORE_AND_NOTIFY = 7,
  CAUSE_PROTOCOL_MESSAGE_NOT_COMPATIBLE_WITH_RECEIVER_STATE = 8,
  CAUSE_PROTOCOL_SEMANTIC_ERROR = 9,
  CAUSE_PROTOCOL_ABSTRACT_SYNTAX_ERROR_FALSELY_CONSTRUCTED_MESSAGE = 10,
  CAUSE_PROTOCOL_UNSPECIFIED = 11,
  CAUSE_RIC_RAN_FUNCTION_ID_INVALID = 12,
  CAUSE_RIC_ACTION_NOT_SUPPORTED = 13,
  CAUSE_RIC_EXCESSIVE_ACTIONS = 14,
  CAUSE_RIC_DUPLICATE_ACTION = 15,
  CAUSE_RIC_DUPLICATE_EVENT = 16,
  CAUSE_RIC_FUNCTION_RESOURCE_LIMIT = 17,
  CAUSE_RIC_REQUEST_ID_UNKNOWN = 18,
  CAUSE_RIC_INCONSISTENT_ACTION_SUBSEQUENT_ACTION_SEQUENCE = 19,
  CAUSE_RIC_CONTROL_MESSAGE_INVALID = 20,
  CAUSE_RIC_CALL_PROCESS_ID_INVALID = 21,
  CAUSE_RIC_UNSPECIFIED = 22,
  CAUSE_RICSERVICE_FUNCTION_NOT_REQUIRED = 23,
  CAUSE_RICSERVICE_EXCESSIVE_FUNCTIONS = 24,
  CAUSE_RICSERVICE_RIC_RESOURCE_LIMIT = 25,
  CAUSE_TRANSPORT_UNSPECIFIED = 26,
  CAUSE_TRANSPORT_TRANSPORT_RESOURCE_UNAVAILABLE = 27,
  Cause_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Cause_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Cause_IsValid(int value);
constexpr Cause Cause_MIN = CAUSE_UNKNOWN;
constexpr Cause Cause_MAX = CAUSE_TRANSPORT_TRANSPORT_RESOURCE_UNAVAILABLE;
constexpr int Cause_ARRAYSIZE = Cause_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Cause_descriptor();
template<typename T>
inline const std::string& Cause_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Cause>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Cause_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Cause_descriptor(), enum_t_value);
}
inline bool Cause_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Cause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Cause>(
    Cause_descriptor(), name, value);
}
enum ControlAckRequest : int {
  ACK = 0,
  NO_ACK = 1,
  NACK = 2,
  ControlAckRequest_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ControlAckRequest_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ControlAckRequest_IsValid(int value);
constexpr ControlAckRequest ControlAckRequest_MIN = ACK;
constexpr ControlAckRequest ControlAckRequest_MAX = NACK;
constexpr int ControlAckRequest_ARRAYSIZE = ControlAckRequest_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlAckRequest_descriptor();
template<typename T>
inline const std::string& ControlAckRequest_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlAckRequest>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlAckRequest_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlAckRequest_descriptor(), enum_t_value);
}
inline bool ControlAckRequest_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlAckRequest* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlAckRequest>(
    ControlAckRequest_descriptor(), name, value);
}
// ===================================================================

class ServiceModel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.ServiceModel) */ {
 public:
  inline ServiceModel() : ServiceModel(nullptr) {}
  ~ServiceModel() override;
  explicit constexpr ServiceModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceModel(const ServiceModel& from);
  ServiceModel(ServiceModel&& from) noexcept
    : ServiceModel() {
    *this = ::std::move(from);
  }

  inline ServiceModel& operator=(const ServiceModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceModel& operator=(ServiceModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceModel* internal_default_instance() {
    return reinterpret_cast<const ServiceModel*>(
               &_ServiceModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServiceModel& a, ServiceModel& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceModel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceModel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceModel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.ServiceModel";
  }
  protected:
  explicit ServiceModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string name = 1 [(.gogoproto.customname) = "Name", (.gogoproto.casttype) = "ServiceModelName"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2 [(.gogoproto.customname) = "Version", (.gogoproto.casttype) = "ServiceModelVersion"];
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.ServiceModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class RequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.RequestHeader) */ {
 public:
  inline RequestHeader() : RequestHeader(nullptr) {}
  ~RequestHeader() override;
  explicit constexpr RequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestHeader(const RequestHeader& from);
  RequestHeader(RequestHeader&& from) noexcept
    : RequestHeader() {
    *this = ::std::move(from);
  }

  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestHeader& operator=(RequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestHeader* internal_default_instance() {
    return reinterpret_cast<const RequestHeader*>(
               &_RequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestHeader& a, RequestHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.RequestHeader";
  }
  protected:
  explicit RequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceModelFieldNumber = 2,
    kEncodingTypeFieldNumber = 1,
  };
  // .onos.e2t.e2.ServiceModel service_model = 2;
  bool has_service_model() const;
  private:
  bool _internal_has_service_model() const;
  public:
  void clear_service_model();
  const ::onos::e2t::e2::ServiceModel& service_model() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::ServiceModel* release_service_model();
  ::onos::e2t::e2::ServiceModel* mutable_service_model();
  void set_allocated_service_model(::onos::e2t::e2::ServiceModel* service_model);
  private:
  const ::onos::e2t::e2::ServiceModel& _internal_service_model() const;
  ::onos::e2t::e2::ServiceModel* _internal_mutable_service_model();
  public:
  void unsafe_arena_set_allocated_service_model(
      ::onos::e2t::e2::ServiceModel* service_model);
  ::onos::e2t::e2::ServiceModel* unsafe_arena_release_service_model();

  // .onos.e2t.e2.EncodingType encoding_type = 1;
  void clear_encoding_type();
  ::onos::e2t::e2::EncodingType encoding_type() const;
  void set_encoding_type(::onos::e2t::e2::EncodingType value);
  private:
  ::onos::e2t::e2::EncodingType _internal_encoding_type() const;
  void _internal_set_encoding_type(::onos::e2t::e2::EncodingType value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.RequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::ServiceModel* service_model_;
  int encoding_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class ResponseHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.ResponseHeader) */ {
 public:
  inline ResponseHeader() : ResponseHeader(nullptr) {}
  ~ResponseHeader() override;
  explicit constexpr ResponseHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseHeader(const ResponseHeader& from);
  ResponseHeader(ResponseHeader&& from) noexcept
    : ResponseHeader() {
    *this = ::std::move(from);
  }

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseHeader& operator=(ResponseHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseHeader* internal_default_instance() {
    return reinterpret_cast<const ResponseHeader*>(
               &_ResponseHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ResponseHeader& a, ResponseHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.ResponseHeader";
  }
  protected:
  explicit ResponseHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceModelFieldNumber = 2,
    kEncodingTypeFieldNumber = 1,
    kResponseStatusFieldNumber = 3,
  };
  // .onos.e2t.e2.ServiceModel service_model = 2;
  bool has_service_model() const;
  private:
  bool _internal_has_service_model() const;
  public:
  void clear_service_model();
  const ::onos::e2t::e2::ServiceModel& service_model() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::ServiceModel* release_service_model();
  ::onos::e2t::e2::ServiceModel* mutable_service_model();
  void set_allocated_service_model(::onos::e2t::e2::ServiceModel* service_model);
  private:
  const ::onos::e2t::e2::ServiceModel& _internal_service_model() const;
  ::onos::e2t::e2::ServiceModel* _internal_mutable_service_model();
  public:
  void unsafe_arena_set_allocated_service_model(
      ::onos::e2t::e2::ServiceModel* service_model);
  ::onos::e2t::e2::ServiceModel* unsafe_arena_release_service_model();

  // .onos.e2t.e2.EncodingType encoding_type = 1;
  void clear_encoding_type();
  ::onos::e2t::e2::EncodingType encoding_type() const;
  void set_encoding_type(::onos::e2t::e2::EncodingType value);
  private:
  ::onos::e2t::e2::EncodingType _internal_encoding_type() const;
  void _internal_set_encoding_type(::onos::e2t::e2::EncodingType value);
  public:

  // .onos.e2t.e2.ResponseStatus response_status = 3;
  void clear_response_status();
  ::onos::e2t::e2::ResponseStatus response_status() const;
  void set_response_status(::onos::e2t::e2::ResponseStatus value);
  private:
  ::onos::e2t::e2::ResponseStatus _internal_response_status() const;
  void _internal_set_response_status(::onos::e2t::e2::ResponseStatus value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.ResponseHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::ServiceModel* service_model_;
  int encoding_type_;
  int response_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class StreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.StreamRequest) */ {
 public:
  inline StreamRequest() : StreamRequest(nullptr) {}
  ~StreamRequest() override;
  explicit constexpr StreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamRequest(const StreamRequest& from);
  StreamRequest(StreamRequest&& from) noexcept
    : StreamRequest() {
    *this = ::std::move(from);
  }

  inline StreamRequest& operator=(const StreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamRequest& operator=(StreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamRequest* internal_default_instance() {
    return reinterpret_cast<const StreamRequest*>(
               &_StreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StreamRequest& a, StreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.StreamRequest";
  }
  protected:
  explicit StreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppIdFieldNumber = 2,
    kInstanceIdFieldNumber = 3,
    kSubscriptionIdFieldNumber = 4,
    kHeaderFieldNumber = 1,
  };
  // string app_id = 2 [(.gogoproto.customname) = "AppID", (.gogoproto.casttype) = "AppID"];
  void clear_app_id();
  const std::string& app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* app_id);
  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
  std::string* _internal_mutable_app_id();
  public:

  // string instance_id = 3 [(.gogoproto.customname) = "InstanceID", (.gogoproto.casttype) = "InstanceID"];
  void clear_instance_id();
  const std::string& instance_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_id();
  PROTOBUF_NODISCARD std::string* release_instance_id();
  void set_allocated_instance_id(std::string* instance_id);
  private:
  const std::string& _internal_instance_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id(const std::string& value);
  std::string* _internal_mutable_instance_id();
  public:

  // string subscription_id = 4 [(.gogoproto.customname) = "SubscriptionID", (.gogoproto.casttype) = "SubscriptionID"];
  void clear_subscription_id();
  const std::string& subscription_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscription_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscription_id();
  PROTOBUF_NODISCARD std::string* release_subscription_id();
  void set_allocated_subscription_id(std::string* subscription_id);
  private:
  const std::string& _internal_subscription_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscription_id(const std::string& value);
  std::string* _internal_mutable_subscription_id();
  public:

  // .onos.e2t.e2.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::onos::e2t::e2::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::RequestHeader* release_header();
  ::onos::e2t::e2::RequestHeader* mutable_header();
  void set_allocated_header(::onos::e2t::e2::RequestHeader* header);
  private:
  const ::onos::e2t::e2::RequestHeader& _internal_header() const;
  ::onos::e2t::e2::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::onos::e2t::e2::RequestHeader* header);
  ::onos::e2t::e2::RequestHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.StreamRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscription_id_;
  ::onos::e2t::e2::RequestHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class StreamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.StreamResponse) */ {
 public:
  inline StreamResponse() : StreamResponse(nullptr) {}
  ~StreamResponse() override;
  explicit constexpr StreamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamResponse(const StreamResponse& from);
  StreamResponse(StreamResponse&& from) noexcept
    : StreamResponse() {
    *this = ::std::move(from);
  }

  inline StreamResponse& operator=(const StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamResponse& operator=(StreamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamResponse* internal_default_instance() {
    return reinterpret_cast<const StreamResponse*>(
               &_StreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StreamResponse& a, StreamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.StreamResponse";
  }
  protected:
  explicit StreamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndicationHeaderFieldNumber = 2,
    kIndicationMessageFieldNumber = 3,
    kHeaderFieldNumber = 1,
  };
  // bytes indication_header = 2;
  void clear_indication_header();
  const std::string& indication_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_indication_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_indication_header();
  PROTOBUF_NODISCARD std::string* release_indication_header();
  void set_allocated_indication_header(std::string* indication_header);
  private:
  const std::string& _internal_indication_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indication_header(const std::string& value);
  std::string* _internal_mutable_indication_header();
  public:

  // bytes indication_message = 3;
  void clear_indication_message();
  const std::string& indication_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_indication_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_indication_message();
  PROTOBUF_NODISCARD std::string* release_indication_message();
  void set_allocated_indication_message(std::string* indication_message);
  private:
  const std::string& _internal_indication_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_indication_message(const std::string& value);
  std::string* _internal_mutable_indication_message();
  public:

  // .onos.e2t.e2.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::onos::e2t::e2::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::ResponseHeader* release_header();
  ::onos::e2t::e2::ResponseHeader* mutable_header();
  void set_allocated_header(::onos::e2t::e2::ResponseHeader* header);
  private:
  const ::onos::e2t::e2::ResponseHeader& _internal_header() const;
  ::onos::e2t::e2::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::onos::e2t::e2::ResponseHeader* header);
  ::onos::e2t::e2::ResponseHeader* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.StreamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indication_header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr indication_message_;
  ::onos::e2t::e2::ResponseHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class ControlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.ControlRequest) */ {
 public:
  inline ControlRequest() : ControlRequest(nullptr) {}
  ~ControlRequest() override;
  explicit constexpr ControlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlRequest(const ControlRequest& from);
  ControlRequest(ControlRequest&& from) noexcept
    : ControlRequest() {
    *this = ::std::move(from);
  }

  inline ControlRequest& operator=(const ControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlRequest& operator=(ControlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlRequest* internal_default_instance() {
    return reinterpret_cast<const ControlRequest*>(
               &_ControlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ControlRequest& a, ControlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.ControlRequest";
  }
  protected:
  explicit ControlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kE2NodeIdFieldNumber = 2,
    kControlHeaderFieldNumber = 3,
    kControlMessageFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kControlAckRequestFieldNumber = 5,
  };
  // string e2_node_id = 2 [(.gogoproto.customname) = "E2NodeID", (.gogoproto.casttype) = "E2NodeID"];
  void clear_e2_node_id();
  const std::string& e2_node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e2_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e2_node_id();
  PROTOBUF_NODISCARD std::string* release_e2_node_id();
  void set_allocated_e2_node_id(std::string* e2_node_id);
  private:
  const std::string& _internal_e2_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e2_node_id(const std::string& value);
  std::string* _internal_mutable_e2_node_id();
  public:

  // bytes control_header = 3;
  void clear_control_header();
  const std::string& control_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_header();
  PROTOBUF_NODISCARD std::string* release_control_header();
  void set_allocated_control_header(std::string* control_header);
  private:
  const std::string& _internal_control_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_header(const std::string& value);
  std::string* _internal_mutable_control_header();
  public:

  // bytes control_message = 4;
  void clear_control_message();
  const std::string& control_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_message();
  PROTOBUF_NODISCARD std::string* release_control_message();
  void set_allocated_control_message(std::string* control_message);
  private:
  const std::string& _internal_control_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_message(const std::string& value);
  std::string* _internal_mutable_control_message();
  public:

  // .onos.e2t.e2.RequestHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::onos::e2t::e2::RequestHeader& header() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::RequestHeader* release_header();
  ::onos::e2t::e2::RequestHeader* mutable_header();
  void set_allocated_header(::onos::e2t::e2::RequestHeader* header);
  private:
  const ::onos::e2t::e2::RequestHeader& _internal_header() const;
  ::onos::e2t::e2::RequestHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::onos::e2t::e2::RequestHeader* header);
  ::onos::e2t::e2::RequestHeader* unsafe_arena_release_header();

  // .onos.e2t.e2.ControlAckRequest control_ack_request = 5;
  void clear_control_ack_request();
  ::onos::e2t::e2::ControlAckRequest control_ack_request() const;
  void set_control_ack_request(::onos::e2t::e2::ControlAckRequest value);
  private:
  ::onos::e2t::e2::ControlAckRequest _internal_control_ack_request() const;
  void _internal_set_control_ack_request(::onos::e2t::e2::ControlAckRequest value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.ControlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e2_node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_message_;
  ::onos::e2t::e2::RequestHeader* header_;
  int control_ack_request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class ControlResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.ControlResponse) */ {
 public:
  inline ControlResponse() : ControlResponse(nullptr) {}
  ~ControlResponse() override;
  explicit constexpr ControlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlResponse(const ControlResponse& from);
  ControlResponse(ControlResponse&& from) noexcept
    : ControlResponse() {
    *this = ::std::move(from);
  }

  inline ControlResponse& operator=(const ControlResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlResponse& operator=(ControlResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kControlAcknowledge = 2,
    kControlFailure = 3,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ControlResponse* internal_default_instance() {
    return reinterpret_cast<const ControlResponse*>(
               &_ControlResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControlResponse& a, ControlResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.ControlResponse";
  }
  protected:
  explicit ControlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kControlAcknowledgeFieldNumber = 2,
    kControlFailureFieldNumber = 3,
  };
  // .onos.e2t.e2.ResponseHeader header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::onos::e2t::e2::ResponseHeader& header() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::ResponseHeader* release_header();
  ::onos::e2t::e2::ResponseHeader* mutable_header();
  void set_allocated_header(::onos::e2t::e2::ResponseHeader* header);
  private:
  const ::onos::e2t::e2::ResponseHeader& _internal_header() const;
  ::onos::e2t::e2::ResponseHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::onos::e2t::e2::ResponseHeader* header);
  ::onos::e2t::e2::ResponseHeader* unsafe_arena_release_header();

  // .onos.e2t.e2.ControlAcknowledge control_acknowledge = 2;
  bool has_control_acknowledge() const;
  private:
  bool _internal_has_control_acknowledge() const;
  public:
  void clear_control_acknowledge();
  const ::onos::e2t::e2::ControlAcknowledge& control_acknowledge() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::ControlAcknowledge* release_control_acknowledge();
  ::onos::e2t::e2::ControlAcknowledge* mutable_control_acknowledge();
  void set_allocated_control_acknowledge(::onos::e2t::e2::ControlAcknowledge* control_acknowledge);
  private:
  const ::onos::e2t::e2::ControlAcknowledge& _internal_control_acknowledge() const;
  ::onos::e2t::e2::ControlAcknowledge* _internal_mutable_control_acknowledge();
  public:
  void unsafe_arena_set_allocated_control_acknowledge(
      ::onos::e2t::e2::ControlAcknowledge* control_acknowledge);
  ::onos::e2t::e2::ControlAcknowledge* unsafe_arena_release_control_acknowledge();

  // .onos.e2t.e2.ControlFailure control_failure = 3;
  bool has_control_failure() const;
  private:
  bool _internal_has_control_failure() const;
  public:
  void clear_control_failure();
  const ::onos::e2t::e2::ControlFailure& control_failure() const;
  PROTOBUF_NODISCARD ::onos::e2t::e2::ControlFailure* release_control_failure();
  ::onos::e2t::e2::ControlFailure* mutable_control_failure();
  void set_allocated_control_failure(::onos::e2t::e2::ControlFailure* control_failure);
  private:
  const ::onos::e2t::e2::ControlFailure& _internal_control_failure() const;
  ::onos::e2t::e2::ControlFailure* _internal_mutable_control_failure();
  public:
  void unsafe_arena_set_allocated_control_failure(
      ::onos::e2t::e2::ControlFailure* control_failure);
  ::onos::e2t::e2::ControlFailure* unsafe_arena_release_control_failure();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:onos.e2t.e2.ControlResponse)
 private:
  class _Internal;
  void set_has_control_acknowledge();
  void set_has_control_failure();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::onos::e2t::e2::ResponseHeader* header_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::onos::e2t::e2::ControlAcknowledge* control_acknowledge_;
    ::onos::e2t::e2::ControlFailure* control_failure_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class ControlAcknowledge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.ControlAcknowledge) */ {
 public:
  inline ControlAcknowledge() : ControlAcknowledge(nullptr) {}
  ~ControlAcknowledge() override;
  explicit constexpr ControlAcknowledge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlAcknowledge(const ControlAcknowledge& from);
  ControlAcknowledge(ControlAcknowledge&& from) noexcept
    : ControlAcknowledge() {
    *this = ::std::move(from);
  }

  inline ControlAcknowledge& operator=(const ControlAcknowledge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlAcknowledge& operator=(ControlAcknowledge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlAcknowledge& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlAcknowledge* internal_default_instance() {
    return reinterpret_cast<const ControlAcknowledge*>(
               &_ControlAcknowledge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControlAcknowledge& a, ControlAcknowledge& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlAcknowledge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlAcknowledge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlAcknowledge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlAcknowledge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlAcknowledge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlAcknowledge& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlAcknowledge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.ControlAcknowledge";
  }
  protected:
  explicit ControlAcknowledge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlOutcomeFieldNumber = 1,
  };
  // bytes control_outcome = 1;
  void clear_control_outcome();
  const std::string& control_outcome() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_outcome(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_outcome();
  PROTOBUF_NODISCARD std::string* release_control_outcome();
  void set_allocated_control_outcome(std::string* control_outcome);
  private:
  const std::string& _internal_control_outcome() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_outcome(const std::string& value);
  std::string* _internal_mutable_control_outcome();
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.ControlAcknowledge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_outcome_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// -------------------------------------------------------------------

class ControlFailure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:onos.e2t.e2.ControlFailure) */ {
 public:
  inline ControlFailure() : ControlFailure(nullptr) {}
  ~ControlFailure() override;
  explicit constexpr ControlFailure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlFailure(const ControlFailure& from);
  ControlFailure(ControlFailure&& from) noexcept
    : ControlFailure() {
    *this = ::std::move(from);
  }

  inline ControlFailure& operator=(const ControlFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlFailure& operator=(ControlFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlFailure* internal_default_instance() {
    return reinterpret_cast<const ControlFailure*>(
               &_ControlFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ControlFailure& a, ControlFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlFailure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlFailure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlFailure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlFailure& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlFailure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "onos.e2t.e2.ControlFailure";
  }
  protected:
  explicit ControlFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlOutcomeFieldNumber = 2,
    kMessageFieldNumber = 3,
    kCauseFieldNumber = 1,
  };
  // bytes control_outcome = 2;
  void clear_control_outcome();
  const std::string& control_outcome() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_control_outcome(ArgT0&& arg0, ArgT... args);
  std::string* mutable_control_outcome();
  PROTOBUF_NODISCARD std::string* release_control_outcome();
  void set_allocated_control_outcome(std::string* control_outcome);
  private:
  const std::string& _internal_control_outcome() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_control_outcome(const std::string& value);
  std::string* _internal_mutable_control_outcome();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .onos.e2t.e2.Cause cause = 1;
  void clear_cause();
  ::onos::e2t::e2::Cause cause() const;
  void set_cause(::onos::e2t::e2::Cause value);
  private:
  ::onos::e2t::e2::Cause _internal_cause() const;
  void _internal_set_cause(::onos::e2t::e2::Cause value);
  public:

  // @@protoc_insertion_point(class_scope:onos.e2t.e2.ControlFailure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr control_outcome_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int cause_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_onos_2fe2t_2fe2_2fe2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServiceModel

// string name = 1 [(.gogoproto.customname) = "Name", (.gogoproto.casttype) = "ServiceModelName"];
inline void ServiceModel::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServiceModel::name() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ServiceModel.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceModel::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ServiceModel.name)
}
inline std::string* ServiceModel::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ServiceModel.name)
  return _s;
}
inline const std::string& ServiceModel::_internal_name() const {
  return name_.Get();
}
inline void ServiceModel::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceModel::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceModel::release_name() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ServiceModel.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceModel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ServiceModel.name)
}

// string version = 2 [(.gogoproto.customname) = "Version", (.gogoproto.casttype) = "ServiceModelVersion"];
inline void ServiceModel::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ServiceModel::version() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ServiceModel.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceModel::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ServiceModel.version)
}
inline std::string* ServiceModel::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ServiceModel.version)
  return _s;
}
inline const std::string& ServiceModel::_internal_version() const {
  return version_.Get();
}
inline void ServiceModel::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceModel::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceModel::release_version() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ServiceModel.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceModel::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ServiceModel.version)
}

// -------------------------------------------------------------------

// RequestHeader

// .onos.e2t.e2.EncodingType encoding_type = 1;
inline void RequestHeader::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::onos::e2t::e2::EncodingType RequestHeader::_internal_encoding_type() const {
  return static_cast< ::onos::e2t::e2::EncodingType >(encoding_type_);
}
inline ::onos::e2t::e2::EncodingType RequestHeader::encoding_type() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.RequestHeader.encoding_type)
  return _internal_encoding_type();
}
inline void RequestHeader::_internal_set_encoding_type(::onos::e2t::e2::EncodingType value) {
  
  encoding_type_ = value;
}
inline void RequestHeader::set_encoding_type(::onos::e2t::e2::EncodingType value) {
  _internal_set_encoding_type(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.RequestHeader.encoding_type)
}

// .onos.e2t.e2.ServiceModel service_model = 2;
inline bool RequestHeader::_internal_has_service_model() const {
  return this != internal_default_instance() && service_model_ != nullptr;
}
inline bool RequestHeader::has_service_model() const {
  return _internal_has_service_model();
}
inline void RequestHeader::clear_service_model() {
  if (GetArenaForAllocation() == nullptr && service_model_ != nullptr) {
    delete service_model_;
  }
  service_model_ = nullptr;
}
inline const ::onos::e2t::e2::ServiceModel& RequestHeader::_internal_service_model() const {
  const ::onos::e2t::e2::ServiceModel* p = service_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::ServiceModel&>(
      ::onos::e2t::e2::_ServiceModel_default_instance_);
}
inline const ::onos::e2t::e2::ServiceModel& RequestHeader::service_model() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.RequestHeader.service_model)
  return _internal_service_model();
}
inline void RequestHeader::unsafe_arena_set_allocated_service_model(
    ::onos::e2t::e2::ServiceModel* service_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model_);
  }
  service_model_ = service_model;
  if (service_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.RequestHeader.service_model)
}
inline ::onos::e2t::e2::ServiceModel* RequestHeader::release_service_model() {
  
  ::onos::e2t::e2::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::ServiceModel* RequestHeader::unsafe_arena_release_service_model() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.RequestHeader.service_model)
  
  ::onos::e2t::e2::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::ServiceModel* RequestHeader::_internal_mutable_service_model() {
  
  if (service_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::ServiceModel>(GetArenaForAllocation());
    service_model_ = p;
  }
  return service_model_;
}
inline ::onos::e2t::e2::ServiceModel* RequestHeader::mutable_service_model() {
  ::onos::e2t::e2::ServiceModel* _msg = _internal_mutable_service_model();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.RequestHeader.service_model)
  return _msg;
}
inline void RequestHeader::set_allocated_service_model(::onos::e2t::e2::ServiceModel* service_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_model_;
  }
  if (service_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::ServiceModel>::GetOwningArena(service_model);
    if (message_arena != submessage_arena) {
      service_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_model, submessage_arena);
    }
    
  } else {
    
  }
  service_model_ = service_model;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.RequestHeader.service_model)
}

// -------------------------------------------------------------------

// ResponseHeader

// .onos.e2t.e2.EncodingType encoding_type = 1;
inline void ResponseHeader::clear_encoding_type() {
  encoding_type_ = 0;
}
inline ::onos::e2t::e2::EncodingType ResponseHeader::_internal_encoding_type() const {
  return static_cast< ::onos::e2t::e2::EncodingType >(encoding_type_);
}
inline ::onos::e2t::e2::EncodingType ResponseHeader::encoding_type() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ResponseHeader.encoding_type)
  return _internal_encoding_type();
}
inline void ResponseHeader::_internal_set_encoding_type(::onos::e2t::e2::EncodingType value) {
  
  encoding_type_ = value;
}
inline void ResponseHeader::set_encoding_type(::onos::e2t::e2::EncodingType value) {
  _internal_set_encoding_type(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ResponseHeader.encoding_type)
}

// .onos.e2t.e2.ServiceModel service_model = 2;
inline bool ResponseHeader::_internal_has_service_model() const {
  return this != internal_default_instance() && service_model_ != nullptr;
}
inline bool ResponseHeader::has_service_model() const {
  return _internal_has_service_model();
}
inline void ResponseHeader::clear_service_model() {
  if (GetArenaForAllocation() == nullptr && service_model_ != nullptr) {
    delete service_model_;
  }
  service_model_ = nullptr;
}
inline const ::onos::e2t::e2::ServiceModel& ResponseHeader::_internal_service_model() const {
  const ::onos::e2t::e2::ServiceModel* p = service_model_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::ServiceModel&>(
      ::onos::e2t::e2::_ServiceModel_default_instance_);
}
inline const ::onos::e2t::e2::ServiceModel& ResponseHeader::service_model() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ResponseHeader.service_model)
  return _internal_service_model();
}
inline void ResponseHeader::unsafe_arena_set_allocated_service_model(
    ::onos::e2t::e2::ServiceModel* service_model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_model_);
  }
  service_model_ = service_model;
  if (service_model) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.ResponseHeader.service_model)
}
inline ::onos::e2t::e2::ServiceModel* ResponseHeader::release_service_model() {
  
  ::onos::e2t::e2::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::ServiceModel* ResponseHeader::unsafe_arena_release_service_model() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ResponseHeader.service_model)
  
  ::onos::e2t::e2::ServiceModel* temp = service_model_;
  service_model_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::ServiceModel* ResponseHeader::_internal_mutable_service_model() {
  
  if (service_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::ServiceModel>(GetArenaForAllocation());
    service_model_ = p;
  }
  return service_model_;
}
inline ::onos::e2t::e2::ServiceModel* ResponseHeader::mutable_service_model() {
  ::onos::e2t::e2::ServiceModel* _msg = _internal_mutable_service_model();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ResponseHeader.service_model)
  return _msg;
}
inline void ResponseHeader::set_allocated_service_model(::onos::e2t::e2::ServiceModel* service_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_model_;
  }
  if (service_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::ServiceModel>::GetOwningArena(service_model);
    if (message_arena != submessage_arena) {
      service_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_model, submessage_arena);
    }
    
  } else {
    
  }
  service_model_ = service_model;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ResponseHeader.service_model)
}

// .onos.e2t.e2.ResponseStatus response_status = 3;
inline void ResponseHeader::clear_response_status() {
  response_status_ = 0;
}
inline ::onos::e2t::e2::ResponseStatus ResponseHeader::_internal_response_status() const {
  return static_cast< ::onos::e2t::e2::ResponseStatus >(response_status_);
}
inline ::onos::e2t::e2::ResponseStatus ResponseHeader::response_status() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ResponseHeader.response_status)
  return _internal_response_status();
}
inline void ResponseHeader::_internal_set_response_status(::onos::e2t::e2::ResponseStatus value) {
  
  response_status_ = value;
}
inline void ResponseHeader::set_response_status(::onos::e2t::e2::ResponseStatus value) {
  _internal_set_response_status(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ResponseHeader.response_status)
}

// -------------------------------------------------------------------

// StreamRequest

// .onos.e2t.e2.RequestHeader header = 1;
inline bool StreamRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StreamRequest::has_header() const {
  return _internal_has_header();
}
inline void StreamRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::onos::e2t::e2::RequestHeader& StreamRequest::_internal_header() const {
  const ::onos::e2t::e2::RequestHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::RequestHeader&>(
      ::onos::e2t::e2::_RequestHeader_default_instance_);
}
inline const ::onos::e2t::e2::RequestHeader& StreamRequest::header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamRequest.header)
  return _internal_header();
}
inline void StreamRequest::unsafe_arena_set_allocated_header(
    ::onos::e2t::e2::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.StreamRequest.header)
}
inline ::onos::e2t::e2::RequestHeader* StreamRequest::release_header() {
  
  ::onos::e2t::e2::RequestHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::RequestHeader* StreamRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamRequest.header)
  
  ::onos::e2t::e2::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::RequestHeader* StreamRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::RequestHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::onos::e2t::e2::RequestHeader* StreamRequest::mutable_header() {
  ::onos::e2t::e2::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamRequest.header)
  return _msg;
}
inline void StreamRequest::set_allocated_header(::onos::e2t::e2::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::RequestHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamRequest.header)
}

// string app_id = 2 [(.gogoproto.customname) = "AppID", (.gogoproto.casttype) = "AppID"];
inline void StreamRequest::clear_app_id() {
  app_id_.ClearToEmpty();
}
inline const std::string& StreamRequest::app_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamRequest.app_id)
  return _internal_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamRequest::set_app_id(ArgT0&& arg0, ArgT... args) {
 
 app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.StreamRequest.app_id)
}
inline std::string* StreamRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamRequest.app_id)
  return _s;
}
inline const std::string& StreamRequest::_internal_app_id() const {
  return app_id_.Get();
}
inline void StreamRequest::_internal_set_app_id(const std::string& value) {
  
  app_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamRequest::_internal_mutable_app_id() {
  
  return app_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamRequest::release_app_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamRequest.app_id)
  return app_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamRequest::set_allocated_app_id(std::string* app_id) {
  if (app_id != nullptr) {
    
  } else {
    
  }
  app_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamRequest.app_id)
}

// string instance_id = 3 [(.gogoproto.customname) = "InstanceID", (.gogoproto.casttype) = "InstanceID"];
inline void StreamRequest::clear_instance_id() {
  instance_id_.ClearToEmpty();
}
inline const std::string& StreamRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamRequest.instance_id)
  return _internal_instance_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamRequest::set_instance_id(ArgT0&& arg0, ArgT... args) {
 
 instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.StreamRequest.instance_id)
}
inline std::string* StreamRequest::mutable_instance_id() {
  std::string* _s = _internal_mutable_instance_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamRequest.instance_id)
  return _s;
}
inline const std::string& StreamRequest::_internal_instance_id() const {
  return instance_id_.Get();
}
inline void StreamRequest::_internal_set_instance_id(const std::string& value) {
  
  instance_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamRequest::_internal_mutable_instance_id() {
  
  return instance_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamRequest::release_instance_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamRequest.instance_id)
  return instance_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamRequest::set_allocated_instance_id(std::string* instance_id) {
  if (instance_id != nullptr) {
    
  } else {
    
  }
  instance_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instance_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    instance_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamRequest.instance_id)
}

// string subscription_id = 4 [(.gogoproto.customname) = "SubscriptionID", (.gogoproto.casttype) = "SubscriptionID"];
inline void StreamRequest::clear_subscription_id() {
  subscription_id_.ClearToEmpty();
}
inline const std::string& StreamRequest::subscription_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamRequest.subscription_id)
  return _internal_subscription_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamRequest::set_subscription_id(ArgT0&& arg0, ArgT... args) {
 
 subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.StreamRequest.subscription_id)
}
inline std::string* StreamRequest::mutable_subscription_id() {
  std::string* _s = _internal_mutable_subscription_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamRequest.subscription_id)
  return _s;
}
inline const std::string& StreamRequest::_internal_subscription_id() const {
  return subscription_id_.Get();
}
inline void StreamRequest::_internal_set_subscription_id(const std::string& value) {
  
  subscription_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamRequest::_internal_mutable_subscription_id() {
  
  return subscription_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamRequest::release_subscription_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamRequest.subscription_id)
  return subscription_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamRequest::set_allocated_subscription_id(std::string* subscription_id) {
  if (subscription_id != nullptr) {
    
  } else {
    
  }
  subscription_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subscription_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subscription_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subscription_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamRequest.subscription_id)
}

// -------------------------------------------------------------------

// StreamResponse

// .onos.e2t.e2.ResponseHeader header = 1;
inline bool StreamResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool StreamResponse::has_header() const {
  return _internal_has_header();
}
inline void StreamResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::onos::e2t::e2::ResponseHeader& StreamResponse::_internal_header() const {
  const ::onos::e2t::e2::ResponseHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::ResponseHeader&>(
      ::onos::e2t::e2::_ResponseHeader_default_instance_);
}
inline const ::onos::e2t::e2::ResponseHeader& StreamResponse::header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamResponse.header)
  return _internal_header();
}
inline void StreamResponse::unsafe_arena_set_allocated_header(
    ::onos::e2t::e2::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.StreamResponse.header)
}
inline ::onos::e2t::e2::ResponseHeader* StreamResponse::release_header() {
  
  ::onos::e2t::e2::ResponseHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::ResponseHeader* StreamResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamResponse.header)
  
  ::onos::e2t::e2::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::ResponseHeader* StreamResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::ResponseHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::onos::e2t::e2::ResponseHeader* StreamResponse::mutable_header() {
  ::onos::e2t::e2::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamResponse.header)
  return _msg;
}
inline void StreamResponse::set_allocated_header(::onos::e2t::e2::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::ResponseHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamResponse.header)
}

// bytes indication_header = 2;
inline void StreamResponse::clear_indication_header() {
  indication_header_.ClearToEmpty();
}
inline const std::string& StreamResponse::indication_header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamResponse.indication_header)
  return _internal_indication_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamResponse::set_indication_header(ArgT0&& arg0, ArgT... args) {
 
 indication_header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.StreamResponse.indication_header)
}
inline std::string* StreamResponse::mutable_indication_header() {
  std::string* _s = _internal_mutable_indication_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamResponse.indication_header)
  return _s;
}
inline const std::string& StreamResponse::_internal_indication_header() const {
  return indication_header_.Get();
}
inline void StreamResponse::_internal_set_indication_header(const std::string& value) {
  
  indication_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamResponse::_internal_mutable_indication_header() {
  
  return indication_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamResponse::release_indication_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamResponse.indication_header)
  return indication_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamResponse::set_allocated_indication_header(std::string* indication_header) {
  if (indication_header != nullptr) {
    
  } else {
    
  }
  indication_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indication_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (indication_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    indication_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamResponse.indication_header)
}

// bytes indication_message = 3;
inline void StreamResponse::clear_indication_message() {
  indication_message_.ClearToEmpty();
}
inline const std::string& StreamResponse::indication_message() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.StreamResponse.indication_message)
  return _internal_indication_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamResponse::set_indication_message(ArgT0&& arg0, ArgT... args) {
 
 indication_message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.StreamResponse.indication_message)
}
inline std::string* StreamResponse::mutable_indication_message() {
  std::string* _s = _internal_mutable_indication_message();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.StreamResponse.indication_message)
  return _s;
}
inline const std::string& StreamResponse::_internal_indication_message() const {
  return indication_message_.Get();
}
inline void StreamResponse::_internal_set_indication_message(const std::string& value) {
  
  indication_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamResponse::_internal_mutable_indication_message() {
  
  return indication_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamResponse::release_indication_message() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.StreamResponse.indication_message)
  return indication_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamResponse::set_allocated_indication_message(std::string* indication_message) {
  if (indication_message != nullptr) {
    
  } else {
    
  }
  indication_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), indication_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (indication_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    indication_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.StreamResponse.indication_message)
}

// -------------------------------------------------------------------

// ControlRequest

// .onos.e2t.e2.RequestHeader header = 1;
inline bool ControlRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ControlRequest::has_header() const {
  return _internal_has_header();
}
inline void ControlRequest::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::onos::e2t::e2::RequestHeader& ControlRequest::_internal_header() const {
  const ::onos::e2t::e2::RequestHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::RequestHeader&>(
      ::onos::e2t::e2::_RequestHeader_default_instance_);
}
inline const ::onos::e2t::e2::RequestHeader& ControlRequest::header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlRequest.header)
  return _internal_header();
}
inline void ControlRequest::unsafe_arena_set_allocated_header(
    ::onos::e2t::e2::RequestHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.ControlRequest.header)
}
inline ::onos::e2t::e2::RequestHeader* ControlRequest::release_header() {
  
  ::onos::e2t::e2::RequestHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::RequestHeader* ControlRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlRequest.header)
  
  ::onos::e2t::e2::RequestHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::RequestHeader* ControlRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::RequestHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::onos::e2t::e2::RequestHeader* ControlRequest::mutable_header() {
  ::onos::e2t::e2::RequestHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlRequest.header)
  return _msg;
}
inline void ControlRequest::set_allocated_header(::onos::e2t::e2::RequestHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::RequestHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlRequest.header)
}

// string e2_node_id = 2 [(.gogoproto.customname) = "E2NodeID", (.gogoproto.casttype) = "E2NodeID"];
inline void ControlRequest::clear_e2_node_id() {
  e2_node_id_.ClearToEmpty();
}
inline const std::string& ControlRequest::e2_node_id() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlRequest.e2_node_id)
  return _internal_e2_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlRequest::set_e2_node_id(ArgT0&& arg0, ArgT... args) {
 
 e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlRequest.e2_node_id)
}
inline std::string* ControlRequest::mutable_e2_node_id() {
  std::string* _s = _internal_mutable_e2_node_id();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlRequest.e2_node_id)
  return _s;
}
inline const std::string& ControlRequest::_internal_e2_node_id() const {
  return e2_node_id_.Get();
}
inline void ControlRequest::_internal_set_e2_node_id(const std::string& value) {
  
  e2_node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlRequest::_internal_mutable_e2_node_id() {
  
  return e2_node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlRequest::release_e2_node_id() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlRequest.e2_node_id)
  return e2_node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlRequest::set_allocated_e2_node_id(std::string* e2_node_id) {
  if (e2_node_id != nullptr) {
    
  } else {
    
  }
  e2_node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), e2_node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e2_node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    e2_node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlRequest.e2_node_id)
}

// bytes control_header = 3;
inline void ControlRequest::clear_control_header() {
  control_header_.ClearToEmpty();
}
inline const std::string& ControlRequest::control_header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlRequest.control_header)
  return _internal_control_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlRequest::set_control_header(ArgT0&& arg0, ArgT... args) {
 
 control_header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlRequest.control_header)
}
inline std::string* ControlRequest::mutable_control_header() {
  std::string* _s = _internal_mutable_control_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlRequest.control_header)
  return _s;
}
inline const std::string& ControlRequest::_internal_control_header() const {
  return control_header_.Get();
}
inline void ControlRequest::_internal_set_control_header(const std::string& value) {
  
  control_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlRequest::_internal_mutable_control_header() {
  
  return control_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlRequest::release_control_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlRequest.control_header)
  return control_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlRequest::set_allocated_control_header(std::string* control_header) {
  if (control_header != nullptr) {
    
  } else {
    
  }
  control_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), control_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (control_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    control_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlRequest.control_header)
}

// bytes control_message = 4;
inline void ControlRequest::clear_control_message() {
  control_message_.ClearToEmpty();
}
inline const std::string& ControlRequest::control_message() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlRequest.control_message)
  return _internal_control_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlRequest::set_control_message(ArgT0&& arg0, ArgT... args) {
 
 control_message_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlRequest.control_message)
}
inline std::string* ControlRequest::mutable_control_message() {
  std::string* _s = _internal_mutable_control_message();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlRequest.control_message)
  return _s;
}
inline const std::string& ControlRequest::_internal_control_message() const {
  return control_message_.Get();
}
inline void ControlRequest::_internal_set_control_message(const std::string& value) {
  
  control_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlRequest::_internal_mutable_control_message() {
  
  return control_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlRequest::release_control_message() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlRequest.control_message)
  return control_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlRequest::set_allocated_control_message(std::string* control_message) {
  if (control_message != nullptr) {
    
  } else {
    
  }
  control_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), control_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (control_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    control_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlRequest.control_message)
}

// .onos.e2t.e2.ControlAckRequest control_ack_request = 5;
inline void ControlRequest::clear_control_ack_request() {
  control_ack_request_ = 0;
}
inline ::onos::e2t::e2::ControlAckRequest ControlRequest::_internal_control_ack_request() const {
  return static_cast< ::onos::e2t::e2::ControlAckRequest >(control_ack_request_);
}
inline ::onos::e2t::e2::ControlAckRequest ControlRequest::control_ack_request() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlRequest.control_ack_request)
  return _internal_control_ack_request();
}
inline void ControlRequest::_internal_set_control_ack_request(::onos::e2t::e2::ControlAckRequest value) {
  
  control_ack_request_ = value;
}
inline void ControlRequest::set_control_ack_request(::onos::e2t::e2::ControlAckRequest value) {
  _internal_set_control_ack_request(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlRequest.control_ack_request)
}

// -------------------------------------------------------------------

// ControlResponse

// .onos.e2t.e2.ResponseHeader header = 1;
inline bool ControlResponse::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ControlResponse::has_header() const {
  return _internal_has_header();
}
inline void ControlResponse::clear_header() {
  if (GetArenaForAllocation() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::onos::e2t::e2::ResponseHeader& ControlResponse::_internal_header() const {
  const ::onos::e2t::e2::ResponseHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::onos::e2t::e2::ResponseHeader&>(
      ::onos::e2t::e2::_ResponseHeader_default_instance_);
}
inline const ::onos::e2t::e2::ResponseHeader& ControlResponse::header() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlResponse.header)
  return _internal_header();
}
inline void ControlResponse::unsafe_arena_set_allocated_header(
    ::onos::e2t::e2::ResponseHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.ControlResponse.header)
}
inline ::onos::e2t::e2::ResponseHeader* ControlResponse::release_header() {
  
  ::onos::e2t::e2::ResponseHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::onos::e2t::e2::ResponseHeader* ControlResponse::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlResponse.header)
  
  ::onos::e2t::e2::ResponseHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::onos::e2t::e2::ResponseHeader* ControlResponse::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::onos::e2t::e2::ResponseHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::onos::e2t::e2::ResponseHeader* ControlResponse::mutable_header() {
  ::onos::e2t::e2::ResponseHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlResponse.header)
  return _msg;
}
inline void ControlResponse::set_allocated_header(::onos::e2t::e2::ResponseHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::onos::e2t::e2::ResponseHeader>::GetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlResponse.header)
}

// .onos.e2t.e2.ControlAcknowledge control_acknowledge = 2;
inline bool ControlResponse::_internal_has_control_acknowledge() const {
  return response_case() == kControlAcknowledge;
}
inline bool ControlResponse::has_control_acknowledge() const {
  return _internal_has_control_acknowledge();
}
inline void ControlResponse::set_has_control_acknowledge() {
  _oneof_case_[0] = kControlAcknowledge;
}
inline void ControlResponse::clear_control_acknowledge() {
  if (_internal_has_control_acknowledge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete response_.control_acknowledge_;
    }
    clear_has_response();
  }
}
inline ::onos::e2t::e2::ControlAcknowledge* ControlResponse::release_control_acknowledge() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlResponse.control_acknowledge)
  if (_internal_has_control_acknowledge()) {
    clear_has_response();
      ::onos::e2t::e2::ControlAcknowledge* temp = response_.control_acknowledge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.control_acknowledge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::e2t::e2::ControlAcknowledge& ControlResponse::_internal_control_acknowledge() const {
  return _internal_has_control_acknowledge()
      ? *response_.control_acknowledge_
      : reinterpret_cast< ::onos::e2t::e2::ControlAcknowledge&>(::onos::e2t::e2::_ControlAcknowledge_default_instance_);
}
inline const ::onos::e2t::e2::ControlAcknowledge& ControlResponse::control_acknowledge() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlResponse.control_acknowledge)
  return _internal_control_acknowledge();
}
inline ::onos::e2t::e2::ControlAcknowledge* ControlResponse::unsafe_arena_release_control_acknowledge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.e2t.e2.ControlResponse.control_acknowledge)
  if (_internal_has_control_acknowledge()) {
    clear_has_response();
    ::onos::e2t::e2::ControlAcknowledge* temp = response_.control_acknowledge_;
    response_.control_acknowledge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlResponse::unsafe_arena_set_allocated_control_acknowledge(::onos::e2t::e2::ControlAcknowledge* control_acknowledge) {
  clear_response();
  if (control_acknowledge) {
    set_has_control_acknowledge();
    response_.control_acknowledge_ = control_acknowledge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.ControlResponse.control_acknowledge)
}
inline ::onos::e2t::e2::ControlAcknowledge* ControlResponse::_internal_mutable_control_acknowledge() {
  if (!_internal_has_control_acknowledge()) {
    clear_response();
    set_has_control_acknowledge();
    response_.control_acknowledge_ = CreateMaybeMessage< ::onos::e2t::e2::ControlAcknowledge >(GetArenaForAllocation());
  }
  return response_.control_acknowledge_;
}
inline ::onos::e2t::e2::ControlAcknowledge* ControlResponse::mutable_control_acknowledge() {
  ::onos::e2t::e2::ControlAcknowledge* _msg = _internal_mutable_control_acknowledge();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlResponse.control_acknowledge)
  return _msg;
}

// .onos.e2t.e2.ControlFailure control_failure = 3;
inline bool ControlResponse::_internal_has_control_failure() const {
  return response_case() == kControlFailure;
}
inline bool ControlResponse::has_control_failure() const {
  return _internal_has_control_failure();
}
inline void ControlResponse::set_has_control_failure() {
  _oneof_case_[0] = kControlFailure;
}
inline void ControlResponse::clear_control_failure() {
  if (_internal_has_control_failure()) {
    if (GetArenaForAllocation() == nullptr) {
      delete response_.control_failure_;
    }
    clear_has_response();
  }
}
inline ::onos::e2t::e2::ControlFailure* ControlResponse::release_control_failure() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlResponse.control_failure)
  if (_internal_has_control_failure()) {
    clear_has_response();
      ::onos::e2t::e2::ControlFailure* temp = response_.control_failure_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.control_failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::onos::e2t::e2::ControlFailure& ControlResponse::_internal_control_failure() const {
  return _internal_has_control_failure()
      ? *response_.control_failure_
      : reinterpret_cast< ::onos::e2t::e2::ControlFailure&>(::onos::e2t::e2::_ControlFailure_default_instance_);
}
inline const ::onos::e2t::e2::ControlFailure& ControlResponse::control_failure() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlResponse.control_failure)
  return _internal_control_failure();
}
inline ::onos::e2t::e2::ControlFailure* ControlResponse::unsafe_arena_release_control_failure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:onos.e2t.e2.ControlResponse.control_failure)
  if (_internal_has_control_failure()) {
    clear_has_response();
    ::onos::e2t::e2::ControlFailure* temp = response_.control_failure_;
    response_.control_failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlResponse::unsafe_arena_set_allocated_control_failure(::onos::e2t::e2::ControlFailure* control_failure) {
  clear_response();
  if (control_failure) {
    set_has_control_failure();
    response_.control_failure_ = control_failure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:onos.e2t.e2.ControlResponse.control_failure)
}
inline ::onos::e2t::e2::ControlFailure* ControlResponse::_internal_mutable_control_failure() {
  if (!_internal_has_control_failure()) {
    clear_response();
    set_has_control_failure();
    response_.control_failure_ = CreateMaybeMessage< ::onos::e2t::e2::ControlFailure >(GetArenaForAllocation());
  }
  return response_.control_failure_;
}
inline ::onos::e2t::e2::ControlFailure* ControlResponse::mutable_control_failure() {
  ::onos::e2t::e2::ControlFailure* _msg = _internal_mutable_control_failure();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlResponse.control_failure)
  return _msg;
}

inline bool ControlResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ControlResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ControlResponse::ResponseCase ControlResponse::response_case() const {
  return ControlResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControlAcknowledge

// bytes control_outcome = 1;
inline void ControlAcknowledge::clear_control_outcome() {
  control_outcome_.ClearToEmpty();
}
inline const std::string& ControlAcknowledge::control_outcome() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlAcknowledge.control_outcome)
  return _internal_control_outcome();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlAcknowledge::set_control_outcome(ArgT0&& arg0, ArgT... args) {
 
 control_outcome_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlAcknowledge.control_outcome)
}
inline std::string* ControlAcknowledge::mutable_control_outcome() {
  std::string* _s = _internal_mutable_control_outcome();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlAcknowledge.control_outcome)
  return _s;
}
inline const std::string& ControlAcknowledge::_internal_control_outcome() const {
  return control_outcome_.Get();
}
inline void ControlAcknowledge::_internal_set_control_outcome(const std::string& value) {
  
  control_outcome_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlAcknowledge::_internal_mutable_control_outcome() {
  
  return control_outcome_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlAcknowledge::release_control_outcome() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlAcknowledge.control_outcome)
  return control_outcome_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlAcknowledge::set_allocated_control_outcome(std::string* control_outcome) {
  if (control_outcome != nullptr) {
    
  } else {
    
  }
  control_outcome_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), control_outcome,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (control_outcome_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    control_outcome_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlAcknowledge.control_outcome)
}

// -------------------------------------------------------------------

// ControlFailure

// .onos.e2t.e2.Cause cause = 1;
inline void ControlFailure::clear_cause() {
  cause_ = 0;
}
inline ::onos::e2t::e2::Cause ControlFailure::_internal_cause() const {
  return static_cast< ::onos::e2t::e2::Cause >(cause_);
}
inline ::onos::e2t::e2::Cause ControlFailure::cause() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlFailure.cause)
  return _internal_cause();
}
inline void ControlFailure::_internal_set_cause(::onos::e2t::e2::Cause value) {
  
  cause_ = value;
}
inline void ControlFailure::set_cause(::onos::e2t::e2::Cause value) {
  _internal_set_cause(value);
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlFailure.cause)
}

// bytes control_outcome = 2;
inline void ControlFailure::clear_control_outcome() {
  control_outcome_.ClearToEmpty();
}
inline const std::string& ControlFailure::control_outcome() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlFailure.control_outcome)
  return _internal_control_outcome();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlFailure::set_control_outcome(ArgT0&& arg0, ArgT... args) {
 
 control_outcome_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlFailure.control_outcome)
}
inline std::string* ControlFailure::mutable_control_outcome() {
  std::string* _s = _internal_mutable_control_outcome();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlFailure.control_outcome)
  return _s;
}
inline const std::string& ControlFailure::_internal_control_outcome() const {
  return control_outcome_.Get();
}
inline void ControlFailure::_internal_set_control_outcome(const std::string& value) {
  
  control_outcome_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlFailure::_internal_mutable_control_outcome() {
  
  return control_outcome_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlFailure::release_control_outcome() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlFailure.control_outcome)
  return control_outcome_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlFailure::set_allocated_control_outcome(std::string* control_outcome) {
  if (control_outcome != nullptr) {
    
  } else {
    
  }
  control_outcome_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), control_outcome,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (control_outcome_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    control_outcome_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlFailure.control_outcome)
}

// string message = 3;
inline void ControlFailure::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& ControlFailure::message() const {
  // @@protoc_insertion_point(field_get:onos.e2t.e2.ControlFailure.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlFailure::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:onos.e2t.e2.ControlFailure.message)
}
inline std::string* ControlFailure::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:onos.e2t.e2.ControlFailure.message)
  return _s;
}
inline const std::string& ControlFailure::_internal_message() const {
  return message_.Get();
}
inline void ControlFailure::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlFailure::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlFailure::release_message() {
  // @@protoc_insertion_point(field_release:onos.e2t.e2.ControlFailure.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlFailure::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:onos.e2t.e2.ControlFailure.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace e2
}  // namespace e2t
}  // namespace onos

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::onos::e2t::e2::EncodingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::EncodingType>() {
  return ::onos::e2t::e2::EncodingType_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::ResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::ResponseStatus>() {
  return ::onos::e2t::e2::ResponseStatus_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::Cause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::Cause>() {
  return ::onos::e2t::e2::Cause_descriptor();
}
template <> struct is_proto_enum< ::onos::e2t::e2::ControlAckRequest> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::onos::e2t::e2::ControlAckRequest>() {
  return ::onos::e2t::e2::ControlAckRequest_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onos_2fe2t_2fe2_2fe2_2eproto
