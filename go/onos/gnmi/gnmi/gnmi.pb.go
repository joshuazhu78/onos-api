// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/gnmi/gnmi/gnmi.proto

// Package gNMI defines a service specification for the gRPC Network Management
// Interface. This interface is defined to be a standard interface via which
// a network management system ("client") can subscribe to state values,
// retrieve snapshots of state information, and manipulate the state of a data
// tree supported by a device ("target").
//
// This document references the gNMI Specification which can be found at
// http://github.com/openconfig/reference/blob/master/rpc/gnmi

package gnmi

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	gnmi_ext "gitlab.devtools.intel.com/ric-sdk/onos-api/go/onos/gnmi/gnmi_ext"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protobuf "google/protobuf"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Encoding defines the value encoding formats that are supported by the gNMI
// protocol. These encodings are used by both the client (when sending Set
// messages to modify the state of the target) and the target when serializing
// data to be returned to the client (in both Subscribe and Get RPCs).
// Reference: gNMI Specification Section 2.3
type Encoding int32

const (
	Encoding_JSON      Encoding = 0
	Encoding_BYTES     Encoding = 1
	Encoding_PROTO     Encoding = 2
	Encoding_ASCII     Encoding = 3
	Encoding_JSON_IETF Encoding = 4
)

var Encoding_name = map[int32]string{
	0: "JSON",
	1: "BYTES",
	2: "PROTO",
	3: "ASCII",
	4: "JSON_IETF",
}

var Encoding_value = map[string]int32{
	"JSON":      0,
	"BYTES":     1,
	"PROTO":     2,
	"ASCII":     3,
	"JSON_IETF": 4,
}

func (x Encoding) String() string {
	return proto.EnumName(Encoding_name, int32(x))
}

func (Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{0}
}

// SubscriptionMode is the mode of the subscription, specifying how the
// target must return values in a subscription.
// Reference: gNMI Specification Section 3.5.1.3
type SubscriptionMode int32

const (
	SubscriptionMode_TARGET_DEFINED SubscriptionMode = 0
	SubscriptionMode_ON_CHANGE      SubscriptionMode = 1
	SubscriptionMode_SAMPLE         SubscriptionMode = 2
)

var SubscriptionMode_name = map[int32]string{
	0: "TARGET_DEFINED",
	1: "ON_CHANGE",
	2: "SAMPLE",
}

var SubscriptionMode_value = map[string]int32{
	"TARGET_DEFINED": 0,
	"ON_CHANGE":      1,
	"SAMPLE":         2,
}

func (x SubscriptionMode) String() string {
	return proto.EnumName(SubscriptionMode_name, int32(x))
}

func (SubscriptionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{1}
}

// Mode of the subscription.
type SubscriptionList_Mode int32

const (
	SubscriptionList_STREAM SubscriptionList_Mode = 0
	SubscriptionList_ONCE   SubscriptionList_Mode = 1
	SubscriptionList_POLL   SubscriptionList_Mode = 2
)

var SubscriptionList_Mode_name = map[int32]string{
	0: "STREAM",
	1: "ONCE",
	2: "POLL",
}

var SubscriptionList_Mode_value = map[string]int32{
	"STREAM": 0,
	"ONCE":   1,
	"POLL":   2,
}

func (x SubscriptionList_Mode) String() string {
	return proto.EnumName(SubscriptionList_Mode_name, int32(x))
}

func (SubscriptionList_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{12, 0}
}

// The operation that was associated with the Path specified.
type UpdateResult_Operation int32

const (
	UpdateResult_INVALID UpdateResult_Operation = 0
	UpdateResult_DELETE  UpdateResult_Operation = 1
	UpdateResult_REPLACE UpdateResult_Operation = 2
	UpdateResult_UPDATE  UpdateResult_Operation = 3
)

var UpdateResult_Operation_name = map[int32]string{
	0: "INVALID",
	1: "DELETE",
	2: "REPLACE",
	3: "UPDATE",
}

var UpdateResult_Operation_value = map[string]int32{
	"INVALID": 0,
	"DELETE":  1,
	"REPLACE": 2,
	"UPDATE":  3,
}

func (x UpdateResult_Operation) String() string {
	return proto.EnumName(UpdateResult_Operation_name, int32(x))
}

func (UpdateResult_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{19, 0}
}

// Type of elements within the data tree.
type GetRequest_DataType int32

const (
	GetRequest_ALL    GetRequest_DataType = 0
	GetRequest_CONFIG GetRequest_DataType = 1
	GetRequest_STATE  GetRequest_DataType = 2
	// Data elements marked in the schema as operational. This refers to data
	// elements whose value relates to the state of processes or interactions
	// running on the device.
	GetRequest_OPERATIONAL GetRequest_DataType = 3
)

var GetRequest_DataType_name = map[int32]string{
	0: "ALL",
	1: "CONFIG",
	2: "STATE",
	3: "OPERATIONAL",
}

var GetRequest_DataType_value = map[string]int32{
	"ALL":         0,
	"CONFIG":      1,
	"STATE":       2,
	"OPERATIONAL": 3,
}

func (x GetRequest_DataType) String() string {
	return proto.EnumName(GetRequest_DataType_name, int32(x))
}

func (GetRequest_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{20, 0}
}

// Notification is a re-usable message that is used to encode data from the
// target to the client. A Notification carries two types of changes to the data
// tree:
//  - Deleted values (delete) - a set of paths that have been removed from the
//    data tree.
//  - Updated values (update) - a set of path-value pairs indicating the path
//    whose value has changed in the data tree.
// Reference: gNMI Specification Section 2.1
type Notification struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Prefix    *Path `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// An alias for the path specified in the prefix field.
	// Reference: gNMI Specification Section 2.4.2
	Alias  string    `protobuf:"bytes,3,opt,name=alias,proto3" json:"alias,omitempty"`
	Update []*Update `protobuf:"bytes,4,rep,name=update,proto3" json:"update,omitempty"`
	Delete []*Path   `protobuf:"bytes,5,rep,name=delete,proto3" json:"delete,omitempty"`
	// This notification contains a set of paths that are always updated together
	// referenced by a globally unique prefix.
	Atomic bool `protobuf:"varint,6,opt,name=atomic,proto3" json:"atomic,omitempty"`
}

func (m *Notification) Reset()         { *m = Notification{} }
func (m *Notification) String() string { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()    {}
func (*Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{0}
}
func (m *Notification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notification.Merge(m, src)
}
func (m *Notification) XXX_Size() int {
	return m.Size()
}
func (m *Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_Notification proto.InternalMessageInfo

func (m *Notification) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Notification) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Notification) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *Notification) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Notification) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *Notification) GetAtomic() bool {
	if m != nil {
		return m.Atomic
	}
	return false
}

// Update is a re-usable message that is used to store a particular Path,
// Value pair.
// Reference: gNMI Specification Section 2.1
type Update struct {
	Path       *Path       `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Value      *Value      `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"` // Deprecated: Do not use.
	Val        *TypedValue `protobuf:"bytes,3,opt,name=val,proto3" json:"val,omitempty"`
	Duplicates uint32      `protobuf:"varint,4,opt,name=duplicates,proto3" json:"duplicates,omitempty"`
}

func (m *Update) Reset()         { *m = Update{} }
func (m *Update) String() string { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()    {}
func (*Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{1}
}
func (m *Update) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Update.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Update.Merge(m, src)
}
func (m *Update) XXX_Size() int {
	return m.Size()
}
func (m *Update) XXX_DiscardUnknown() {
	xxx_messageInfo_Update.DiscardUnknown(m)
}

var xxx_messageInfo_Update proto.InternalMessageInfo

func (m *Update) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// Deprecated: Do not use.
func (m *Update) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Update) GetVal() *TypedValue {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *Update) GetDuplicates() uint32 {
	if m != nil {
		return m.Duplicates
	}
	return 0
}

// TypedValue is used to encode a value being sent between the client and
// target (originated by either entity).
type TypedValue struct {
	// One of the fields within the val oneof is populated with the value
	// of the update. The type of the value being included in the Update
	// determines which field should be populated. In the case that the
	// encoding is a particular form of the base protobuf type, a specific
	// field is used to store the value (e.g., json_val).
	//
	// Types that are valid to be assigned to Value:
	//	*TypedValue_StringVal
	//	*TypedValue_IntVal
	//	*TypedValue_UintVal
	//	*TypedValue_BoolVal
	//	*TypedValue_BytesVal
	//	*TypedValue_FloatVal
	//	*TypedValue_DecimalVal
	//	*TypedValue_LeaflistVal
	//	*TypedValue_AnyVal
	//	*TypedValue_JsonVal
	//	*TypedValue_JsonIetfVal
	//	*TypedValue_AsciiVal
	//	*TypedValue_ProtoBytes
	Value isTypedValue_Value `protobuf_oneof:"value"`
}

func (m *TypedValue) Reset()         { *m = TypedValue{} }
func (m *TypedValue) String() string { return proto.CompactTextString(m) }
func (*TypedValue) ProtoMessage()    {}
func (*TypedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{2}
}
func (m *TypedValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypedValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypedValue.Merge(m, src)
}
func (m *TypedValue) XXX_Size() int {
	return m.Size()
}
func (m *TypedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TypedValue.DiscardUnknown(m)
}

var xxx_messageInfo_TypedValue proto.InternalMessageInfo

type isTypedValue_Value interface {
	isTypedValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TypedValue_StringVal struct {
	StringVal string `protobuf:"bytes,1,opt,name=string_val,json=stringVal,proto3,oneof" json:"string_val,omitempty"`
}
type TypedValue_IntVal struct {
	IntVal int64 `protobuf:"varint,2,opt,name=int_val,json=intVal,proto3,oneof" json:"int_val,omitempty"`
}
type TypedValue_UintVal struct {
	UintVal uint64 `protobuf:"varint,3,opt,name=uint_val,json=uintVal,proto3,oneof" json:"uint_val,omitempty"`
}
type TypedValue_BoolVal struct {
	BoolVal bool `protobuf:"varint,4,opt,name=bool_val,json=boolVal,proto3,oneof" json:"bool_val,omitempty"`
}
type TypedValue_BytesVal struct {
	BytesVal []byte `protobuf:"bytes,5,opt,name=bytes_val,json=bytesVal,proto3,oneof" json:"bytes_val,omitempty"`
}
type TypedValue_FloatVal struct {
	FloatVal float32 `protobuf:"fixed32,6,opt,name=float_val,json=floatVal,proto3,oneof" json:"float_val,omitempty"`
}
type TypedValue_DecimalVal struct {
	DecimalVal *Decimal64 `protobuf:"bytes,7,opt,name=decimal_val,json=decimalVal,proto3,oneof" json:"decimal_val,omitempty"`
}
type TypedValue_LeaflistVal struct {
	LeaflistVal *ScalarArray `protobuf:"bytes,8,opt,name=leaflist_val,json=leaflistVal,proto3,oneof" json:"leaflist_val,omitempty"`
}
type TypedValue_AnyVal struct {
	AnyVal *types.Any `protobuf:"bytes,9,opt,name=any_val,json=anyVal,proto3,oneof" json:"any_val,omitempty"`
}
type TypedValue_JsonVal struct {
	JsonVal []byte `protobuf:"bytes,10,opt,name=json_val,json=jsonVal,proto3,oneof" json:"json_val,omitempty"`
}
type TypedValue_JsonIetfVal struct {
	JsonIetfVal []byte `protobuf:"bytes,11,opt,name=json_ietf_val,json=jsonIetfVal,proto3,oneof" json:"json_ietf_val,omitempty"`
}
type TypedValue_AsciiVal struct {
	AsciiVal string `protobuf:"bytes,12,opt,name=ascii_val,json=asciiVal,proto3,oneof" json:"ascii_val,omitempty"`
}
type TypedValue_ProtoBytes struct {
	ProtoBytes []byte `protobuf:"bytes,13,opt,name=proto_bytes,json=protoBytes,proto3,oneof" json:"proto_bytes,omitempty"`
}

func (*TypedValue_StringVal) isTypedValue_Value()   {}
func (*TypedValue_IntVal) isTypedValue_Value()      {}
func (*TypedValue_UintVal) isTypedValue_Value()     {}
func (*TypedValue_BoolVal) isTypedValue_Value()     {}
func (*TypedValue_BytesVal) isTypedValue_Value()    {}
func (*TypedValue_FloatVal) isTypedValue_Value()    {}
func (*TypedValue_DecimalVal) isTypedValue_Value()  {}
func (*TypedValue_LeaflistVal) isTypedValue_Value() {}
func (*TypedValue_AnyVal) isTypedValue_Value()      {}
func (*TypedValue_JsonVal) isTypedValue_Value()     {}
func (*TypedValue_JsonIetfVal) isTypedValue_Value() {}
func (*TypedValue_AsciiVal) isTypedValue_Value()    {}
func (*TypedValue_ProtoBytes) isTypedValue_Value()  {}

func (m *TypedValue) GetValue() isTypedValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TypedValue) GetStringVal() string {
	if x, ok := m.GetValue().(*TypedValue_StringVal); ok {
		return x.StringVal
	}
	return ""
}

func (m *TypedValue) GetIntVal() int64 {
	if x, ok := m.GetValue().(*TypedValue_IntVal); ok {
		return x.IntVal
	}
	return 0
}

func (m *TypedValue) GetUintVal() uint64 {
	if x, ok := m.GetValue().(*TypedValue_UintVal); ok {
		return x.UintVal
	}
	return 0
}

func (m *TypedValue) GetBoolVal() bool {
	if x, ok := m.GetValue().(*TypedValue_BoolVal); ok {
		return x.BoolVal
	}
	return false
}

func (m *TypedValue) GetBytesVal() []byte {
	if x, ok := m.GetValue().(*TypedValue_BytesVal); ok {
		return x.BytesVal
	}
	return nil
}

func (m *TypedValue) GetFloatVal() float32 {
	if x, ok := m.GetValue().(*TypedValue_FloatVal); ok {
		return x.FloatVal
	}
	return 0
}

func (m *TypedValue) GetDecimalVal() *Decimal64 {
	if x, ok := m.GetValue().(*TypedValue_DecimalVal); ok {
		return x.DecimalVal
	}
	return nil
}

func (m *TypedValue) GetLeaflistVal() *ScalarArray {
	if x, ok := m.GetValue().(*TypedValue_LeaflistVal); ok {
		return x.LeaflistVal
	}
	return nil
}

func (m *TypedValue) GetAnyVal() *types.Any {
	if x, ok := m.GetValue().(*TypedValue_AnyVal); ok {
		return x.AnyVal
	}
	return nil
}

func (m *TypedValue) GetJsonVal() []byte {
	if x, ok := m.GetValue().(*TypedValue_JsonVal); ok {
		return x.JsonVal
	}
	return nil
}

func (m *TypedValue) GetJsonIetfVal() []byte {
	if x, ok := m.GetValue().(*TypedValue_JsonIetfVal); ok {
		return x.JsonIetfVal
	}
	return nil
}

func (m *TypedValue) GetAsciiVal() string {
	if x, ok := m.GetValue().(*TypedValue_AsciiVal); ok {
		return x.AsciiVal
	}
	return ""
}

func (m *TypedValue) GetProtoBytes() []byte {
	if x, ok := m.GetValue().(*TypedValue_ProtoBytes); ok {
		return x.ProtoBytes
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TypedValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TypedValue_StringVal)(nil),
		(*TypedValue_IntVal)(nil),
		(*TypedValue_UintVal)(nil),
		(*TypedValue_BoolVal)(nil),
		(*TypedValue_BytesVal)(nil),
		(*TypedValue_FloatVal)(nil),
		(*TypedValue_DecimalVal)(nil),
		(*TypedValue_LeaflistVal)(nil),
		(*TypedValue_AnyVal)(nil),
		(*TypedValue_JsonVal)(nil),
		(*TypedValue_JsonIetfVal)(nil),
		(*TypedValue_AsciiVal)(nil),
		(*TypedValue_ProtoBytes)(nil),
	}
}

// Path encodes a data tree path as a series of repeated strings, with
// each element of the path representing a data tree node name and the
// associated attributes.
// Reference: gNMI Specification Section 2.2.2.
type Path struct {
	// Elements of the path are no longer encoded as a string, but rather within
	// the elem field as a PathElem message.
	Element []string    `protobuf:"bytes,1,rep,name=element,proto3" json:"element,omitempty"` // Deprecated: Do not use.
	Origin  string      `protobuf:"bytes,2,opt,name=origin,proto3" json:"origin,omitempty"`
	Elem    []*PathElem `protobuf:"bytes,3,rep,name=elem,proto3" json:"elem,omitempty"`
	Target  string      `protobuf:"bytes,4,opt,name=target,proto3" json:"target,omitempty"`
}

func (m *Path) Reset()         { *m = Path{} }
func (m *Path) String() string { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()    {}
func (*Path) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{3}
}
func (m *Path) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Path) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Path.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Path) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Path.Merge(m, src)
}
func (m *Path) XXX_Size() int {
	return m.Size()
}
func (m *Path) XXX_DiscardUnknown() {
	xxx_messageInfo_Path.DiscardUnknown(m)
}

var xxx_messageInfo_Path proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *Path) GetElement() []string {
	if m != nil {
		return m.Element
	}
	return nil
}

func (m *Path) GetOrigin() string {
	if m != nil {
		return m.Origin
	}
	return ""
}

func (m *Path) GetElem() []*PathElem {
	if m != nil {
		return m.Elem
	}
	return nil
}

func (m *Path) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

// PathElem encodes an element of a gNMI path, along with any attributes (keys)
// that may be associated with it.
// Reference: gNMI Specification Section 2.2.2.
type PathElem struct {
	Name string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key  map[string]string `protobuf:"bytes,2,rep,name=key,proto3" json:"key,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *PathElem) Reset()         { *m = PathElem{} }
func (m *PathElem) String() string { return proto.CompactTextString(m) }
func (*PathElem) ProtoMessage()    {}
func (*PathElem) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{4}
}
func (m *PathElem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathElem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathElem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathElem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathElem.Merge(m, src)
}
func (m *PathElem) XXX_Size() int {
	return m.Size()
}
func (m *PathElem) XXX_DiscardUnknown() {
	xxx_messageInfo_PathElem.DiscardUnknown(m)
}

var xxx_messageInfo_PathElem proto.InternalMessageInfo

func (m *PathElem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PathElem) GetKey() map[string]string {
	if m != nil {
		return m.Key
	}
	return nil
}

// Value encodes a data tree node's value - along with the way in which
// the value is encoded. This message is deprecated by gNMI 0.3.0.
// Reference: gNMI Specification Section 2.2.3.
//
// Deprecated: Do not use.
type Value struct {
	Value []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  Encoding `protobuf:"varint,2,opt,name=type,proto3,enum=gnmi.Encoding" json:"type,omitempty"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{5}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

func (m *Value) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Value) GetType() Encoding {
	if m != nil {
		return m.Type
	}
	return Encoding_JSON
}

// Error message previously utilised to return errors to the client. Deprecated
// in favour of using the google.golang.org/genproto/googleapis/rpc/status
// message in the RPC response.
// Reference: gNMI Specification Section 2.5
//
// Deprecated: Do not use.
type Error struct {
	Code    uint32     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string     `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Data    *types.Any `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{6}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetData() *types.Any {
	if m != nil {
		return m.Data
	}
	return nil
}

// Decimal64 is used to encode a fixed precision decimal number. The value
// is expressed as a set of digits with the precision specifying the
// number of digits following the decimal point in the digit set.
type Decimal64 struct {
	Digits    int64  `protobuf:"varint,1,opt,name=digits,proto3" json:"digits,omitempty"`
	Precision uint32 `protobuf:"varint,2,opt,name=precision,proto3" json:"precision,omitempty"`
}

func (m *Decimal64) Reset()         { *m = Decimal64{} }
func (m *Decimal64) String() string { return proto.CompactTextString(m) }
func (*Decimal64) ProtoMessage()    {}
func (*Decimal64) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{7}
}
func (m *Decimal64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Decimal64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Decimal64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Decimal64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Decimal64.Merge(m, src)
}
func (m *Decimal64) XXX_Size() int {
	return m.Size()
}
func (m *Decimal64) XXX_DiscardUnknown() {
	xxx_messageInfo_Decimal64.DiscardUnknown(m)
}

var xxx_messageInfo_Decimal64 proto.InternalMessageInfo

func (m *Decimal64) GetDigits() int64 {
	if m != nil {
		return m.Digits
	}
	return 0
}

func (m *Decimal64) GetPrecision() uint32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

// ScalarArray is used to encode a mixed-type array of values.
type ScalarArray struct {
	// The set of elements within the array. Each TypedValue message should
	// specify only elements that have a field identifier of 1-7 (i.e., the
	// values are scalar values).
	Element []*TypedValue `protobuf:"bytes,1,rep,name=element,proto3" json:"element,omitempty"`
}

func (m *ScalarArray) Reset()         { *m = ScalarArray{} }
func (m *ScalarArray) String() string { return proto.CompactTextString(m) }
func (*ScalarArray) ProtoMessage()    {}
func (*ScalarArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{8}
}
func (m *ScalarArray) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalarArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScalarArray.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScalarArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalarArray.Merge(m, src)
}
func (m *ScalarArray) XXX_Size() int {
	return m.Size()
}
func (m *ScalarArray) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalarArray.DiscardUnknown(m)
}

var xxx_messageInfo_ScalarArray proto.InternalMessageInfo

func (m *ScalarArray) GetElement() []*TypedValue {
	if m != nil {
		return m.Element
	}
	return nil
}

// SubscribeRequest is the message sent by the client to the target when
// initiating a subscription to a set of paths within the data tree. The
// request field must be populated and the initial message must specify a
// SubscriptionList to initiate a subscription. The message is subsequently
// used to define aliases or trigger polled data to be sent by the target.
// Reference: gNMI Specification Section 3.5.1.1
type SubscribeRequest struct {
	// Types that are valid to be assigned to Request:
	//	*SubscribeRequest_Subscribe
	//	*SubscribeRequest_Poll
	//	*SubscribeRequest_Aliases
	Request isSubscribeRequest_Request `protobuf_oneof:"request"`
	// Extension messages associated with the SubscribeRequest. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,5,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{9}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

type isSubscribeRequest_Request interface {
	isSubscribeRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SubscribeRequest_Subscribe struct {
	Subscribe *SubscriptionList `protobuf:"bytes,1,opt,name=subscribe,proto3,oneof" json:"subscribe,omitempty"`
}
type SubscribeRequest_Poll struct {
	Poll *Poll `protobuf:"bytes,3,opt,name=poll,proto3,oneof" json:"poll,omitempty"`
}
type SubscribeRequest_Aliases struct {
	Aliases *AliasList `protobuf:"bytes,4,opt,name=aliases,proto3,oneof" json:"aliases,omitempty"`
}

func (*SubscribeRequest_Subscribe) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Poll) isSubscribeRequest_Request()      {}
func (*SubscribeRequest_Aliases) isSubscribeRequest_Request()   {}

func (m *SubscribeRequest) GetRequest() isSubscribeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SubscribeRequest) GetSubscribe() *SubscriptionList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *SubscribeRequest) GetPoll() *Poll {
	if x, ok := m.GetRequest().(*SubscribeRequest_Poll); ok {
		return x.Poll
	}
	return nil
}

func (m *SubscribeRequest) GetAliases() *AliasList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Aliases); ok {
		return x.Aliases
	}
	return nil
}

func (m *SubscribeRequest) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SubscribeRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SubscribeRequest_Subscribe)(nil),
		(*SubscribeRequest_Poll)(nil),
		(*SubscribeRequest_Aliases)(nil),
	}
}

// Poll is sent within a SubscribeRequest to trigger the device to
// send telemetry updates for the paths that are associated with the
// subscription.
// Reference: gNMI Specification Section Section 3.5.1.4
type Poll struct {
}

func (m *Poll) Reset()         { *m = Poll{} }
func (m *Poll) String() string { return proto.CompactTextString(m) }
func (*Poll) ProtoMessage()    {}
func (*Poll) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{10}
}
func (m *Poll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Poll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Poll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Poll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Poll.Merge(m, src)
}
func (m *Poll) XXX_Size() int {
	return m.Size()
}
func (m *Poll) XXX_DiscardUnknown() {
	xxx_messageInfo_Poll.DiscardUnknown(m)
}

var xxx_messageInfo_Poll proto.InternalMessageInfo

// SubscribeResponse is the message used by the target within a Subscribe RPC.
// The target includes a Notification message which is used to transmit values
// of the path(s) that are associated with the subscription. The same message
// is to indicate that the target has sent all data values once (is
// synchronized).
// Reference: gNMI Specification Section 3.5.1.4
type SubscribeResponse struct {
	// Types that are valid to be assigned to Response:
	//	*SubscribeResponse_Update
	//	*SubscribeResponse_SyncResponse
	//	*SubscribeResponse_Error
	Response isSubscribeResponse_Response `protobuf_oneof:"response"`
	// Extension messages associated with the SubscribeResponse. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,5,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *SubscribeResponse) Reset()         { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()    {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{11}
}
func (m *SubscribeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeResponse.Merge(m, src)
}
func (m *SubscribeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeResponse proto.InternalMessageInfo

type isSubscribeResponse_Response interface {
	isSubscribeResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SubscribeResponse_Update struct {
	Update *Notification `protobuf:"bytes,1,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type SubscribeResponse_SyncResponse struct {
	SyncResponse bool `protobuf:"varint,3,opt,name=sync_response,json=syncResponse,proto3,oneof" json:"sync_response,omitempty"`
}
type SubscribeResponse_Error struct {
	Error *Error `protobuf:"bytes,4,opt,name=error,proto3,oneof" json:"error,omitempty"`
}

func (*SubscribeResponse_Update) isSubscribeResponse_Response()       {}
func (*SubscribeResponse_SyncResponse) isSubscribeResponse_Response() {}
func (*SubscribeResponse_Error) isSubscribeResponse_Response()        {}

func (m *SubscribeResponse) GetResponse() isSubscribeResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SubscribeResponse) GetUpdate() *Notification {
	if x, ok := m.GetResponse().(*SubscribeResponse_Update); ok {
		return x.Update
	}
	return nil
}

func (m *SubscribeResponse) GetSyncResponse() bool {
	if x, ok := m.GetResponse().(*SubscribeResponse_SyncResponse); ok {
		return x.SyncResponse
	}
	return false
}

// Deprecated: Do not use.
func (m *SubscribeResponse) GetError() *Error {
	if x, ok := m.GetResponse().(*SubscribeResponse_Error); ok {
		return x.Error
	}
	return nil
}

func (m *SubscribeResponse) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SubscribeResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SubscribeResponse_Update)(nil),
		(*SubscribeResponse_SyncResponse)(nil),
		(*SubscribeResponse_Error)(nil),
	}
}

// SubscriptionList is used within a Subscribe message to specify the list of
// paths that the client wishes to subscribe to. The message consists of a
// list of (possibly prefixed) paths, and options that relate to the
// subscription.
// Reference: gNMI Specification Section 3.5.1.2
type SubscriptionList struct {
	Prefix       *Path           `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Subscription []*Subscription `protobuf:"bytes,2,rep,name=subscription,proto3" json:"subscription,omitempty"`
	// Whether target defined aliases are allowed within the subscription.
	UseAliases bool                  `protobuf:"varint,3,opt,name=use_aliases,json=useAliases,proto3" json:"use_aliases,omitempty"`
	Qos        *QOSMarking           `protobuf:"bytes,4,opt,name=qos,proto3" json:"qos,omitempty"`
	Mode       SubscriptionList_Mode `protobuf:"varint,5,opt,name=mode,proto3,enum=gnmi.SubscriptionList_Mode" json:"mode,omitempty"`
	// Whether elements of the schema that are marked as eligible for aggregation
	// should be aggregated or not.
	AllowAggregation bool `protobuf:"varint,6,opt,name=allow_aggregation,json=allowAggregation,proto3" json:"allow_aggregation,omitempty"`
	// The set of schemas that define the elements of the data tree that should
	// be sent by the target.
	UseModels []*ModelData `protobuf:"bytes,7,rep,name=use_models,json=useModels,proto3" json:"use_models,omitempty"`
	// The encoding that the target should use within the Notifications generated
	// corresponding to the SubscriptionList.
	Encoding Encoding `protobuf:"varint,8,opt,name=encoding,proto3,enum=gnmi.Encoding" json:"encoding,omitempty"`
	// An optional field to specify that only updates to current state should be
	// sent to a client. If set, the initial state is not sent to the client but
	// rather only the sync message followed by any subsequent updates to the
	// current state. For ONCE and POLL modes, this causes the server to send only
	// the sync message (Sec. 3.5.2.3).
	UpdatesOnly bool `protobuf:"varint,9,opt,name=updates_only,json=updatesOnly,proto3" json:"updates_only,omitempty"`
}

func (m *SubscriptionList) Reset()         { *m = SubscriptionList{} }
func (m *SubscriptionList) String() string { return proto.CompactTextString(m) }
func (*SubscriptionList) ProtoMessage()    {}
func (*SubscriptionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{12}
}
func (m *SubscriptionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscriptionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscriptionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscriptionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscriptionList.Merge(m, src)
}
func (m *SubscriptionList) XXX_Size() int {
	return m.Size()
}
func (m *SubscriptionList) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscriptionList.DiscardUnknown(m)
}

var xxx_messageInfo_SubscriptionList proto.InternalMessageInfo

func (m *SubscriptionList) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SubscriptionList) GetSubscription() []*Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *SubscriptionList) GetUseAliases() bool {
	if m != nil {
		return m.UseAliases
	}
	return false
}

func (m *SubscriptionList) GetQos() *QOSMarking {
	if m != nil {
		return m.Qos
	}
	return nil
}

func (m *SubscriptionList) GetMode() SubscriptionList_Mode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionList_STREAM
}

func (m *SubscriptionList) GetAllowAggregation() bool {
	if m != nil {
		return m.AllowAggregation
	}
	return false
}

func (m *SubscriptionList) GetUseModels() []*ModelData {
	if m != nil {
		return m.UseModels
	}
	return nil
}

func (m *SubscriptionList) GetEncoding() Encoding {
	if m != nil {
		return m.Encoding
	}
	return Encoding_JSON
}

func (m *SubscriptionList) GetUpdatesOnly() bool {
	if m != nil {
		return m.UpdatesOnly
	}
	return false
}

// Subscription is a single request within a SubscriptionList. The path
// specified is interpreted (along with the prefix) as the elements of the data
// tree that the client is subscribing to. The mode determines how the target
// should trigger updates to be sent.
// Reference: gNMI Specification Section 3.5.1.3
type Subscription struct {
	Path           *Path            `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Mode           SubscriptionMode `protobuf:"varint,2,opt,name=mode,proto3,enum=gnmi.SubscriptionMode" json:"mode,omitempty"`
	SampleInterval uint64           `protobuf:"varint,3,opt,name=sample_interval,json=sampleInterval,proto3" json:"sample_interval,omitempty"`
	// Indicates whether values that have not changed should be sent in a SAMPLE
	// subscription.
	SuppressRedundant bool `protobuf:"varint,4,opt,name=suppress_redundant,json=suppressRedundant,proto3" json:"suppress_redundant,omitempty"`
	// Specifies the maximum allowable silent period in nanoseconds when
	// suppress_redundant is in use. The target should send a value at least once
	// in the period specified.
	HeartbeatInterval uint64 `protobuf:"varint,5,opt,name=heartbeat_interval,json=heartbeatInterval,proto3" json:"heartbeat_interval,omitempty"`
}

func (m *Subscription) Reset()         { *m = Subscription{} }
func (m *Subscription) String() string { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()    {}
func (*Subscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{13}
}
func (m *Subscription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscription.Merge(m, src)
}
func (m *Subscription) XXX_Size() int {
	return m.Size()
}
func (m *Subscription) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscription.DiscardUnknown(m)
}

var xxx_messageInfo_Subscription proto.InternalMessageInfo

func (m *Subscription) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Subscription) GetMode() SubscriptionMode {
	if m != nil {
		return m.Mode
	}
	return SubscriptionMode_TARGET_DEFINED
}

func (m *Subscription) GetSampleInterval() uint64 {
	if m != nil {
		return m.SampleInterval
	}
	return 0
}

func (m *Subscription) GetSuppressRedundant() bool {
	if m != nil {
		return m.SuppressRedundant
	}
	return false
}

func (m *Subscription) GetHeartbeatInterval() uint64 {
	if m != nil {
		return m.HeartbeatInterval
	}
	return 0
}

// QOSMarking specifies the DSCP value to be set on transmitted telemetry
// updates from the target.
// Reference: gNMI Specification Section 3.5.1.2
type QOSMarking struct {
	Marking uint32 `protobuf:"varint,1,opt,name=marking,proto3" json:"marking,omitempty"`
}

func (m *QOSMarking) Reset()         { *m = QOSMarking{} }
func (m *QOSMarking) String() string { return proto.CompactTextString(m) }
func (*QOSMarking) ProtoMessage()    {}
func (*QOSMarking) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{14}
}
func (m *QOSMarking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QOSMarking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QOSMarking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QOSMarking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QOSMarking.Merge(m, src)
}
func (m *QOSMarking) XXX_Size() int {
	return m.Size()
}
func (m *QOSMarking) XXX_DiscardUnknown() {
	xxx_messageInfo_QOSMarking.DiscardUnknown(m)
}

var xxx_messageInfo_QOSMarking proto.InternalMessageInfo

func (m *QOSMarking) GetMarking() uint32 {
	if m != nil {
		return m.Marking
	}
	return 0
}

// Alias specifies a data tree path, and an associated string which defines an
// alias which is to be used for this path in the context of the RPC. The alias
// is specified as a string which is prefixed with "#" to disambiguate it from
// data tree element paths.
// Reference: gNMI Specification Section 2.4.2
type Alias struct {
	Path  *Path  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Alias string `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
}

func (m *Alias) Reset()         { *m = Alias{} }
func (m *Alias) String() string { return proto.CompactTextString(m) }
func (*Alias) ProtoMessage()    {}
func (*Alias) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{15}
}
func (m *Alias) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Alias) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Alias.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Alias) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Alias.Merge(m, src)
}
func (m *Alias) XXX_Size() int {
	return m.Size()
}
func (m *Alias) XXX_DiscardUnknown() {
	xxx_messageInfo_Alias.DiscardUnknown(m)
}

var xxx_messageInfo_Alias proto.InternalMessageInfo

func (m *Alias) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Alias) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

// AliasList specifies a list of aliases. It is used in a SubscribeRequest for
// a client to create a set of aliases that the target is to utilize.
// Reference: gNMI Specification Section 3.5.1.6
type AliasList struct {
	Alias []*Alias `protobuf:"bytes,1,rep,name=alias,proto3" json:"alias,omitempty"`
}

func (m *AliasList) Reset()         { *m = AliasList{} }
func (m *AliasList) String() string { return proto.CompactTextString(m) }
func (*AliasList) ProtoMessage()    {}
func (*AliasList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{16}
}
func (m *AliasList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AliasList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AliasList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AliasList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AliasList.Merge(m, src)
}
func (m *AliasList) XXX_Size() int {
	return m.Size()
}
func (m *AliasList) XXX_DiscardUnknown() {
	xxx_messageInfo_AliasList.DiscardUnknown(m)
}

var xxx_messageInfo_AliasList proto.InternalMessageInfo

func (m *AliasList) GetAlias() []*Alias {
	if m != nil {
		return m.Alias
	}
	return nil
}

// SetRequest is sent from a client to the target to update values in the data
// tree. Paths are either deleted by the client, or modified by means of being
// updated, or replaced. Where a replace is used, unspecified values are
// considered to be replaced, whereas when update is used the changes are
// considered to be incremental. The set of changes that are specified within
// a single SetRequest are considered to be a transaction.
// Reference: gNMI Specification Section 3.4.1
type SetRequest struct {
	Prefix  *Path     `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Delete  []*Path   `protobuf:"bytes,2,rep,name=delete,proto3" json:"delete,omitempty"`
	Replace []*Update `protobuf:"bytes,3,rep,name=replace,proto3" json:"replace,omitempty"`
	Update  []*Update `protobuf:"bytes,4,rep,name=update,proto3" json:"update,omitempty"`
	// Extension messages associated with the SetRequest. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,5,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *SetRequest) Reset()         { *m = SetRequest{} }
func (m *SetRequest) String() string { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()    {}
func (*SetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{17}
}
func (m *SetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetRequest.Merge(m, src)
}
func (m *SetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetRequest proto.InternalMessageInfo

func (m *SetRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SetRequest) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *SetRequest) GetReplace() []*Update {
	if m != nil {
		return m.Replace
	}
	return nil
}

func (m *SetRequest) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *SetRequest) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// SetResponse is the response to a SetRequest, sent from the target to the
// client. It reports the result of the modifications to the data tree that were
// specified by the client. Errors for this RPC should be reported using the
// https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto
// message in the RPC return. The gnmi.Error message can be used to add additional
// details where required.
// Reference: gNMI Specification Section 3.4.2
type SetResponse struct {
	Prefix *Path `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// A set of responses specifying the result of the operations specified in
	// the SetRequest.
	Response  []*UpdateResult `protobuf:"bytes,2,rep,name=response,proto3" json:"response,omitempty"`
	Message   *Error          `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"` // Deprecated: Do not use.
	Timestamp int64           `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Extension messages associated with the SetResponse. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,5,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *SetResponse) Reset()         { *m = SetResponse{} }
func (m *SetResponse) String() string { return proto.CompactTextString(m) }
func (*SetResponse) ProtoMessage()    {}
func (*SetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{18}
}
func (m *SetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetResponse.Merge(m, src)
}
func (m *SetResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetResponse proto.InternalMessageInfo

func (m *SetResponse) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SetResponse) GetResponse() []*UpdateResult {
	if m != nil {
		return m.Response
	}
	return nil
}

// Deprecated: Do not use.
func (m *SetResponse) GetMessage() *Error {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *SetResponse) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SetResponse) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// UpdateResult is used within the SetResponse message to communicate the
// result of an operation specified within a SetRequest message.
// Reference: gNMI Specification Section 3.4.2
type UpdateResult struct {
	// Deprecated timestamp for the UpdateResult, this field has been
	// replaced by the timestamp within the SetResponse message, since
	// all mutations effected by a set should be applied as a single
	// transaction.
	Timestamp int64                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Deprecated: Do not use.
	Path      *Path                  `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Message   *Error                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"` // Deprecated: Do not use.
	Op        UpdateResult_Operation `protobuf:"varint,4,opt,name=op,proto3,enum=gnmi.UpdateResult_Operation" json:"op,omitempty"`
}

func (m *UpdateResult) Reset()         { *m = UpdateResult{} }
func (m *UpdateResult) String() string { return proto.CompactTextString(m) }
func (*UpdateResult) ProtoMessage()    {}
func (*UpdateResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{19}
}
func (m *UpdateResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResult.Merge(m, src)
}
func (m *UpdateResult) XXX_Size() int {
	return m.Size()
}
func (m *UpdateResult) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResult.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResult proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *UpdateResult) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateResult) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// Deprecated: Do not use.
func (m *UpdateResult) GetMessage() *Error {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UpdateResult) GetOp() UpdateResult_Operation {
	if m != nil {
		return m.Op
	}
	return UpdateResult_INVALID
}

// GetRequest is sent when a client initiates a Get RPC. It is used to specify
// the set of data elements for which the target should return a snapshot of
// data. The use_models field specifies the set of schema modules that are to
// be used by the target - where use_models is not specified then the target
// must use all schema models that it has.
// Reference: gNMI Specification Section 3.3.1
type GetRequest struct {
	Prefix    *Path               `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Path      []*Path             `protobuf:"bytes,2,rep,name=path,proto3" json:"path,omitempty"`
	Type      GetRequest_DataType `protobuf:"varint,3,opt,name=type,proto3,enum=gnmi.GetRequest_DataType" json:"type,omitempty"`
	Encoding  Encoding            `protobuf:"varint,5,opt,name=encoding,proto3,enum=gnmi.Encoding" json:"encoding,omitempty"`
	UseModels []*ModelData        `protobuf:"bytes,6,rep,name=use_models,json=useModels,proto3" json:"use_models,omitempty"`
	// Extension messages associated with the GetRequest. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,7,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{20}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *GetRequest) GetPath() []*Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *GetRequest) GetType() GetRequest_DataType {
	if m != nil {
		return m.Type
	}
	return GetRequest_ALL
}

func (m *GetRequest) GetEncoding() Encoding {
	if m != nil {
		return m.Encoding
	}
	return Encoding_JSON
}

func (m *GetRequest) GetUseModels() []*ModelData {
	if m != nil {
		return m.UseModels
	}
	return nil
}

func (m *GetRequest) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// GetResponse is used by the target to respond to a GetRequest from a client.
// The set of Notifications corresponds to the data values that are requested
// by the client in the GetRequest.
// Reference: gNMI Specification Section 3.3.2
type GetResponse struct {
	Notification []*Notification `protobuf:"bytes,1,rep,name=notification,proto3" json:"notification,omitempty"`
	Error        *Error          `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"` // Deprecated: Do not use.
	// Extension messages associated with the GetResponse. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,3,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *GetResponse) Reset()         { *m = GetResponse{} }
func (m *GetResponse) String() string { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()    {}
func (*GetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{21}
}
func (m *GetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResponse.Merge(m, src)
}
func (m *GetResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetResponse proto.InternalMessageInfo

func (m *GetResponse) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

// Deprecated: Do not use.
func (m *GetResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetResponse) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// CapabilityRequest is sent by the client in the Capabilities RPC to request
// that the target reports its capabilities.
// Reference: gNMI Specification Section 3.2.1
type CapabilityRequest struct {
	// Extension messages associated with the CapabilityRequest. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,1,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *CapabilityRequest) Reset()         { *m = CapabilityRequest{} }
func (m *CapabilityRequest) String() string { return proto.CompactTextString(m) }
func (*CapabilityRequest) ProtoMessage()    {}
func (*CapabilityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{22}
}
func (m *CapabilityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapabilityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapabilityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapabilityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapabilityRequest.Merge(m, src)
}
func (m *CapabilityRequest) XXX_Size() int {
	return m.Size()
}
func (m *CapabilityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CapabilityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CapabilityRequest proto.InternalMessageInfo

func (m *CapabilityRequest) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// CapabilityResponse is used by the target to report its capabilities to the
// client within the Capabilities RPC.
// Reference: gNMI Specification Section 3.2.2
type CapabilityResponse struct {
	SupportedModels    []*ModelData `protobuf:"bytes,1,rep,name=supported_models,json=supportedModels,proto3" json:"supported_models,omitempty"`
	SupportedEncodings []Encoding   `protobuf:"varint,2,rep,packed,name=supported_encodings,json=supportedEncodings,proto3,enum=gnmi.Encoding" json:"supported_encodings,omitempty"`
	GNMIVersion        string       `protobuf:"bytes,3,opt,name=gNMI_version,json=gNMIVersion,proto3" json:"gNMI_version,omitempty"`
	// Extension messages associated with the CapabilityResponse. See the
	// gNMI extension specification for further definition.
	Extension []*gnmi_ext.Extension `protobuf:"bytes,4,rep,name=extension,proto3" json:"extension,omitempty"`
}

func (m *CapabilityResponse) Reset()         { *m = CapabilityResponse{} }
func (m *CapabilityResponse) String() string { return proto.CompactTextString(m) }
func (*CapabilityResponse) ProtoMessage()    {}
func (*CapabilityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{23}
}
func (m *CapabilityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapabilityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CapabilityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CapabilityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapabilityResponse.Merge(m, src)
}
func (m *CapabilityResponse) XXX_Size() int {
	return m.Size()
}
func (m *CapabilityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CapabilityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CapabilityResponse proto.InternalMessageInfo

func (m *CapabilityResponse) GetSupportedModels() []*ModelData {
	if m != nil {
		return m.SupportedModels
	}
	return nil
}

func (m *CapabilityResponse) GetSupportedEncodings() []Encoding {
	if m != nil {
		return m.SupportedEncodings
	}
	return nil
}

func (m *CapabilityResponse) GetGNMIVersion() string {
	if m != nil {
		return m.GNMIVersion
	}
	return ""
}

func (m *CapabilityResponse) GetExtension() []*gnmi_ext.Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

// ModelData is used to describe a set of schema modules. It can be used in a
// CapabilityResponse where a target reports the set of modules that it
// supports, and within the SubscribeRequest and GetRequest messages to specify
// the set of models from which data tree elements should be reported.
// Reference: gNMI Specification Section 3.2.3
type ModelData struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	Version      string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ModelData) Reset()         { *m = ModelData{} }
func (m *ModelData) String() string { return proto.CompactTextString(m) }
func (*ModelData) ProtoMessage()    {}
func (*ModelData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ac9b3bb81c731384, []int{24}
}
func (m *ModelData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelData.Merge(m, src)
}
func (m *ModelData) XXX_Size() int {
	return m.Size()
}
func (m *ModelData) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelData.DiscardUnknown(m)
}

var xxx_messageInfo_ModelData proto.InternalMessageInfo

func (m *ModelData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelData) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *ModelData) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

var E_GnmiService = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.FileOptions)(nil),
	ExtensionType: (*string)(nil),
	Field:         1001,
	Name:          "gnmi.gnmi_service",
	Tag:           "bytes,1001,opt,name=gnmi_service",
	Filename:      "onos/gnmi/gnmi/gnmi.proto",
}

func init() {
	proto.RegisterEnum("gnmi.Encoding", Encoding_name, Encoding_value)
	proto.RegisterEnum("gnmi.SubscriptionMode", SubscriptionMode_name, SubscriptionMode_value)
	proto.RegisterEnum("gnmi.SubscriptionList_Mode", SubscriptionList_Mode_name, SubscriptionList_Mode_value)
	proto.RegisterEnum("gnmi.UpdateResult_Operation", UpdateResult_Operation_name, UpdateResult_Operation_value)
	proto.RegisterEnum("gnmi.GetRequest_DataType", GetRequest_DataType_name, GetRequest_DataType_value)
	proto.RegisterType((*Notification)(nil), "gnmi.Notification")
	proto.RegisterType((*Update)(nil), "gnmi.Update")
	proto.RegisterType((*TypedValue)(nil), "gnmi.TypedValue")
	proto.RegisterType((*Path)(nil), "gnmi.Path")
	proto.RegisterType((*PathElem)(nil), "gnmi.PathElem")
	proto.RegisterMapType((map[string]string)(nil), "gnmi.PathElem.KeyEntry")
	proto.RegisterType((*Value)(nil), "gnmi.Value")
	proto.RegisterType((*Error)(nil), "gnmi.Error")
	proto.RegisterType((*Decimal64)(nil), "gnmi.Decimal64")
	proto.RegisterType((*ScalarArray)(nil), "gnmi.ScalarArray")
	proto.RegisterType((*SubscribeRequest)(nil), "gnmi.SubscribeRequest")
	proto.RegisterType((*Poll)(nil), "gnmi.Poll")
	proto.RegisterType((*SubscribeResponse)(nil), "gnmi.SubscribeResponse")
	proto.RegisterType((*SubscriptionList)(nil), "gnmi.SubscriptionList")
	proto.RegisterType((*Subscription)(nil), "gnmi.Subscription")
	proto.RegisterType((*QOSMarking)(nil), "gnmi.QOSMarking")
	proto.RegisterType((*Alias)(nil), "gnmi.Alias")
	proto.RegisterType((*AliasList)(nil), "gnmi.AliasList")
	proto.RegisterType((*SetRequest)(nil), "gnmi.SetRequest")
	proto.RegisterType((*SetResponse)(nil), "gnmi.SetResponse")
	proto.RegisterType((*UpdateResult)(nil), "gnmi.UpdateResult")
	proto.RegisterType((*GetRequest)(nil), "gnmi.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "gnmi.GetResponse")
	proto.RegisterType((*CapabilityRequest)(nil), "gnmi.CapabilityRequest")
	proto.RegisterType((*CapabilityResponse)(nil), "gnmi.CapabilityResponse")
	proto.RegisterType((*ModelData)(nil), "gnmi.ModelData")
	proto.RegisterExtension(E_GnmiService)
}

func init() { proto.RegisterFile("onos/gnmi/gnmi/gnmi.proto", fileDescriptor_ac9b3bb81c731384) }

var fileDescriptor_ac9b3bb81c731384 = []byte{
	// 1963 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdd, 0x72, 0xdb, 0xd6,
	0x11, 0x26, 0x08, 0xfe, 0x61, 0x49, 0xd9, 0xd0, 0x49, 0x26, 0xa1, 0x15, 0x57, 0xa1, 0x31, 0x89,
	0xc3, 0x28, 0x09, 0xe5, 0xaa, 0x1d, 0xb5, 0x75, 0x27, 0x6d, 0x20, 0x09, 0x92, 0xd8, 0x52, 0xa4,
	0x7a, 0xc8, 0x78, 0xa6, 0x17, 0x1d, 0xce, 0x11, 0x79, 0x44, 0xa3, 0x01, 0x01, 0x04, 0x38, 0x74,
	0xcd, 0xde, 0xf5, 0x0d, 0x3a, 0xd3, 0x07, 0xe8, 0x6b, 0xf4, 0x11, 0x32, 0xed, 0x8d, 0x6f, 0x3a,
	0xed, 0x4d, 0x67, 0x5a, 0xfb, 0xa2, 0xed, 0xf4, 0x25, 0x3a, 0xe7, 0x07, 0x00, 0x61, 0xd2, 0x63,
	0x39, 0x37, 0x1c, 0x60, 0xbf, 0xdd, 0xc5, 0xd9, 0xb3, 0xbb, 0xdf, 0x2e, 0xe1, 0x4e, 0xe0, 0x07,
	0xf1, 0xfe, 0xcc, 0x9f, 0xbb, 0xd9, 0x4f, 0x27, 0x8c, 0x02, 0x16, 0xa0, 0x12, 0x7f, 0xde, 0xb9,
	0x33, 0x0b, 0x82, 0x99, 0x47, 0xf7, 0x85, 0xec, 0x6a, 0x71, 0xbd, 0x4f, 0xfc, 0xa5, 0x54, 0xd8,
	0x69, 0xbd, 0x0c, 0x4d, 0x69, 0x3c, 0x89, 0xdc, 0x90, 0x05, 0x91, 0xd2, 0xb8, 0x97, 0xf7, 0x3e,
	0xa6, 0x4f, 0x59, 0xfa, 0x20, 0x55, 0xac, 0x6f, 0x34, 0x68, 0xf4, 0x03, 0xe6, 0x5e, 0xbb, 0x13,
	0xc2, 0xdc, 0xc0, 0x47, 0x77, 0xc1, 0x60, 0xee, 0x9c, 0xc6, 0x8c, 0xcc, 0xc3, 0xa6, 0xd6, 0xd2,
	0xda, 0x3a, 0xce, 0x04, 0xc8, 0x82, 0x4a, 0x18, 0xd1, 0x6b, 0xf7, 0x69, 0xb3, 0xd8, 0xd2, 0xda,
	0xf5, 0x03, 0xe8, 0x88, 0x13, 0x5f, 0x12, 0xf6, 0x18, 0x2b, 0x04, 0xbd, 0x0d, 0x65, 0xe2, 0xb9,
	0x24, 0x6e, 0xea, 0x2d, 0xad, 0x6d, 0x60, 0xf9, 0x82, 0x3e, 0x80, 0xca, 0x22, 0x9c, 0x12, 0x46,
	0x9b, 0xa5, 0x96, 0xde, 0xae, 0x1f, 0x34, 0xa4, 0xe5, 0x97, 0x42, 0x86, 0x15, 0xc6, 0xfd, 0x4f,
	0xa9, 0x47, 0x19, 0x6d, 0x96, 0x85, 0x56, 0xce, 0xbf, 0x44, 0xd0, 0x3b, 0x50, 0x21, 0x2c, 0x98,
	0xbb, 0x93, 0x66, 0xa5, 0xa5, 0xb5, 0x6b, 0x58, 0xbd, 0x59, 0x7f, 0xd0, 0xa0, 0x22, 0xdd, 0xa1,
	0x5d, 0x28, 0x85, 0x84, 0x3d, 0x16, 0xe7, 0xcf, 0x3b, 0x11, 0x72, 0xf4, 0x21, 0x94, 0x9f, 0x10,
	0x6f, 0x41, 0x55, 0x14, 0x75, 0xa9, 0xf0, 0x88, 0x8b, 0x8e, 0x8a, 0x4d, 0x0d, 0x4b, 0x14, 0x59,
	0xa0, 0x3f, 0x21, 0x9e, 0x88, 0xa3, 0x7e, 0x60, 0x4a, 0xa5, 0xd1, 0x32, 0xa4, 0x53, 0xa1, 0x89,
	0x39, 0x88, 0x76, 0x01, 0xa6, 0x8b, 0xd0, 0xe3, 0xd7, 0x47, 0xe3, 0x66, 0xa9, 0xa5, 0xb5, 0xb7,
	0xf0, 0x8a, 0xc4, 0xfa, 0x9f, 0x0e, 0x90, 0xd9, 0xa0, 0xf7, 0x01, 0x62, 0x16, 0xb9, 0xfe, 0x6c,
	0xcc, 0x3d, 0xf3, 0xf3, 0x19, 0xe7, 0x05, 0x6c, 0x48, 0xd9, 0x23, 0xe2, 0xa1, 0x3b, 0x50, 0x75,
	0x7d, 0x26, 0x50, 0x7e, 0x38, 0xfd, 0xbc, 0x80, 0x2b, 0xae, 0xcf, 0x38, 0xf4, 0x1e, 0xd4, 0x16,
	0x09, 0xc6, 0xcf, 0x54, 0x3a, 0x2f, 0xe0, 0xea, 0x22, 0x03, 0xaf, 0x82, 0xc0, 0x13, 0x20, 0x3f,
	0x45, 0x8d, 0x83, 0x5c, 0xc2, 0xc1, 0xef, 0x80, 0x71, 0xb5, 0x64, 0x34, 0x16, 0x68, 0xb9, 0xa5,
	0xb5, 0x1b, 0xe7, 0x05, 0x5c, 0x13, 0x22, 0x05, 0x5f, 0x7b, 0x01, 0x91, 0x9e, 0xf9, 0xa5, 0x16,
	0x39, 0x2c, 0x44, 0x1c, 0x3e, 0x80, 0xfa, 0x94, 0x4e, 0xdc, 0x39, 0x91, 0xde, 0xab, 0xe2, 0x3a,
	0x6e, 0xcb, 0xeb, 0x38, 0x91, 0xc0, 0xe1, 0xf7, 0xcf, 0x0b, 0x18, 0x94, 0x16, 0xb7, 0x39, 0x84,
	0x86, 0x47, 0xc9, 0xb5, 0xe7, 0xc6, 0xd2, 0x6b, 0x4d, 0x18, 0x6d, 0x4b, 0xa3, 0xe1, 0x84, 0x78,
	0x24, 0xb2, 0xa3, 0x88, 0x2c, 0xcf, 0x0b, 0xb8, 0x9e, 0x28, 0x72, 0xbb, 0x7d, 0xa8, 0x12, 0x7f,
	0x29, 0x4c, 0x0c, 0x61, 0xf2, 0x76, 0x47, 0x96, 0x79, 0x27, 0x29, 0xf3, 0x8e, 0xed, 0x73, 0xab,
	0x0a, 0xf1, 0x97, 0x2a, 0xee, 0x5f, 0xc7, 0x81, 0x2f, 0x2c, 0x40, 0x45, 0x56, 0xe5, 0x12, 0x0e,
	0x7e, 0x00, 0x5b, 0x02, 0x74, 0x29, 0xbb, 0x16, 0x1a, 0x75, 0xa5, 0x51, 0xe7, 0xe2, 0x2e, 0x65,
	0xd7, 0x2a, 0x7c, 0x12, 0x4f, 0x5c, 0x57, 0x68, 0x34, 0x54, 0x4a, 0x6a, 0x42, 0xc4, 0xe1, 0x7b,
	0x50, 0x17, 0xdf, 0x1e, 0x8b, 0xfb, 0x6a, 0x6e, 0x29, 0x17, 0x20, 0x84, 0x47, 0x5c, 0x76, 0x54,
	0x55, 0xf5, 0x64, 0x3d, 0x85, 0x12, 0x2f, 0x33, 0x74, 0x17, 0xaa, 0xd4, 0xa3, 0x73, 0xea, 0xb3,
	0xa6, 0xd6, 0xd2, 0xdb, 0x86, 0xa8, 0xaa, 0x44, 0xc4, 0x2b, 0x38, 0x88, 0xdc, 0x99, 0xeb, 0x8b,
	0x14, 0x1b, 0x58, 0xbd, 0x21, 0x0b, 0x4a, 0x5c, 0xa5, 0xa9, 0x8b, 0xda, 0xbf, 0x95, 0x95, 0xad,
	0xe3, 0xd1, 0x39, 0x16, 0x18, 0xb7, 0x65, 0x24, 0x9a, 0x51, 0x26, 0xb2, 0x6c, 0x60, 0xf5, 0x66,
	0xfd, 0x4e, 0x83, 0x5a, 0xa2, 0x8a, 0x10, 0x94, 0x7c, 0x32, 0xa7, 0xb2, 0xbe, 0xb0, 0x78, 0x46,
	0x1f, 0x83, 0xfe, 0x15, 0x5d, 0x36, 0x8b, 0xc2, 0xf7, 0xbb, 0x79, 0xdf, 0x9d, 0x9f, 0xd3, 0xa5,
	0xe3, 0xb3, 0x68, 0x89, 0xb9, 0xce, 0xce, 0x21, 0xd4, 0x12, 0x01, 0x32, 0xa5, 0x99, 0xf4, 0xc4,
	0x1f, 0x79, 0x7f, 0x67, 0xcd, 0x63, 0xa8, 0x5e, 0x79, 0x58, 0xfc, 0xa1, 0x66, 0x39, 0x50, 0x96,
	0x55, 0x9e, 0xaa, 0x70, 0xb3, 0x46, 0xd6, 0x4e, 0x25, 0xb6, 0x0c, 0xa5, 0xdd, 0xad, 0x24, 0x3c,
	0xc7, 0x9f, 0x04, 0x53, 0xd7, 0x9f, 0x61, 0x81, 0x3d, 0x2c, 0x36, 0x35, 0x6b, 0x02, 0x65, 0x27,
	0x8a, 0x82, 0x88, 0x87, 0x31, 0x09, 0xa6, 0xd2, 0xcb, 0x16, 0x16, 0xcf, 0xa8, 0x09, 0xd5, 0x39,
	0x8d, 0x63, 0x32, 0x4b, 0xbe, 0x9f, 0xbc, 0xa2, 0x36, 0x94, 0xa6, 0x84, 0x11, 0xd5, 0xae, 0x1b,
	0xeb, 0x06, 0x0b, 0x0d, 0xf1, 0x11, 0x1b, 0x8c, 0xb4, 0x76, 0xf9, 0xa5, 0x4e, 0xdd, 0x99, 0xcb,
	0x62, 0xc5, 0x78, 0xea, 0x8d, 0x93, 0x61, 0x18, 0xd1, 0x89, 0x1b, 0xbb, 0x81, 0xcc, 0xd5, 0x16,
	0xce, 0x04, 0xd6, 0x8f, 0xa0, 0xbe, 0x52, 0xc9, 0x68, 0x2f, 0x9f, 0xf3, 0x4d, 0x8c, 0x91, 0x28,
	0x58, 0x7f, 0xd3, 0xc0, 0x1c, 0x2e, 0xae, 0x38, 0x5f, 0x5f, 0x51, 0x4c, 0xbf, 0x5e, 0xd0, 0x98,
	0xa1, 0x43, 0x30, 0xe2, 0x44, 0xa6, 0xa8, 0xeb, 0x1d, 0xd5, 0x30, 0x52, 0x1c, 0x72, 0x86, 0xee,
	0xb9, 0x31, 0x13, 0x94, 0x91, 0xa8, 0xa2, 0x16, 0x94, 0xc2, 0xc0, 0x4b, 0x78, 0x2a, 0x61, 0xbb,
	0xc0, 0xf3, 0xce, 0x0b, 0x58, 0x20, 0xe8, 0x13, 0xa8, 0x0a, 0x16, 0x56, 0x0c, 0x95, 0x76, 0xaf,
	0xcd, 0x85, 0xca, 0x61, 0xa2, 0x81, 0xbe, 0x0b, 0x06, 0x7d, 0xca, 0xa8, 0x2f, 0x82, 0x96, 0x34,
	0xfc, 0x56, 0x27, 0x1d, 0x1b, 0x4e, 0x02, 0xe1, 0x4c, 0xeb, 0xc8, 0x80, 0x6a, 0x24, 0x83, 0xb0,
	0x2a, 0x50, 0xe2, 0x9f, 0xb6, 0x9e, 0x69, 0xb0, 0xbd, 0x12, 0x61, 0x1c, 0x06, 0x7e, 0x4c, 0xd1,
	0xa7, 0xe9, 0x14, 0x90, 0xf1, 0x21, 0x79, 0x8e, 0xd5, 0x09, 0xc4, 0x7b, 0x5b, 0x4d, 0x83, 0x0f,
	0x61, 0x2b, 0x5e, 0xfa, 0x93, 0x71, 0xa4, 0xcc, 0x45, 0x84, 0x9c, 0xd8, 0x1a, 0x5c, 0x9c, 0x3a,
	0xfd, 0x08, 0xca, 0x94, 0xd7, 0x8b, 0x8a, 0x4d, 0xb1, 0xb9, 0x28, 0x21, 0xde, 0x77, 0xe7, 0x05,
	0x2c, 0xf1, 0x6f, 0x13, 0x19, 0x40, 0x2d, 0xf9, 0xba, 0xf5, 0x27, 0x3d, 0x4d, 0x5a, 0x9a, 0x89,
	0x95, 0x89, 0xa8, 0xbd, 0x72, 0x22, 0x1e, 0x42, 0x23, 0x5e, 0xb1, 0x53, 0x3d, 0x88, 0xd6, 0x73,
	0x8b, 0x73, 0x7a, 0xe8, 0x7d, 0xa8, 0x2f, 0x62, 0x3a, 0x4e, 0x52, 0x27, 0xa2, 0xc7, 0xb0, 0x88,
	0xa9, 0xad, 0x52, 0x65, 0x81, 0xfe, 0x75, 0x90, 0xe4, 0x54, 0x95, 0xdb, 0x2f, 0x06, 0xc3, 0x0b,
	0x12, 0x7d, 0xc5, 0x5b, 0x8a, 0x83, 0x68, 0x1f, 0x4a, 0x73, 0xde, 0x44, 0x65, 0xd1, 0x75, 0xef,
	0x6d, 0x2e, 0xa8, 0xce, 0x45, 0x30, 0xa5, 0x58, 0x28, 0xa2, 0x4f, 0x60, 0x9b, 0x78, 0x5e, 0xf0,
	0x9b, 0x31, 0x99, 0xcd, 0x22, 0x3a, 0x13, 0x49, 0x51, 0xa3, 0xd6, 0x14, 0x80, 0x9d, 0xc9, 0x51,
	0x07, 0xf8, 0x79, 0xc6, 0xdc, 0xd0, 0x8b, 0x9b, 0x55, 0x11, 0x98, 0x2a, 0x2e, 0xee, 0xd2, 0x3b,
	0x21, 0x8c, 0x60, 0x63, 0x11, 0x53, 0xf1, 0x16, 0xa3, 0x3d, 0xa8, 0x51, 0xd5, 0xf1, 0x62, 0x26,
	0xac, 0xf3, 0x40, 0x8a, 0xa3, 0x7b, 0xd0, 0x90, 0x85, 0x10, 0x8f, 0x03, 0xdf, 0x5b, 0x8a, 0x81,
	0x50, 0xc3, 0x75, 0x25, 0x1b, 0xf8, 0xde, 0xd2, 0xba, 0x0f, 0x25, 0xee, 0x18, 0x01, 0x54, 0x86,
	0x23, 0xec, 0xd8, 0x17, 0x66, 0x01, 0xd5, 0xa0, 0x34, 0xe8, 0x1f, 0x3b, 0xa6, 0xc6, 0x9f, 0x2e,
	0x07, 0xbd, 0x9e, 0x59, 0xb4, 0xfe, 0xa5, 0x41, 0x63, 0x35, 0xe6, 0xd7, 0x6e, 0x08, 0x7b, 0xea,
	0xd6, 0x24, 0x57, 0x6d, 0x68, 0xc3, 0x95, 0x0b, 0xfb, 0x08, 0x6e, 0xc7, 0x64, 0x1e, 0x7a, 0x74,
	0xec, 0xfa, 0x8c, 0x46, 0xe9, 0x78, 0xc6, 0xb7, 0xa4, 0xb8, 0xab, 0xa4, 0xe8, 0x33, 0x40, 0xf1,
	0x22, 0x0c, 0x23, 0x1a, 0xc7, 0xe3, 0x88, 0x4e, 0x17, 0xfe, 0x94, 0xf8, 0x92, 0xc7, 0x6b, 0x78,
	0x3b, 0x41, 0x70, 0x02, 0x70, 0xf5, 0xc7, 0x94, 0x44, 0xec, 0x8a, 0x12, 0x96, 0xb9, 0x2e, 0x0b,
	0xd7, 0xdb, 0x29, 0x92, 0x78, 0xb7, 0xee, 0x03, 0x64, 0xb9, 0x17, 0x3c, 0x29, 0x1f, 0x15, 0x7d,
	0x26, 0xaf, 0xd6, 0xe7, 0x50, 0x16, 0xf5, 0xf3, 0xda, 0x3b, 0x48, 0x17, 0xb9, 0xe2, 0xca, 0x22,
	0x67, 0x75, 0xc0, 0x48, 0x69, 0x03, 0xdd, 0x4b, 0x54, 0x24, 0xe3, 0xd5, 0x57, 0x68, 0x25, 0xd1,
	0xff, 0xab, 0x06, 0x30, 0xa4, 0x2c, 0x21, 0xb9, 0x9b, 0xf4, 0x4b, 0xb6, 0x05, 0x16, 0x5f, 0xb9,
	0x05, 0xde, 0xe7, 0x94, 0x13, 0x7a, 0x64, 0x42, 0xd5, 0xb8, 0xcc, 0x2f, 0x94, 0x09, 0x78, 0xc3,
	0xbd, 0xf3, 0xcd, 0x99, 0xc1, 0xfa, 0x87, 0x06, 0x75, 0x11, 0x97, 0x62, 0xa1, 0x9b, 0x04, 0xd6,
	0xc9, 0xd8, 0x24, 0x4f, 0x02, 0xea, 0x38, 0x34, 0x5e, 0x78, 0x0c, 0xa7, 0x3a, 0xe8, 0xe3, 0x6c,
	0xd8, 0xe9, 0x1b, 0xb9, 0x2d, 0x9b, 0x7e, 0xb9, 0xbd, 0xbd, 0xf4, 0xf2, 0xde, 0xfe, 0x2d, 0xe2,
	0xfb, 0x8f, 0x06, 0x8d, 0xd5, 0x63, 0xa1, 0xd6, 0xda, 0x3f, 0x03, 0x71, 0x82, 0x95, 0xaf, 0x24,
	0x05, 0x55, 0x7c, 0x45, 0x41, 0xbd, 0x41, 0x38, 0x9f, 0x42, 0x31, 0x90, 0x71, 0xdc, 0x3a, 0xb8,
	0xbb, 0x7e, 0x47, 0x9d, 0x41, 0x48, 0x23, 0xc1, 0x40, 0xb8, 0x18, 0x84, 0xd6, 0xe7, 0x60, 0xa4,
	0x02, 0x54, 0x87, 0x6a, 0xb7, 0xff, 0xc8, 0xee, 0x75, 0x4f, 0xcc, 0x02, 0x27, 0x86, 0x13, 0xa7,
	0xe7, 0x8c, 0x38, 0x1d, 0xd4, 0xa1, 0x8a, 0x9d, 0xcb, 0x9e, 0x7d, 0xec, 0x98, 0x45, 0x0e, 0x7c,
	0x79, 0x79, 0x62, 0x8f, 0x1c, 0x53, 0xb7, 0xfe, 0x52, 0x04, 0x38, 0x7b, 0xb3, 0x12, 0xcd, 0x42,
	0xd5, 0x37, 0x86, 0xfa, 0x99, 0xda, 0x75, 0x74, 0x11, 0xc1, 0x1d, 0x89, 0x67, 0xdf, 0xe8, 0x70,
	0x5e, 0xe4, 0x8b, 0x81, 0x5c, 0x7b, 0x72, 0xb4, 0x58, 0x7e, 0x0d, 0x2d, 0xe6, 0x29, 0xb7, 0xf2,
	0x5a, 0xca, 0xcd, 0xe5, 0xbe, 0x7a, 0xa3, 0xdc, 0xff, 0x18, 0x6a, 0xc9, 0x01, 0x51, 0x15, 0x74,
	0xbb, 0xd7, 0x93, 0x57, 0x79, 0x3c, 0xe8, 0x9f, 0x76, 0xcf, 0x4c, 0x0d, 0x19, 0x50, 0x1e, 0x8e,
	0xf8, 0xe5, 0x15, 0xd1, 0x6d, 0xa8, 0x0f, 0x2e, 0x1d, 0x6c, 0x8f, 0xba, 0x83, 0xbe, 0xdd, 0x33,
	0x75, 0xeb, 0x8f, 0x1a, 0xd4, 0xcf, 0x56, 0x1a, 0xe3, 0x10, 0x1a, 0xfe, 0xca, 0x7c, 0x57, 0x54,
	0xb1, 0x61, 0xf2, 0xe3, 0x9c, 0x1e, 0xff, 0x93, 0x26, 0xc7, 0x7a, 0x71, 0x73, 0xad, 0x6c, 0x1a,
	0xea, 0xfa, 0x8d, 0xc2, 0x3b, 0x85, 0xed, 0x63, 0x12, 0x92, 0x2b, 0xd7, 0x73, 0xd9, 0x32, 0xc9,
	0x7a, 0xce, 0x8f, 0x76, 0x23, 0x3f, 0xff, 0xd6, 0x00, 0xad, 0x3a, 0x52, 0x01, 0x3f, 0x04, 0x93,
	0x93, 0x79, 0x10, 0x31, 0x3a, 0x4d, 0xd2, 0xa4, 0x6d, 0x4e, 0xd3, 0xed, 0x54, 0x51, 0x25, 0xeb,
	0xa7, 0xf0, 0x56, 0x66, 0x9b, 0xa4, 0x3c, 0x16, 0x65, 0xb6, 0x5e, 0x13, 0x28, 0x55, 0x4d, 0x44,
	0x31, 0x1f, 0x9a, 0xb3, 0xfe, 0x45, 0x77, 0xfc, 0x84, 0x46, 0xea, 0x46, 0x38, 0x77, 0xd7, 0xb9,
	0xec, 0x91, 0x14, 0xe5, 0x23, 0x2d, 0xdd, 0x28, 0xd2, 0x5f, 0x81, 0x91, 0x1e, 0x7a, 0xe3, 0xbf,
	0x0b, 0x0b, 0x1a, 0x41, 0x34, 0x23, 0xbe, 0xfb, 0x5b, 0xc2, 0x92, 0x65, 0xd9, 0xc0, 0x39, 0x19,
	0x1f, 0x49, 0xf9, 0x53, 0x25, 0xaf, 0x7b, 0x27, 0x50, 0x4b, 0x22, 0xe0, 0x43, 0xfb, 0x67, 0xc3,
	0x41, 0xdf, 0x2c, 0xf0, 0x22, 0x3b, 0xfa, 0xe5, 0xc8, 0x19, 0xca, 0x7a, 0xbb, 0xc4, 0x83, 0xd1,
	0xc0, 0x2c, 0xf2, 0x47, 0x7b, 0x78, 0xdc, 0xed, 0x9a, 0x3a, 0xda, 0x02, 0x83, 0xab, 0x8e, 0xbb,
	0xce, 0xe8, 0xd4, 0x2c, 0xed, 0xd9, 0xf9, 0xf5, 0x4c, 0x2c, 0x06, 0x08, 0x6e, 0x8d, 0x6c, 0x7c,
	0xe6, 0x8c, 0xc6, 0x27, 0xce, 0x69, 0xb7, 0xef, 0x70, 0x4e, 0xd8, 0x02, 0x63, 0xd0, 0x1f, 0x1f,
	0x9f, 0xdb, 0xfd, 0x33, 0x4e, 0x0b, 0x7c, 0x77, 0xb0, 0x2f, 0x2e, 0x7b, 0x8e, 0x59, 0x3c, 0x78,
	0xa1, 0x41, 0x89, 0x5f, 0x15, 0xb2, 0xa1, 0x91, 0x66, 0xd6, 0xa5, 0x31, 0x52, 0x7f, 0x98, 0xd6,
	0xca, 0x66, 0xa7, 0xb9, 0x0e, 0xa8, 0x32, 0xd8, 0x03, 0xfd, 0x8c, 0x32, 0x64, 0xbe, 0xdc, 0xfb,
	0x3b, 0xdb, 0x2b, 0x92, 0x4c, 0x77, 0x98, 0xe9, 0x0e, 0xd7, 0x74, 0x57, 0x07, 0xcd, 0x17, 0x60,
	0xa4, 0x8b, 0x35, 0xca, 0x6f, 0x26, 0xe9, 0x7f, 0x89, 0x9d, 0x77, 0xd7, 0xe4, 0xd2, 0xba, 0xad,
	0x3d, 0xd0, 0x1e, 0x7e, 0x01, 0x0d, 0x91, 0xee, 0x98, 0x46, 0x4f, 0xdc, 0x09, 0x45, 0x77, 0xd7,
	0xfe, 0x2b, 0x9d, 0xba, 0x1e, 0x1d, 0x88, 0x5b, 0x8c, 0x9b, 0xff, 0xad, 0xaa, 0x12, 0xf2, 0xe7,
	0xee, 0x50, 0x5a, 0x1c, 0xb5, 0xfe, 0xfc, 0x93, 0xf2, 0x83, 0xce, 0x0f, 0x3a, 0x0f, 0xbe, 0x79,
	0xbe, 0xab, 0x3d, 0x7b, 0xbe, 0xab, 0xfd, 0xf3, 0xf9, 0xae, 0xf6, 0xfb, 0x17, 0xbb, 0x85, 0x67,
	0x2f, 0x76, 0x0b, 0x7f, 0x7f, 0xb1, 0x5b, 0xb8, 0xaa, 0x08, 0x5f, 0xdf, 0xfb, 0x7f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x3a, 0x7c, 0x2d, 0x08, 0xe2, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GNMIClient is the client API for GNMI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GNMIClient interface {
	// Capabilities allows the client to retrieve the set of capabilities that
	// is supported by the target. This allows the target to validate the
	// service version that is implemented and retrieve the set of models that
	// the target supports. The models can then be specified in subsequent RPCs
	// to restrict the set of data that is utilized.
	// Reference: gNMI Specification Section 3.2
	Capabilities(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (*CapabilityResponse, error)
	// Retrieve a snapshot of data from the target. A Get RPC requests that the
	// target snapshots a subset of the data tree as specified by the paths
	// included in the message and serializes this to be returned to the
	// client using the specified encoding.
	// Reference: gNMI Specification Section 3.3
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Set allows the client to modify the state of data on the target. The
	// paths to modified along with the new values that the client wishes
	// to set the value to.
	// Reference: gNMI Specification Section 3.4
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Subscribe allows a client to request the target to send it values
	// of particular paths within the data tree. These values may be streamed
	// at a particular cadence (STREAM), sent one off on a long-lived channel
	// (POLL), or sent as a one-off retrieval (ONCE).
	// Reference: gNMI Specification Section 3.5
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (GNMI_SubscribeClient, error)
}

type gNMIClient struct {
	cc *grpc.ClientConn
}

func NewGNMIClient(cc *grpc.ClientConn) GNMIClient {
	return &gNMIClient{cc}
}

func (c *gNMIClient) Capabilities(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (*CapabilityResponse, error) {
	out := new(CapabilityResponse)
	err := c.cc.Invoke(ctx, "/gnmi.gNMI/Capabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gNMIClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, "/gnmi.gNMI/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gNMIClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, "/gnmi.gNMI/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gNMIClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (GNMI_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GNMI_serviceDesc.Streams[0], "/gnmi.gNMI/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &gNMISubscribeClient{stream}
	return x, nil
}

type GNMI_SubscribeClient interface {
	Send(*SubscribeRequest) error
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type gNMISubscribeClient struct {
	grpc.ClientStream
}

func (x *gNMISubscribeClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gNMISubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GNMIServer is the server API for GNMI service.
type GNMIServer interface {
	// Capabilities allows the client to retrieve the set of capabilities that
	// is supported by the target. This allows the target to validate the
	// service version that is implemented and retrieve the set of models that
	// the target supports. The models can then be specified in subsequent RPCs
	// to restrict the set of data that is utilized.
	// Reference: gNMI Specification Section 3.2
	Capabilities(context.Context, *CapabilityRequest) (*CapabilityResponse, error)
	// Retrieve a snapshot of data from the target. A Get RPC requests that the
	// target snapshots a subset of the data tree as specified by the paths
	// included in the message and serializes this to be returned to the
	// client using the specified encoding.
	// Reference: gNMI Specification Section 3.3
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Set allows the client to modify the state of data on the target. The
	// paths to modified along with the new values that the client wishes
	// to set the value to.
	// Reference: gNMI Specification Section 3.4
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// Subscribe allows a client to request the target to send it values
	// of particular paths within the data tree. These values may be streamed
	// at a particular cadence (STREAM), sent one off on a long-lived channel
	// (POLL), or sent as a one-off retrieval (ONCE).
	// Reference: gNMI Specification Section 3.5
	Subscribe(GNMI_SubscribeServer) error
}

// UnimplementedGNMIServer can be embedded to have forward compatible implementations.
type UnimplementedGNMIServer struct {
}

func (*UnimplementedGNMIServer) Capabilities(ctx context.Context, req *CapabilityRequest) (*CapabilityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Capabilities not implemented")
}
func (*UnimplementedGNMIServer) Get(ctx context.Context, req *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedGNMIServer) Set(ctx context.Context, req *SetRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedGNMIServer) Subscribe(srv GNMI_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterGNMIServer(s *grpc.Server, srv GNMIServer) {
	s.RegisterService(&_GNMI_serviceDesc, srv)
}

func _GNMI_Capabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GNMIServer).Capabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnmi.gNMI/Capabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GNMIServer).Capabilities(ctx, req.(*CapabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GNMI_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GNMIServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnmi.gNMI/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GNMIServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GNMI_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GNMIServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gnmi.gNMI/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GNMIServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GNMI_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GNMIServer).Subscribe(&gNMISubscribeServer{stream})
}

type GNMI_SubscribeServer interface {
	Send(*SubscribeResponse) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type gNMISubscribeServer struct {
	grpc.ServerStream
}

func (x *gNMISubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gNMISubscribeServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GNMI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gnmi.gNMI",
	HandlerType: (*GNMIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Capabilities",
			Handler:    _GNMI_Capabilities_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GNMI_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _GNMI_Set_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _GNMI_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "onos/gnmi/gnmi/gnmi.proto",
}

func (m *Notification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Atomic {
		i--
		if m.Atomic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Delete) > 0 {
		for iNdEx := len(m.Delete) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delete[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Update) > 0 {
		for iNdEx := len(m.Update) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Update[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Alias) > 0 {
		i -= len(m.Alias)
		copy(dAtA[i:], m.Alias)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Alias)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Duplicates != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Duplicates))
		i--
		dAtA[i] = 0x20
	}
	if m.Val != nil {
		{
			size, err := m.Val.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TypedValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypedValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TypedValue_StringVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_StringVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringVal)
	copy(dAtA[i:], m.StringVal)
	i = encodeVarintGnmi(dAtA, i, uint64(len(m.StringVal)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *TypedValue_IntVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_IntVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintGnmi(dAtA, i, uint64(m.IntVal))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *TypedValue_UintVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_UintVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintGnmi(dAtA, i, uint64(m.UintVal))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *TypedValue_BoolVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_BoolVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolVal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *TypedValue_BytesVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_BytesVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesVal != nil {
		i -= len(m.BytesVal)
		copy(dAtA[i:], m.BytesVal)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.BytesVal)))
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *TypedValue_FloatVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_FloatVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 4
	encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.FloatVal))))
	i--
	dAtA[i] = 0x35
	return len(dAtA) - i, nil
}
func (m *TypedValue_DecimalVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_DecimalVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DecimalVal != nil {
		{
			size, err := m.DecimalVal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TypedValue_LeaflistVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_LeaflistVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaflistVal != nil {
		{
			size, err := m.LeaflistVal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *TypedValue_AnyVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_AnyVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyVal != nil {
		{
			size, err := m.AnyVal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *TypedValue_JsonVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_JsonVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsonVal != nil {
		i -= len(m.JsonVal)
		copy(dAtA[i:], m.JsonVal)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.JsonVal)))
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *TypedValue_JsonIetfVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_JsonIetfVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JsonIetfVal != nil {
		i -= len(m.JsonIetfVal)
		copy(dAtA[i:], m.JsonIetfVal)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.JsonIetfVal)))
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *TypedValue_AsciiVal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_AsciiVal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.AsciiVal)
	copy(dAtA[i:], m.AsciiVal)
	i = encodeVarintGnmi(dAtA, i, uint64(len(m.AsciiVal)))
	i--
	dAtA[i] = 0x62
	return len(dAtA) - i, nil
}
func (m *TypedValue_ProtoBytes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TypedValue_ProtoBytes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProtoBytes != nil {
		i -= len(m.ProtoBytes)
		copy(dAtA[i:], m.ProtoBytes)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.ProtoBytes)))
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Path) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Path) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Path) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Elem) > 0 {
		for iNdEx := len(m.Elem) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elem[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Origin) > 0 {
		i -= len(m.Origin)
		copy(dAtA[i:], m.Origin)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Origin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Element) > 0 {
		for iNdEx := len(m.Element) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Element[iNdEx])
			copy(dAtA[i:], m.Element[iNdEx])
			i = encodeVarintGnmi(dAtA, i, uint64(len(m.Element[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PathElem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathElem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathElem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		for k := range m.Key {
			v := m.Key[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGnmi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGnmi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGnmi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Decimal64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Decimal64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Decimal64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precision != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x10
	}
	if m.Digits != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Digits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScalarArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalarArray) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalarArray) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Element) > 0 {
		for iNdEx := len(m.Element) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Element[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeRequest_Subscribe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest_Subscribe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subscribe != nil {
		{
			size, err := m.Subscribe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SubscribeRequest_Poll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest_Poll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Poll != nil {
		{
			size, err := m.Poll.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SubscribeRequest_Aliases) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest_Aliases) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Aliases != nil {
		{
			size, err := m.Aliases.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Poll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Poll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Poll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SubscribeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeResponse_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SubscribeResponse_SyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse_SyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.SyncResponse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *SubscribeResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeResponse_Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SubscriptionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscriptionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscriptionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatesOnly {
		i--
		if m.UpdatesOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Encoding != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Encoding))
		i--
		dAtA[i] = 0x40
	}
	if len(m.UseModels) > 0 {
		for iNdEx := len(m.UseModels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UseModels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.AllowAggregation {
		i--
		if m.AllowAggregation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Mode != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x28
	}
	if m.Qos != nil {
		{
			size, err := m.Qos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UseAliases {
		i--
		if m.UseAliases {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Subscription) > 0 {
		for iNdEx := len(m.Subscription) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subscription[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subscription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subscription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeartbeatInterval != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.HeartbeatInterval))
		i--
		dAtA[i] = 0x28
	}
	if m.SuppressRedundant {
		i--
		if m.SuppressRedundant {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SampleInterval != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.SampleInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.Mode != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QOSMarking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QOSMarking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QOSMarking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Marking != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Marking))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Alias) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alias) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Alias) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Alias) > 0 {
		i -= len(m.Alias)
		copy(dAtA[i:], m.Alias)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Alias)))
		i--
		dAtA[i] = 0x12
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AliasList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AliasList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AliasList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Alias) > 0 {
		for iNdEx := len(m.Alias) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Alias[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Update) > 0 {
		for iNdEx := len(m.Update) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Update[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Replace) > 0 {
		for iNdEx := len(m.Replace) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replace[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Delete) > 0 {
		for iNdEx := len(m.Delete) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Delete[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Response) > 0 {
		for iNdEx := len(m.Response) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Response[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x20
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.UseModels) > 0 {
		for iNdEx := len(m.UseModels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UseModels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Encoding != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Encoding))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintGnmi(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Path) > 0 {
		for iNdEx := len(m.Path) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Path[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Prefix != nil {
		{
			size, err := m.Prefix.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGnmi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Notification) > 0 {
		for iNdEx := len(m.Notification) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Notification[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CapabilityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapabilityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CapabilityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapabilityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Extension[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.GNMIVersion) > 0 {
		i -= len(m.GNMIVersion)
		copy(dAtA[i:], m.GNMIVersion)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.GNMIVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SupportedEncodings) > 0 {
		dAtA26 := make([]byte, len(m.SupportedEncodings)*10)
		var j25 int
		for _, num := range m.SupportedEncodings {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintGnmi(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SupportedModels) > 0 {
		for iNdEx := len(m.SupportedModels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SupportedModels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGnmi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGnmi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGnmi(dAtA []byte, offset int, v uint64) int {
	offset -= sovGnmi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Notification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGnmi(uint64(m.Timestamp))
	}
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Update) > 0 {
		for _, e := range m.Update {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if len(m.Delete) > 0 {
		for _, e := range m.Delete {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if m.Atomic {
		n += 2
	}
	return n
}

func (m *Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Duplicates != 0 {
		n += 1 + sovGnmi(uint64(m.Duplicates))
	}
	return n
}

func (m *TypedValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *TypedValue_StringVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringVal)
	n += 1 + l + sovGnmi(uint64(l))
	return n
}
func (m *TypedValue_IntVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGnmi(uint64(m.IntVal))
	return n
}
func (m *TypedValue_UintVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovGnmi(uint64(m.UintVal))
	return n
}
func (m *TypedValue_BoolVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *TypedValue_BytesVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesVal != nil {
		l = len(m.BytesVal)
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *TypedValue_FloatVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 5
	return n
}
func (m *TypedValue_DecimalVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecimalVal != nil {
		l = m.DecimalVal.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *TypedValue_LeaflistVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaflistVal != nil {
		l = m.LeaflistVal.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *TypedValue_AnyVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyVal != nil {
		l = m.AnyVal.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *TypedValue_JsonVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsonVal != nil {
		l = len(m.JsonVal)
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *TypedValue_JsonIetfVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JsonIetfVal != nil {
		l = len(m.JsonIetfVal)
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *TypedValue_AsciiVal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AsciiVal)
	n += 1 + l + sovGnmi(uint64(l))
	return n
}
func (m *TypedValue_ProtoBytes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtoBytes != nil {
		l = len(m.ProtoBytes)
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *Path) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Element) > 0 {
		for _, s := range m.Element {
			l = len(s)
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	l = len(m.Origin)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Elem) > 0 {
		for _, e := range m.Elem {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}

func (m *PathElem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Key) > 0 {
		for k, v := range m.Key {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGnmi(uint64(len(k))) + 1 + len(v) + sovGnmi(uint64(len(v)))
			n += mapEntrySize + 1 + sovGnmi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGnmi(uint64(m.Type))
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGnmi(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}

func (m *Decimal64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Digits != 0 {
		n += 1 + sovGnmi(uint64(m.Digits))
	}
	if m.Precision != 0 {
		n += 1 + sovGnmi(uint64(m.Precision))
	}
	return n
}

func (m *ScalarArray) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Element) > 0 {
		for _, e := range m.Element {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *SubscribeRequest_Subscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subscribe != nil {
		l = m.Subscribe.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *SubscribeRequest_Poll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Poll != nil {
		l = m.Poll.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *SubscribeRequest_Aliases) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aliases != nil {
		l = m.Aliases.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *Poll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SubscribeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *SubscribeResponse_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *SubscribeResponse_SyncResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *SubscribeResponse_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}
func (m *SubscriptionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Subscription) > 0 {
		for _, e := range m.Subscription {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if m.UseAliases {
		n += 2
	}
	if m.Qos != nil {
		l = m.Qos.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovGnmi(uint64(m.Mode))
	}
	if m.AllowAggregation {
		n += 2
	}
	if len(m.UseModels) > 0 {
		for _, e := range m.UseModels {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if m.Encoding != 0 {
		n += 1 + sovGnmi(uint64(m.Encoding))
	}
	if m.UpdatesOnly {
		n += 2
	}
	return n
}

func (m *Subscription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovGnmi(uint64(m.Mode))
	}
	if m.SampleInterval != 0 {
		n += 1 + sovGnmi(uint64(m.SampleInterval))
	}
	if m.SuppressRedundant {
		n += 2
	}
	if m.HeartbeatInterval != 0 {
		n += 1 + sovGnmi(uint64(m.HeartbeatInterval))
	}
	return n
}

func (m *QOSMarking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Marking != 0 {
		n += 1 + sovGnmi(uint64(m.Marking))
	}
	return n
}

func (m *Alias) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}

func (m *AliasList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Alias) > 0 {
		for _, e := range m.Alias {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *SetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Delete) > 0 {
		for _, e := range m.Delete {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if len(m.Replace) > 0 {
		for _, e := range m.Replace {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if len(m.Update) > 0 {
		for _, e := range m.Update {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *SetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovGnmi(uint64(m.Timestamp))
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *UpdateResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGnmi(uint64(m.Timestamp))
	}
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovGnmi(uint64(m.Op))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prefix != nil {
		l = m.Prefix.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Path) > 0 {
		for _, e := range m.Path {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovGnmi(uint64(m.Type))
	}
	if m.Encoding != 0 {
		n += 1 + sovGnmi(uint64(m.Encoding))
	}
	if len(m.UseModels) > 0 {
		for _, e := range m.UseModels {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Notification) > 0 {
		for _, e := range m.Notification {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *CapabilityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *CapabilityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupportedModels) > 0 {
		for _, e := range m.SupportedModels {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	if len(m.SupportedEncodings) > 0 {
		l = 0
		for _, e := range m.SupportedEncodings {
			l += sovGnmi(uint64(e))
		}
		n += 1 + sovGnmi(uint64(l)) + l
	}
	l = len(m.GNMIVersion)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = e.Size()
			n += 1 + l + sovGnmi(uint64(l))
		}
	}
	return n
}

func (m *ModelData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGnmi(uint64(l))
	}
	return n
}

func sovGnmi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGnmi(x uint64) (n int) {
	return sovGnmi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Notification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &Path{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, &Update{})
			if err := m.Update[len(m.Update)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = append(m.Delete, &Path{})
			if err := m.Delete[len(m.Delete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atomic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Atomic = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &TypedValue{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duplicates", wireType)
			}
			m.Duplicates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duplicates |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypedValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypedValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypedValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &TypedValue_StringVal{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntVal", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &TypedValue_IntVal{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintVal", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &TypedValue_UintVal{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolVal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &TypedValue_BoolVal{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &TypedValue_BytesVal{v}
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatVal", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &TypedValue_FloatVal{float32(math.Float32frombits(v))}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecimalVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Decimal64{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &TypedValue_DecimalVal{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaflistVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScalarArray{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &TypedValue_LeaflistVal{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Any{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &TypedValue_AnyVal{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &TypedValue_JsonVal{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonIetfVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &TypedValue_JsonIetfVal{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsciiVal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &TypedValue_AsciiVal{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &TypedValue_ProtoBytes{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Path) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Path: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Path: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Element", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Element = append(m.Element, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elem", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elem = append(m.Elem, &PathElem{})
			if err := m.Elem[len(m.Elem)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathElem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathElem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathElem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGnmi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGnmi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGnmi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGnmi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGnmi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGnmi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGnmi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGnmi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthGnmi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Key[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &types.Any{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Decimal64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decimal64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decimal64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digits", wireType)
			}
			m.Digits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Digits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalarArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalarArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalarArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Element", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Element = append(m.Element, &TypedValue{})
			if err := m.Element[len(m.Element)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubscriptionList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SubscribeRequest_Subscribe{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poll", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Poll{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SubscribeRequest_Poll{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aliases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AliasList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &SubscribeRequest_Aliases{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Poll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Poll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Poll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Notification{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SubscribeResponse_Update{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncResponse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Response = &SubscribeResponse_SyncResponse{b}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &SubscribeResponse_Error{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscriptionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscriptionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscriptionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &Path{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscription = append(m.Subscription, &Subscription{})
			if err := m.Subscription[len(m.Subscription)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAliases", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseAliases = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qos == nil {
				m.Qos = &QOSMarking{}
			}
			if err := m.Qos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= SubscriptionList_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAggregation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowAggregation = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseModels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UseModels = append(m.UseModels, &ModelData{})
			if err := m.UseModels[len(m.UseModels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatesOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatesOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= SubscriptionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleInterval", wireType)
			}
			m.SampleInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressRedundant", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuppressRedundant = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatInterval", wireType)
			}
			m.HeartbeatInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QOSMarking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QOSMarking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QOSMarking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marking", wireType)
			}
			m.Marking = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Marking |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Alias) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alias: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alias: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AliasList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AliasList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AliasList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = append(m.Alias, &Alias{})
			if err := m.Alias[len(m.Alias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &Path{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = append(m.Delete, &Path{})
			if err := m.Delete[len(m.Delete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replace = append(m.Replace, &Update{})
			if err := m.Replace[len(m.Replace)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, &Update{})
			if err := m.Update[len(m.Update)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &Path{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &UpdateResult{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Error{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &Path{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Error{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= UpdateResult_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prefix == nil {
				m.Prefix = &Path{}
			}
			if err := m.Prefix.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, &Path{})
			if err := m.Path[len(m.Path)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= GetRequest_DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseModels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UseModels = append(m.UseModels, &ModelData{})
			if err := m.UseModels[len(m.UseModels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notification = append(m.Notification, &Notification{})
			if err := m.Notification[len(m.Notification)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapabilityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapabilityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapabilityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CapabilityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapabilityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapabilityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedModels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedModels = append(m.SupportedModels, &ModelData{})
			if err := m.SupportedModels[len(m.SupportedModels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Encoding
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGnmi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Encoding(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedEncodings = append(m.SupportedEncodings, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGnmi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGnmi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGnmi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SupportedEncodings) == 0 {
					m.SupportedEncodings = make([]Encoding, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Encoding
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGnmi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Encoding(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedEncodings = append(m.SupportedEncodings, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedEncodings", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GNMIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GNMIVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &gnmi_ext.Extension{})
			if err := m.Extension[len(m.Extension)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGnmi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGnmi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGnmi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGnmi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGnmi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGnmi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGnmi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGnmi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGnmi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGnmi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGnmi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGnmi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGnmi = fmt.Errorf("proto: unexpected end of group")
)
