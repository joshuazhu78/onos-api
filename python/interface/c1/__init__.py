# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: onos/onos-ric/nb/c1-interface.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Iterable, List, Optional, Union

import betterproto
import grpclib


class StationPowerOffset(betterproto.Enum):
    """Enumerated Power offset - It is defined in E2 interface"""

    PA_DB_MINUS6 = 0
    PA_DB_MINUX4DOT77 = 1
    PA_DB_MINUS3 = 2
    PA_DB_MINUS1DOT77 = 3
    PA_DB_0 = 4
    PA_DB_1 = 5
    PA_DB_2 = 6
    PA_DB_3 = 7


class C1MessageType(betterproto.Enum):
    C1_MESSAGE_UNKNOWN = 0
    C1_GET_RNIBCELLS = 1
    C1_GET_RNIBUES = 2
    C1_GET_RNIBLINKS = 3
    C1_POST_HANDOVERS = 4
    C1_POST_RMMCONFIGURATION = 5


class C1RnibType(betterproto.Enum):
    C1_RNIB_UNKNOWN = 0
    C1_RNIB_CELL = 1
    C1_RNIB_UE = 2
    C1_RNIB_LINK = 3


class C1Xicicpa(betterproto.Enum):
    C1_XICIC_PA_DB_MINUS6 = 0
    C1_XICIC_PA_DB_MINUX4DOT77 = 1
    C1_XICIC_PA_DB_MINUS3 = 2
    C1_XICIC_PA_DB_MINUS1DOT77 = 3
    C1_XICIC_PA_DB_0 = 4
    C1_XICIC_PA_DB_1 = 5
    C1_XICIC_PA_DB_2 = 6
    C1_XICIC_PA_DB_3 = 7


@dataclass(eq=False, repr=False)
class Ecgi(betterproto.Message):
    """station's unique ID"""

    plmnid: str = betterproto.string_field(1)
    ecid: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class StationListRequest(betterproto.Message):
    """if ecgi is empty, stream all stations' information"""

    # ecgi - optional station identifier - list for all stations if not present
    ecgi: "Ecgi" = betterproto.message_field(1)
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all stations have been streamed to the client
    subscribe: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class StationInfo(betterproto.Message):
    # station's unique ID
    ecgi: "Ecgi" = betterproto.message_field(1)
    # station's maximum number of connected UEs - used for MLB
    max_num_connected_ues: int = betterproto.uint32_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class StationLinkListRequest(betterproto.Message):
    """if ECGI is empty, stream all station links' information"""

    # ecgi - optional station identifier - list for all stations if not present
    ecgi: "Ecgi" = betterproto.message_field(1)
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all stationlinks have been streamed to the client
    subscribe: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class StationLinkInfo(betterproto.Message):
    # target station ID
    ecgi: "Ecgi" = betterproto.message_field(1)
    # list of neighbor stations' ID
    neighbor_ecgi: List["Ecgi"] = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UeListRequest(betterproto.Message):
    """if ECGI is empty, stream all UEs' information"""

    # crnti - optional UE's local ID in serving station  - list for all UE local
    # IDs if not present
    crnti: str = betterproto.string_field(1)
    # ecgi - optional UE's serving station identifier - list for all stations if
    # not present
    ecgi: "Ecgi" = betterproto.message_field(2)
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all uelinks have been streamed to the client
    subscribe: bool = betterproto.bool_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UeInfo(betterproto.Message):
    # Both crnti and ecgi are used as a key in our store. UE's local ID in
    # serving station
    crnti: str = betterproto.string_field(1)
    # UE's serving station ID
    ecgi: "Ecgi" = betterproto.message_field(2)
    imsi: str = betterproto.string_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UeLinkListRequest(betterproto.Message):
    """if crnti and ecgi are empty, stream all UE links' information"""

    # crnti - optional UE's local ID in serving station  - list for all UE local
    # IDs if not present
    crnti: str = betterproto.string_field(1)
    # ecgi - optional UE's serving station identifier - list for all stations if
    # not present
    ecgi: "Ecgi" = betterproto.message_field(2)
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all uelinks have been streamed to the client
    subscribe: bool = betterproto.bool_field(3)
    # noReplay - do not replay the list of UELinks from before the request Used
    # with subscribe, to only get new changes
    no_replay: bool = betterproto.bool_field(4)
    # noimsi - imsi is not needed in the response
    noimsi: bool = betterproto.bool_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UeTputsListRequest(betterproto.Message):
    # crnti - optional UE's local ID in serving station  - list for all UE local
    # IDs if not present
    crnti: str = betterproto.string_field(1)
    # ecgi - optional UE's serving station identifier - list for all stations if
    # not present
    ecgi: "Ecgi" = betterproto.message_field(2)
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all uelinks have been streamed to the client
    subscribe: bool = betterproto.bool_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UeTputInfo(betterproto.Message):
    # Both crnti and ecgi are used as a key in our store. UE's local ID in
    # serving station
    crnti: str = betterproto.string_field(1)
    # UE's serving station ID
    ecgi: "Ecgi" = betterproto.message_field(2)
    imsi: str = betterproto.string_field(3)
    # UE downlink and uplink throughput
    throughput_dl: List[int] = betterproto.uint32_field(4)
    throughput_ul: List[int] = betterproto.uint32_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ChannelQuality(betterproto.Message):
    # Target stations's ID This target station can be either the serving station
    # or the serving station's neighbor stations.
    target_ecgi: "Ecgi" = betterproto.message_field(1)
    # CQI stands for Channel Quality Indicator in LTE, which ranges from 0 (out
    # of range) to 15 (64 QAM and 948 Code rate)
    cqi_hist: int = betterproto.uint32_field(2)
    # CQI offset when evaluating a target cell
    a3_offset_cqi: int = betterproto.int32_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UeLinkInfo(betterproto.Message):
    """
    It shows the link quality between the UE -- having crnti (1) and serviced
    by the station having ecgi (2) -- and the station -- having targetECGI (3).
    Target station can be not only UE's serving station but also the station's
    neighbor stations.
    """

    # Both crnti and ecgi are used as a key in our store. UE's local ID in
    # serving station
    crnti: str = betterproto.string_field(1)
    # UE's serving station ID
    ecgi: "Ecgi" = betterproto.message_field(2)
    # Channel quality values between the UE and its serving or neighbor stations.
    channel_qualities: List["ChannelQuality"] = betterproto.message_field(3)
    # optional value: IMSI which is a global unique UE ID  This value is from
    # UEContextUpdate message The crnti is local ID only working in a serving
    # base station. However, sometimes an app may need the unique ID Thus, add
    # IMSI as an optional.
    imsi: str = betterproto.string_field(4)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HandOverRequest(betterproto.Message):
    # UE's local ID in serving station
    crnti: str = betterproto.string_field(1)
    # UE's source station ID - serving station
    src_station: "Ecgi" = betterproto.message_field(2)
    # UE's destination station ID for handover - one of neighbor stations
    dst_station: "Ecgi" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class HandOverResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RadioPowerRequest(betterproto.Message):
    # target station's ID
    ecgi: "Ecgi" = betterproto.message_field(1)
    # target station's power offset to adjust transmission power
    offset: "StationPowerOffset" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RadioPowerResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CellPciRequest(betterproto.Message):
    # target station's ID
    ecgi: "Ecgi" = betterproto.message_field(1)
    # target station's pci
    pci: int = betterproto.uint32_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CellPciResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RequestMessage(betterproto.Message):
    header: "C1RequestMessageHeader" = betterproto.message_field(1)
    payload: "C1RequestMessagePayload" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1ResponseMessage(betterproto.Message):
    header: "C1ResponseMessageHeader" = betterproto.message_field(1)
    payload: "C1ResponseMessagePayload" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RequestMessageHeader(betterproto.Message):
    type: "C1MessageType" = betterproto.enum_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RequestMessagePayload(betterproto.Message):
    requested_rnib_type: "C1RnibType" = betterproto.enum_field(1, group="request")
    handover_request: "C1HandoverRequest" = betterproto.message_field(
        2, group="request"
    )
    rrm_configuration_request: "C1RrmConfiguration" = betterproto.message_field(
        3, group="request"
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1ResponseMessageHeader(betterproto.Message):
    type: "C1MessageType" = betterproto.enum_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1ResponseMessagePayload(betterproto.Message):
    response_code: str = betterproto.string_field(1, group="result")
    r_nib_cells: "C1RnibCells" = betterproto.message_field(2, group="result")
    r_nibu_es: "C1RnibuEs" = betterproto.message_field(3, group="result")
    r_nib_links: "C1RnibLinks" = betterproto.message_field(4, group="result")

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RnibCells(betterproto.Message):
    r_nib_cells: List["C1RnibCell"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RnibuEs(betterproto.Message):
    r_nibu_es: List["C1Rnibue"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RnibLinks(betterproto.Message):
    r_nib_links: List["C1RnibLink"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1Ecgi(betterproto.Message):
    plmn_id: str = betterproto.string_field(1)
    ecid: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1CandScell(betterproto.Message):
    pci: str = betterproto.string_field(1)
    earfcn_dl: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RnibCell(betterproto.Message):
    ecgi: "C1Ecgi" = betterproto.message_field(1)
    # attributes of R-NIB Cell for Cell Configuration
    cell_configuration: "C1CellConfigAttribute" = betterproto.message_field(2)
    # for RRM configuration
    rrm_configuration: "C1RrmConfigAttribute" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1CellConfigAttribute(betterproto.Message):
    ecgi: "C1Ecgi" = betterproto.message_field(1)
    pci: str = betterproto.string_field(2)
    cand_scells: List["C1CandScell"] = betterproto.message_field(3)
    earfcn_dl: str = betterproto.string_field(4)
    earfcn_ul: str = betterproto.string_field(5)
    rbs_per_tti_dl: str = betterproto.string_field(6)
    rbs_per_tti_ul: str = betterproto.string_field(7)
    num_tx_antenna: str = betterproto.string_field(8)
    duplex_mode: str = betterproto.string_field(9)
    max_num_connected_ues: str = betterproto.string_field(10)
    max_num_connected_bearers: str = betterproto.string_field(11)
    max_num_ues_sched_per_tti_dl: str = betterproto.string_field(12)
    max_num_ues_sched_per_tti_ul: str = betterproto.string_field(13)
    dlfs_sched_enable: str = betterproto.string_field(14)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1PciArfcn(betterproto.Message):
    pci: str = betterproto.string_field(1)
    earfcn_dl: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RrmConfigAttribute(betterproto.Message):
    """
    This attributed defined all elements as a list (repeated), but this list
    only has a single element for MWC demo -> will be extended
    """

    ecgi: "C1Ecgi" = betterproto.message_field(1)
    crnti: List[str] = betterproto.string_field(2)
    pci_arfcn: "C1PciArfcn" = betterproto.message_field(3)
    pa: List["C1Xicicpa"] = betterproto.enum_field(4)
    start_prb_dl: List[str] = betterproto.string_field(5)
    end_prb_dl: List[str] = betterproto.string_field(6)
    sub_frame_bitmask_dl: List[str] = betterproto.string_field(7)
    p0_ue_pusch: List[str] = betterproto.string_field(8)
    start_prb_ul: List[str] = betterproto.string_field(9)
    end_prb_ul: List[str] = betterproto.string_field(10)
    sub_frame_bitmask_ul: List[str] = betterproto.string_field(11)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1Rnibue(betterproto.Message):
    imsi: str = betterproto.string_field(1)
    # attributes of R-NIB UE
    crnti: str = betterproto.string_field(2)
    s_cell: "C1Ecgi" = betterproto.message_field(3)
    mme_ue_s1_ap_id: str = betterproto.string_field(4)
    enb_ue_s1_ap_id: str = betterproto.string_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RnibLinkId(betterproto.Message):
    ecgi: "C1Ecgi" = betterproto.message_field(1)
    imsi: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RadioRepPerServCellAttribute(betterproto.Message):
    """either serving cell or neighbor cell report"""

    ecgi: "C1Ecgi" = betterproto.message_field(1)
    cqi_hist: List[str] = betterproto.string_field(2)
    ri_hist: List[str] = betterproto.string_field(3)
    pusch_sinr_hist: List[str] = betterproto.string_field(4)
    pucch_sinr_hist: List[str] = betterproto.string_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RadioMeasReportPerUeAttribute(betterproto.Message):
    radio_rep_per_serv_cell: List[
        "C1RadioRepPerServCellAttribute"
    ] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RnibLink(betterproto.Message):
    link_id: "C1RnibLinkId" = betterproto.message_field(1)
    # attributes of R-NIB Link
    radio_meas_report_per_ue: "C1RadioMeasReportPerUeAttribute" = (
        betterproto.message_field(2)
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1HandoverRequest(betterproto.Message):
    # UE in links[index] should be moved from srcCells[index] to dstCell[index]
    links: "C1RnibLinks" = betterproto.message_field(1)
    src_cells: "C1RnibCells" = betterproto.message_field(2)
    dst_cells: "C1RnibCells" = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class C1RrmConfiguration(betterproto.Message):
    # targetCells[index] should have the offset pa which MLB app assigns; pa
    # value in targetCell[index] is the new value to update on RNIBCell
    target_cells: "C1RnibCells" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


class C1InterfaceServiceStub(betterproto.ServiceStub):
    async def list_stations(
        self, *, ecgi: "Ecgi" = None, subscribe: bool = False
    ) -> AsyncIterator["StationInfo"]:
        """ListStations returns a stream of base station records."""

        request = StationListRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.subscribe = subscribe

        async for response in self._unary_stream(
            "/interface.c1.C1InterfaceService/ListStations",
            request,
            StationInfo,
        ):
            yield response

    async def list_station_links(
        self, *, ecgi: "Ecgi" = None, subscribe: bool = False
    ) -> AsyncIterator["StationLinkInfo"]:
        """
        ListStationLinks returns a stream of links between neighboring base
        stations.
        """

        request = StationLinkListRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.subscribe = subscribe

        async for response in self._unary_stream(
            "/interface.c1.C1InterfaceService/ListStationLinks",
            request,
            StationLinkInfo,
        ):
            yield response

    async def list_ue_links(self) -> AsyncIterator["UeLinkInfo"]:
        """
        ListUELinks returns a stream of UI and base station links; one-time or
        (later) continuous subscribe.
        """

        request = UeLinkListRequest()

        async for response in self._unary_stream(
            "/interface.c1.C1InterfaceService/ListUELinks",
            request,
            UeLinkInfo,
        ):
            yield response

    async def list_u_es(self) -> AsyncIterator["UeInfo"]:

        request = UeListRequest()

        async for response in self._unary_stream(
            "/interface.c1.C1InterfaceService/ListUEs",
            request,
            UeInfo,
        ):
            yield response

    async def list_ue_tputs(self) -> AsyncIterator["UeTputInfo"]:
        """
        ListUETputs returns a stream of UE throughputs info; one-time or
        (later) continuous subscribe.
        """

        request = UeTputsListRequest()

        async for response in self._unary_stream(
            "/interface.c1.C1InterfaceService/ListUETputs",
            request,
            UeTputInfo,
        ):
            yield response

    async def trigger_hand_over(
        self, *, crnti: str = "", src_station: "Ecgi" = None, dst_station: "Ecgi" = None
    ) -> "HandOverResponse":
        """
        TriggerHandOver returns a hand-over response indicating success or
        failure. HO app will ask to handover to multiple UEs
        """

        request = HandOverRequest()
        request.crnti = crnti
        if src_station is not None:
            request.src_station = src_station
        if dst_station is not None:
            request.dst_station = dst_station

        return await self._unary_unary(
            "/interface.c1.C1InterfaceService/TriggerHandOver",
            request,
            HandOverResponse,
        )

    async def trigger_hand_over_stream(
        self,
        request_iterator: Union[
            AsyncIterable["HandOverRequest"], Iterable["HandOverRequest"]
        ],
    ) -> "HandOverResponse":
        """
        TriggerHandOverStream is a version that stays open all the time and
        sends HO messages as they happen
        """

        return await self._stream_unary(
            "/interface.c1.C1InterfaceService/TriggerHandOverStream",
            request_iterator,
            HandOverRequest,
            HandOverResponse,
        )

    async def set_radio_power(
        self, *, ecgi: "Ecgi" = None, offset: "StationPowerOffset" = None
    ) -> "RadioPowerResponse":
        """
        SetRadioPower returns a response indicating success or failure. MLB app
        will ask to change transmission power to multiple stations
        """

        request = RadioPowerRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.offset = offset

        return await self._unary_unary(
            "/interface.c1.C1InterfaceService/SetRadioPower",
            request,
            RadioPowerResponse,
        )

    async def set_cell_pci(
        self, *, ecgi: "Ecgi" = None, pci: int = 0
    ) -> "CellPciResponse":

        request = CellPciRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.pci = pci

        return await self._unary_unary(
            "/interface.c1.C1InterfaceService/SetCellPci", request, CellPciResponse
        )
