# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: onos/ran-simulator/trafficsim/trafficsim.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterator, List, Optional

import betterproto
import grpclib


class Type(betterproto.Enum):
    """Change event type"""

    # NONE indicates this response does not represent a modification of the
    # Change
    NONE = 0
    # ADDED is an event which occurs when a Change is added to the topology
    ADDED = 1
    # UPDATED is an event which occurs when a Change is updated
    UPDATED = 2
    # REMOVED is an event which occurs when a Change is removed from the
    # configuration
    REMOVED = 3


class UpdateType(betterproto.Enum):
    """
    In the case of an update this helps qualify the update type - add items as
    necessary
    """

    NOUPDATETYPE = 0
    # POSITION An update in position of UE only, without a change in the Tower
    # affinity
    POSITION = 1
    # TOWER An update in non-serving tower affinity (and also position) of UE
    TOWER = 2
    # HANDOVER An update of the serving tower
    HANDOVER = 3
    # THROUGHPUT An update of the average throughput
    THROUGHPUT = 4
    # HANDOVERPARAM An update of the handover parameters
    HANDOVERPARAM = 5


@dataclass(eq=False, repr=False)
class MapLayoutRequest(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListCellsRequest(betterproto.Message):
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all cells have been streamed to the client
    subscribe: bool = betterproto.bool_field(1)
    # option to request only changes that happen after the call
    without_replay: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListCellsResponse(betterproto.Message):
    # cell is the cell change on which the event occurred
    cell: "types.Cell" = betterproto.message_field(1)
    # type is a qualification of the type of change being made
    type: "Type" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListRoutesRequest(betterproto.Message):
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all routes have been streamed to the client
    subscribe: bool = betterproto.bool_field(1)
    # option to request only changes that happen after the call
    without_replay: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListRoutesResponse(betterproto.Message):
    # route is the route change on which the event occurred
    route: "types.Route" = betterproto.message_field(1)
    # type is a qualification of the type of change being made
    type: "Type" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListUesRequest(betterproto.Message):
    # subscribe indicates whether to subscribe to events (e.g. ADD, UPDATE, and
    # REMOVE) that occur after all routes have been streamed to the client
    subscribe: bool = betterproto.bool_field(1)
    # option to request only changes that happen after the call
    without_replay: bool = betterproto.bool_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ListUesResponse(betterproto.Message):
    # Ue is the UserEquipment change on which the event occurred
    ue: "types.Ue" = betterproto.message_field(1)
    # type is a qualification of the type of change being made
    type: "Type" = betterproto.enum_field(2)
    # update_type is a qualification of the type of UE change
    update_type: "UpdateType" = betterproto.enum_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SetNumberUEsRequest(betterproto.Message):
    number: int = betterproto.uint32_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SetNumberUEsResponse(betterproto.Message):
    number: int = betterproto.uint32_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class ResetMetricsMsg(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SetPathLossModelRequest(betterproto.Message):
    type: "types.PathlossModelType" = betterproto.enum_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class SetPathLossModelResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateCellsRequest(betterproto.Message):
    ecgi: "types.Ecgi" = betterproto.message_field(1)
    power_adj: float = betterproto.float_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateCellsResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateHoRequest(betterproto.Message):
    imsi: int = betterproto.uint64_field(1)
    ecgi: "types.Ecgi" = betterproto.message_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateHoResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateUeAdmissionRequest(betterproto.Message):
    imsi: int = betterproto.uint64_field(1)
    is_ue_admitted: bool = betterproto.bool_field(2)
    is_removed: bool = betterproto.bool_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateUeAdmissionResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateTputsDlMetRequest(betterproto.Message):
    imsi: int = betterproto.uint64_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateTputsDlMetResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateTelemetryMetRequest(betterproto.Message):
    ecgi: "types.Ecgi" = betterproto.message_field(1)
    crnti: str = betterproto.string_field(2)
    radio_report_serv_cells: List["RadioRepPerServCell"] = betterproto.message_field(3)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RadioRepPerServCell(betterproto.Message):
    ecgi: "types.Ecgi" = betterproto.message_field(1)
    cqi_hist: List[int] = betterproto.uint32_field(2)
    ri_hist: List[str] = betterproto.string_field(3)
    pusch_sinr_hist: List[str] = betterproto.string_field(4)
    pucch_sinr_hist: List[str] = betterproto.string_field(5)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateTelemetryMetResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetImsiByCrntiRequest(betterproto.Message):
    ecgi: "types.Ecgi" = betterproto.message_field(1)
    crnti: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetImsiByCrntiResponse(betterproto.Message):
    imsi: int = betterproto.uint64_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateCellPciRequest(betterproto.Message):
    ecgi: "types.Ecgi" = betterproto.message_field(1)
    pci: int = betterproto.uint32_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateCellPciResponse(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


class TrafficStub(betterproto.ServiceStub):
    """Traffic - provides a stream of traffic data to GUI"""

    async def get_map_layout(self) -> "types.MapLayout":

        request = MapLayoutRequest()

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/GetMapLayout", request, types.MapLayout
        )

    async def list_cells(
        self, *, subscribe: bool = False, without_replay: bool = False
    ) -> AsyncIterator["ListCellsResponse"]:

        request = ListCellsRequest()
        request.subscribe = subscribe
        request.without_replay = without_replay

        async for response in self._unary_stream(
            "/ran.trafficsim.Traffic/ListCells",
            request,
            ListCellsResponse,
        ):
            yield response

    async def list_routes(
        self, *, subscribe: bool = False, without_replay: bool = False
    ) -> AsyncIterator["ListRoutesResponse"]:

        request = ListRoutesRequest()
        request.subscribe = subscribe
        request.without_replay = without_replay

        async for response in self._unary_stream(
            "/ran.trafficsim.Traffic/ListRoutes",
            request,
            ListRoutesResponse,
        ):
            yield response

    async def list_ues(
        self, *, subscribe: bool = False, without_replay: bool = False
    ) -> AsyncIterator["ListUesResponse"]:

        request = ListUesRequest()
        request.subscribe = subscribe
        request.without_replay = without_replay

        async for response in self._unary_stream(
            "/ran.trafficsim.Traffic/ListUes",
            request,
            ListUesResponse,
        ):
            yield response

    async def set_number_u_es(self, *, number: int = 0) -> "SetNumberUEsResponse":

        request = SetNumberUEsRequest()
        request.number = number

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/SetNumberUEs", request, SetNumberUEsResponse
        )

    async def reset_metrics(self) -> "ResetMetricsMsg":

        request = ResetMetricsMsg()

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/ResetMetrics", request, ResetMetricsMsg
        )

    async def set_path_loss_model(
        self, *, type: "types.PathlossModelType" = None
    ) -> "SetPathLossModelResponse":

        request = SetPathLossModelRequest()
        request.type = type

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/SetPathLossModel",
            request,
            SetPathLossModelResponse,
        )

    async def update_cells(
        self, *, ecgi: "types.Ecgi" = None, power_adj: float = 0.0
    ) -> "UpdateCellsResponse":

        request = UpdateCellsRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.power_adj = power_adj

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/UpdateCells", request, UpdateCellsResponse
        )

    async def update_ho(
        self, *, imsi: int = 0, ecgi: "types.Ecgi" = None
    ) -> "UpdateHoResponse":

        request = UpdateHoRequest()
        request.imsi = imsi
        if ecgi is not None:
            request.ecgi = ecgi

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/UpdateHo", request, UpdateHoResponse
        )

    async def update_ue_admission(
        self, *, imsi: int = 0, is_ue_admitted: bool = False, is_removed: bool = False
    ) -> "UpdateUeAdmissionResponse":

        request = UpdateUeAdmissionRequest()
        request.imsi = imsi
        request.is_ue_admitted = is_ue_admitted
        request.is_removed = is_removed

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/UpdateUeAdmission",
            request,
            UpdateUeAdmissionResponse,
        )

    async def update_tputs_dl_met(self, *, imsi: int = 0) -> "UpdateTputsDlMetResponse":

        request = UpdateTputsDlMetRequest()
        request.imsi = imsi

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/UpdateTputsDlMet",
            request,
            UpdateTputsDlMetResponse,
        )

    async def update_telemetry_met(
        self,
        *,
        ecgi: "types.Ecgi" = None,
        crnti: str = "",
        radio_report_serv_cells: Optional[List["RadioRepPerServCell"]] = None,
    ) -> "UpdateTelemetryMetResponse":
        radio_report_serv_cells = radio_report_serv_cells or []

        request = UpdateTelemetryMetRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.crnti = crnti
        if radio_report_serv_cells is not None:
            request.radio_report_serv_cells = radio_report_serv_cells

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/UpdateTelemetryMet",
            request,
            UpdateTelemetryMetResponse,
        )

    async def get_imsi_by_crnti(
        self, *, ecgi: "types.Ecgi" = None, crnti: str = ""
    ) -> "GetImsiByCrntiResponse":

        request = GetImsiByCrntiRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.crnti = crnti

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/GetImsiByCrnti", request, GetImsiByCrntiResponse
        )

    async def update_cell_pci(
        self, *, ecgi: "types.Ecgi" = None, pci: int = 0
    ) -> "UpdateCellPciResponse":

        request = UpdateCellPciRequest()
        if ecgi is not None:
            request.ecgi = ecgi
        request.pci = pci

        return await self._unary_unary(
            "/ran.trafficsim.Traffic/UpdateCellPci", request, UpdateCellPciResponse
        )


from . import types
